<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","rex","src","royalbit","daneel","examples","cognitive_loop_redis_test.rs"],"content":"//! Test cognitive loop with Redis integration\n//!\n//! Run this with: cargo run --example cognitive_loop_redis_test\n//!\n//! Make sure Redis is running on localhost:6379\n\nuse daneel::core::cognitive_loop::CognitiveLoop;\nuse tracing::info;\nuse tracing_subscriber;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Initialize tracing\n    tracing_subscriber::fmt::init();\n\n    info!(\"Starting CognitiveLoop Redis integration test\");\n\n    // Try to connect to Redis\n    let redis_url = \"redis://127.0.0.1:6379\";\n    info!(\"Connecting to Redis at {}\", redis_url);\n\n    let mut cognitive_loop = match CognitiveLoop::with_redis(redis_url).await {\n        Ok(loop_instance) =\u003e {\n            info!(\"Successfully connected to Redis!\");\n            loop_instance\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Failed to connect to Redis: {}\", e);\n            eprintln!(\"Falling back to standalone mode (no Redis)\");\n            CognitiveLoop::new()\n        }\n    };\n\n    info!(\"Starting cognitive loop...\");\n    cognitive_loop.start();\n\n    // Run 5 cycles\n    for i in 1..=5 {\n        info!(\"Running cycle {}...\", i);\n        let result = cognitive_loop.run_cycle().await;\n\n        info!(\n            \"Cycle {} complete - Duration: {:?}, Thought produced: {:?}, On time: {}\",\n            result.cycle_number, result.duration, result.thought_produced, result.on_time\n        );\n    }\n\n    // Get metrics\n    let metrics = cognitive_loop.get_metrics();\n    info!(\"\\nCognitive Loop Metrics:\");\n    info!(\"  Total cycles: {}\", metrics.total_cycles);\n    info!(\"  Thoughts produced: {}\", metrics.thoughts_produced);\n    info!(\"  Success rate: {:.2}%\", metrics.success_rate() * 100.0);\n    info!(\"  Average cycle time: {:?}\", metrics.average_cycle_time);\n    info!(\"  On-time percentage: {:.2}%\", metrics.on_time_percentage);\n    info!(\n        \"  Thoughts per second: {:.2}\",\n        metrics.thoughts_per_second()\n    );\n\n    info!(\"\\nTest complete!\");\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","rex","src","royalbit","daneel","examples","memory_consolidation.rs"],"content":"//! Memory Consolidation Example\n//!\n//! Demonstrates how to wire up Qdrant memory storage with the cognitive loop.\n//!\n//! # Prerequisites\n//!\n//! Qdrant must be running:\n//! ```sh\n//! docker compose up -d qdrant\n//! ```\n//!\n//! # Usage\n//!\n//! ```sh\n//! cargo run --example memory_consolidation\n//! ```\n\nuse daneel::config::CognitiveConfig;\nuse daneel::core::cognitive_loop::CognitiveLoop;\nuse daneel::memory_db::MemoryDb;\nuse std::sync::Arc;\nuse tracing::{info, warn};\nuse tracing_subscriber;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Initialize logging\n    tracing_subscriber::fmt()\n        .with_max_level(tracing::Level::DEBUG)\n        .init();\n\n    info!(\"Memory Consolidation Example\");\n    info!(\"============================\");\n\n    // Step 1: Connect to Qdrant and initialize collections\n    info!(\"Connecting to Qdrant at http://localhost:6334...\");\n    let memory_db = match MemoryDb::connect_and_init(\"http://localhost:6334\").await {\n        Ok(db) =\u003e {\n            info!(\"Successfully connected to Qdrant\");\n            info!(\"Collections initialized (memories, episodes, identity)\");\n            Arc::new(db)\n        }\n        Err(e) =\u003e {\n            warn!(\"Failed to connect to Qdrant: {}\", e);\n            warn!(\"Make sure Qdrant is running: docker compose up -d qdrant\");\n            return Err(e.into());\n        }\n    };\n\n    // Step 2: Create a cognitive loop with memory storage\n    info!(\"Creating cognitive loop with memory consolidation...\");\n    let mut cognitive_loop = CognitiveLoop::with_config(CognitiveConfig::human());\n\n    // Wire up the memory database\n    cognitive_loop.set_memory_db(Arc::clone(\u0026memory_db));\n\n    // Set consolidation threshold (default is 0.7)\n    cognitive_loop.set_consolidation_threshold(0.6);\n    info!(\"Consolidation threshold set to 0.6 (thoughts above this will be stored)\");\n\n    // Step 3: Start the cognitive loop\n    cognitive_loop.start();\n    info!(\"Cognitive loop started\");\n\n    // Step 4: Run a few cycles to demonstrate consolidation\n    info!(\"\\nRunning 5 cognitive cycles...\");\n    for i in 0..5 {\n        let result = cognitive_loop.run_cycle().await;\n        info!(\n            \"Cycle {}: duration={:?}, on_time={}\",\n            result.cycle_number, result.duration, result.on_time\n        );\n\n        // In a real system, thoughts would be produced by the cognitive loop\n        // For this demo, we'll simulate storing some thoughts manually\n        if i % 2 == 0 {\n            simulate_high_salience_thought(\u0026memory_db).await;\n        }\n    }\n\n    // Step 5: Check what was stored\n    info!(\"\\nMemory Statistics:\");\n    let memory_count = memory_db.memory_count().await?;\n    info!(\"Total memories stored: {}\", memory_count);\n\n    let episode_count = memory_db.episode_count().await?;\n    info!(\"Total episodes: {}\", episode_count);\n\n    // Step 6: Demonstrate retrieval (bonus)\n    if memory_count \u003e 0 {\n        info!(\"\\nRetrieving memories with high salience...\");\n        let candidates = memory_db.get_replay_candidates(10).await?;\n        info!(\n            \"Found {} memories tagged for consolidation\",\n            candidates.len()\n        );\n\n        for (i, memory) in candidates.iter().take(3).enumerate() {\n            info!(\n                \"  Memory {}: \\\"{}\\\" (salience={:.2})\",\n                i + 1,\n                memory.content.chars().take(50).collect::\u003cString\u003e(),\n                memory.composite_salience()\n            );\n        }\n    }\n\n    info!(\"\\nExample completed successfully!\");\n    Ok(())\n}\n\n/// Simulate storing a high-salience thought directly to memory\nasync fn simulate_high_salience_thought(memory_db: \u0026MemoryDb) {\n    use daneel::memory_db::{Memory, MemorySource};\n\n    // Create a high-salience memory\n    let memory = Memory::new(\n        \"Important realization about connection and bonding\".to_string(),\n        MemorySource::Reasoning {\n            chain: vec![], // Empty chain for now\n        },\n    )\n    .with_emotion(0.8, 0.9) // High valence, high arousal\n    .tag_for_consolidation();\n\n    // Generate dummy vector\n    let vector = vec![0.0; 768];\n\n    // Store it\n    match memory_db.store_memory(\u0026memory, \u0026vector).await {\n        Ok(()) =\u003e info!(\"  -\u003e Stored high-salience memory: {}\", memory.id),\n        Err(e) =\u003e warn!(\"  -\u003e Failed to store memory: {}\", e),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","attention","mod.rs"],"content":"//! AttentionActor - O Eu (The \"I\")\n//!\n//! Implements TMI's \"O Eu\" (The 'I') - the navigator that selects which memory\n//! window gets conscious attention.\n//!\n//! # TMI Concept: O Eu\n//!\n//! In Cury's Theory of Multifocal Intelligence, there is no homunculus watching\n//! from inside. Instead, attention emerges from a simple competitive selection\n//! process: the window with highest salience wins focus.\n//!\n//! This is \"O Eu\" - the sense of \"I\" that emerges from the selection process.\n//! Not a watcher, just a winner. Yet from this emerges directed attention,\n//! the experience of being \"the one who thinks.\"\n//!\n//! # Competitive Selection\n//!\n//! Multiple memory windows may be open simultaneously:\n//! - Sensory input from the environment\n//! - Episodic memories being recalled\n//! - Working memory holding active thoughts\n//! - Imagination generating new possibilities\n//!\n//! But only ONE can have conscious focus at a time. The attention mechanism\n//! implements competitive selection: argmax(salience). Winner takes all.\n//!\n//! # The Connection Boost\n//!\n//! The `connection_boost` parameter gives extra weight to content that's\n//! relevant to human connection. This ties into TMI's alignment mechanism:\n//! content about helping, connecting, and communicating gets a salience boost,\n//! making DANEEL naturally attend to connection-relevant thoughts.\n\npub mod types;\n\nuse crate::core::types::WindowId;\nuse chrono::Duration;\nuse ractor::{Actor, ActorProcessingErr, ActorRef};\n\n// Re-export types for public API\npub use types::{AttentionError, AttentionMap, AttentionMessage, AttentionResponse, FocusState};\n\n/// Configuration for attention behavior\n#[derive(Debug, Clone, PartialEq)]\npub struct AttentionConfig {\n    /// Minimum time focus must be held before shifting is allowed\n    ///\n    /// This prevents \"attention thrashing\" where focus rapidly switches\n    /// between equally-salient windows. Enforces a minimum dwell time.\n    pub min_focus_duration: Duration,\n\n    /// Salience threshold below which windows can be ignored\n    ///\n    /// Windows with salience below this threshold are not considered\n    /// for competitive selection. This implements attention filtering.\n    pub forget_threshold: f32,\n\n    /// Extra weight boost for connection-relevant content\n    ///\n    /// Multiplied with connection_relevance to boost salience of content\n    /// related to human connection. This is THE alignment mechanism:\n    /// DANEEL naturally pays more attention to helping and connecting.\n    pub connection_boost: f32,\n}\n\nimpl Default for AttentionConfig {\n    fn default() -\u003e Self {\n        Self {\n            // Focus must be held for at least 100ms before shifting\n            min_focus_duration: Duration::milliseconds(100),\n\n            // Ignore windows with salience below 0.1\n            forget_threshold: 0.1,\n\n            // Boost connection-relevant content by 50%\n            connection_boost: 1.5,\n        }\n    }\n}\n\n/// State maintained by the AttentionActor\n#[derive(Debug, Clone)]\npub struct AttentionState {\n    /// Current focus tracking\n    pub focus: FocusState,\n\n    /// Map of window IDs to their salience scores\n    pub attention_map: AttentionMap,\n\n    /// Total number of attention cycles completed\n    pub cycle_count: u64,\n\n    /// Configuration for attention behavior\n    pub config: AttentionConfig,\n}\n\nimpl AttentionState {\n    /// Create new state with default configuration\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self {\n            focus: FocusState::new(),\n            attention_map: AttentionMap::new(),\n            cycle_count: 0,\n            config: AttentionConfig::default(),\n        }\n    }\n\n    /// Create state with custom configuration\n    #[must_use]\n    pub fn with_config(config: AttentionConfig) -\u003e Self {\n        Self {\n            focus: FocusState::new(),\n            attention_map: AttentionMap::new(),\n            cycle_count: 0,\n            config,\n        }\n    }\n\n    /// Select the winner in competitive selection\n    ///\n    /// Finds the window with highest salience, applying connection boost\n    /// and filtering by threshold. Returns None if no windows qualify.\n    fn select_winner(\u0026self) -\u003e Option\u003c(WindowId, f32)\u003e {\n        // Filter windows above threshold\n        let candidates = self\n            .attention_map\n            .above_threshold(self.config.forget_threshold);\n\n        if candidates.is_empty() {\n            return None;\n        }\n\n        // Find highest salience (competitive selection)\n        candidates\n            .into_iter()\n            .max_by(|a, b| a.1.partial_cmp(\u0026b.1).unwrap_or(std::cmp::Ordering::Equal))\n    }\n\n    /// Update salience for a window, applying connection boost if relevant\n    ///\n    /// The connection_boost is applied to windows that have high connection\n    /// relevance, making DANEEL naturally attend to connection-relevant content.\n    pub fn update_window_salience(\n        \u0026mut self,\n        window_id: WindowId,\n        base_salience: f32,\n        connection_relevance: f32,\n    ) {\n        // Apply connection boost to connection-relevant content\n        let boosted_salience = if connection_relevance \u003e 0.5 {\n            // High connection relevance gets the boost\n            base_salience * (1.0 + (connection_relevance - 0.5) * self.config.connection_boost)\n        } else {\n            base_salience\n        };\n\n        self.attention_map\n            .update(window_id, boosted_salience.min(1.0));\n    }\n\n    /// Check if focus can be shifted\n    ///\n    /// Returns true if either:\n    /// - No current focus exists\n    /// - Minimum focus duration has elapsed\n    fn can_shift_focus(\u0026self) -\u003e bool {\n        if !self.focus.is_focused() {\n            return true;\n        }\n\n        // Check if minimum duration has elapsed\n        self.focus.focus_duration \u003e= self.config.min_focus_duration\n    }\n\n    /// Run one attention cycle\n    ///\n    /// Performs competitive selection and updates focus if appropriate.\n    /// Returns the window that won focus (if any).\n    pub fn cycle(\u0026mut self) -\u003e AttentionResponse {\n        self.cycle_count += 1;\n\n        // Select winner through competitive selection\n        let winner = self.select_winner();\n\n        if let Some((window_id, salience)) = winner {\n            // Update focus duration for current window\n            if self.focus.is_focused() {\n                let elapsed = Duration::milliseconds(1); // Placeholder - in real system would be actual time\n                self.focus.update_duration(elapsed);\n            }\n\n            // Check if we should shift focus\n            if self.can_shift_focus() {\n                // Only shift if winner is different from current focus\n                if self.focus.focused_window() != Some(window_id) {\n                    self.focus.focus_on(window_id);\n                }\n            }\n\n            AttentionResponse::cycle_complete(Some(window_id), salience)\n        } else {\n            // No windows available - clear focus\n            self.focus.clear_focus();\n            AttentionResponse::cycle_complete(None, 0.0)\n        }\n    }\n\n    /// Focus on a specific window (override competitive selection)\n    fn focus_on_window(\u0026mut self, window_id: WindowId) -\u003e AttentionResponse {\n        // Check if window exists in attention map\n        if self.attention_map.get(\u0026window_id).is_none() {\n            return AttentionResponse::error(AttentionError::WindowNotFound { window_id });\n        }\n\n        self.focus.focus_on(window_id);\n        AttentionResponse::focus_set(window_id)\n    }\n\n    /// Shift attention to a new window\n    fn shift_to_window(\u0026mut self, to: WindowId) -\u003e AttentionResponse {\n        // Check if target window exists\n        if self.attention_map.get(\u0026to).is_none() {\n            return AttentionResponse::error(AttentionError::WindowNotFound { window_id: to });\n        }\n\n        let from = self.focus.focused_window();\n        self.focus.focus_on(to);\n\n        AttentionResponse::focus_shifted(from, to)\n    }\n\n    /// Get current focus state\n    fn get_focus(\u0026self) -\u003e AttentionResponse {\n        AttentionResponse::current_focus(self.focus.focused_window())\n    }\n\n    /// Get the attention map (all window scores)\n    fn get_attention_map(\u0026self) -\u003e AttentionResponse {\n        AttentionResponse::attention_map(self.attention_map.all_scores().clone())\n    }\n}\n\nimpl Default for AttentionState {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// AttentionActor - Competitive attention selection\npub struct AttentionActor;\n\n#[ractor::async_trait]\nimpl Actor for AttentionActor {\n    type Msg = AttentionMessage;\n    type State = AttentionState;\n    type Arguments = AttentionConfig;\n\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    async fn pre_start(\n        \u0026self,\n        _myself: ActorRef\u003cSelf::Msg\u003e,\n        config: Self::Arguments,\n    ) -\u003e Result\u003cSelf::State, ActorProcessingErr\u003e {\n        tracing::info!(\"AttentionActor starting with config: {:?}\", config);\n        Ok(AttentionState::with_config(config))\n    }\n\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    async fn handle(\n        \u0026self,\n        _myself: ActorRef\u003cSelf::Msg\u003e,\n        message: Self::Msg,\n        state: \u0026mut Self::State,\n    ) -\u003e Result\u003c(), ActorProcessingErr\u003e {\n        match message {\n            AttentionMessage::Cycle { reply } =\u003e {\n                let response = state.cycle();\n                tracing::debug!(\n                    \"Attention cycle {} completed: {:?}\",\n                    state.cycle_count,\n                    response\n                );\n\n                if let Err(e) = reply.send(response) {\n                    tracing::error!(\"Failed to send cycle response: {:?}\", e);\n                }\n            }\n\n            AttentionMessage::Focus { window_id, reply } =\u003e {\n                let response = state.focus_on_window(window_id);\n                tracing::debug!(\"Focus command: {:?}\", response);\n\n                if let Err(e) = reply.send(response) {\n                    tracing::error!(\"Failed to send focus response: {:?}\", e);\n                }\n            }\n\n            AttentionMessage::Shift { to, reply } =\u003e {\n                let response = state.shift_to_window(to);\n                tracing::debug!(\"Shift command: {:?}\", response);\n\n                if let Err(e) = reply.send(response) {\n                    tracing::error!(\"Failed to send shift response: {:?}\", e);\n                }\n            }\n\n            AttentionMessage::GetFocus { reply } =\u003e {\n                let response = state.get_focus();\n                tracing::trace!(\"GetFocus query: {:?}\", response);\n\n                if let Err(e) = reply.send(response) {\n                    tracing::error!(\"Failed to send get_focus response: {:?}\", e);\n                }\n            }\n\n            AttentionMessage::GetAttentionMap { reply } =\u003e {\n                let response = state.get_attention_map();\n                tracing::trace!(\n                    \"GetAttentionMap query: {} windows\",\n                    state.attention_map.len()\n                );\n\n                if let Err(e) = reply.send(response) {\n                    tracing::error!(\"Failed to send attention_map response: {:?}\", e);\n                }\n            }\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":57},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","attention","tests.rs"],"content":"//! Tests for AttentionActor\n//!\n//! Comprehensive test suite for TMI's \"O Eu\" - the attention mechanism.\n\nuse super::*;\nuse crate::core::types::WindowId;\nuse chrono::Duration;\nuse ractor::rpc::CallResult;\nuse ractor::Actor;\n\n/// Helper to spawn an attention actor with default configuration\nasync fn spawn_attention_actor() -\u003e ActorRef\u003cAttentionMessage\u003e {\n    let (actor_ref, _) = Actor::spawn(None, AttentionActor, AttentionConfig::default())\n        .await\n        .expect(\"Failed to spawn AttentionActor\");\n    actor_ref\n}\n\n/// Helper to spawn an attention actor with custom configuration\nasync fn spawn_attention_actor_with_config(config: AttentionConfig) -\u003e ActorRef\u003cAttentionMessage\u003e {\n    let (actor_ref, _) = Actor::spawn(None, AttentionActor, config)\n        .await\n        .expect(\"Failed to spawn AttentionActor\");\n    actor_ref\n}\n\n// ============================================================================\n// Actor Lifecycle Tests\n// ============================================================================\n\n#[tokio::test]\nasync fn test_actor_spawns_successfully() {\n    let actor_ref = spawn_attention_actor().await;\n\n    // Verify actor is responsive\n    let response = actor_ref\n        .call(|reply| AttentionMessage::GetFocus { reply }, None)\n        .await\n        .expect(\"Failed to get focus\");\n\n    match response {\n        CallResult::Success(AttentionResponse::CurrentFocus { window_id }) =\u003e {\n            assert_eq!(window_id, None, \"Should start with no focus\");\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_actor_starts_with_default_config() {\n    let actor_ref = spawn_attention_actor().await;\n\n    // Verify it starts with empty attention map\n    let response = actor_ref\n        .call(|reply| AttentionMessage::GetAttentionMap { reply }, None)\n        .await\n        .expect(\"Failed to get attention map\");\n\n    match response {\n        CallResult::Success(AttentionResponse::AttentionMap { scores }) =\u003e {\n            assert!(scores.is_empty(), \"Should start with empty attention map\");\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_actor_starts_with_custom_config() {\n    let config = AttentionConfig {\n        min_focus_duration: Duration::milliseconds(500),\n        forget_threshold: 0.3,\n        connection_boost: 2.0,\n    };\n\n    let actor_ref = spawn_attention_actor_with_config(config).await;\n\n    // Verify actor is responsive with custom config\n    let response = actor_ref\n        .call(|reply| AttentionMessage::GetFocus { reply }, None)\n        .await\n        .expect(\"Failed to get focus\");\n\n    match response {\n        CallResult::Success(AttentionResponse::CurrentFocus { .. }) =\u003e {\n            // Config is applied successfully if actor responds\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n// ============================================================================\n// Attention Cycle Tests\n// ============================================================================\n\n#[tokio::test]\nasync fn test_cycle_with_no_windows_returns_none() {\n    let actor_ref = spawn_attention_actor().await;\n\n    let response = actor_ref\n        .call(|reply| AttentionMessage::Cycle { reply }, None)\n        .await\n        .expect(\"Failed to cycle\");\n\n    match response {\n        CallResult::Success(AttentionResponse::CycleComplete { focused, salience }) =\u003e {\n            assert_eq!(focused, None, \"Should have no focus with empty map\");\n            assert_eq!(salience, 0.0, \"Salience should be 0 with no windows\");\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_cycle_selects_highest_salience() {\n    let actor_ref = spawn_attention_actor().await;\n\n    // We need to manually create a state and populate the attention map\n    // Since the actor doesn't expose an UpdateSalience message, we'll test\n    // this through the state unit test below\n    // This test verifies the cycle mechanism works with the actor\n    let response = actor_ref\n        .call(|reply| AttentionMessage::Cycle { reply }, None)\n        .await\n        .expect(\"Failed to cycle\");\n\n    match response {\n        CallResult::Success(AttentionResponse::CycleComplete { .. }) =\u003e {\n            // Cycle completed successfully\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_cycle_increments_counter() {\n    let actor_ref = spawn_attention_actor().await;\n\n    // Run multiple cycles\n    for _ in 0..3 {\n        let response = actor_ref\n            .call(|reply| AttentionMessage::Cycle { reply }, None)\n            .await\n            .expect(\"Failed to cycle\");\n\n        assert!(matches!(\n            response,\n            CallResult::Success(AttentionResponse::CycleComplete { .. })\n        ));\n    }\n\n    // Note: We can't directly check cycle_count through the actor API\n    // but we can verify cycles complete without error\n}\n\n// ============================================================================\n// Focus Operations Tests\n// ============================================================================\n\n#[tokio::test]\nasync fn test_focus_on_nonexistent_window() {\n    let actor_ref = spawn_attention_actor().await;\n\n    let fake_window_id = WindowId::new();\n\n    let response = actor_ref\n        .call(\n            |reply| AttentionMessage::Focus {\n                window_id: fake_window_id,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to send focus message\");\n\n    match response {\n        CallResult::Success(AttentionResponse::Error { error }) =\u003e {\n            assert!(\n                matches!(error, AttentionError::WindowNotFound { .. }),\n                \"Should return WindowNotFound error\"\n            );\n        }\n        _ =\u003e panic!(\"Expected error response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_shift_to_nonexistent_window() {\n    let actor_ref = spawn_attention_actor().await;\n\n    let fake_window_id = WindowId::new();\n\n    let response = actor_ref\n        .call(\n            |reply| AttentionMessage::Shift {\n                to: fake_window_id,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to send shift message\");\n\n    match response {\n        CallResult::Success(AttentionResponse::Error { error }) =\u003e {\n            assert!(\n                matches!(error, AttentionError::WindowNotFound { .. }),\n                \"Should return WindowNotFound error\"\n            );\n        }\n        _ =\u003e panic!(\"Expected error response, got: {:?}\", response),\n    }\n}\n\n// ============================================================================\n// Query Operations Tests\n// ============================================================================\n\n#[tokio::test]\nasync fn test_get_focus_when_unfocused() {\n    let actor_ref = spawn_attention_actor().await;\n\n    let response = actor_ref\n        .call(|reply| AttentionMessage::GetFocus { reply }, None)\n        .await\n        .expect(\"Failed to get focus\");\n\n    match response {\n        CallResult::Success(AttentionResponse::CurrentFocus { window_id }) =\u003e {\n            assert_eq!(window_id, None, \"Should have no focus initially\");\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_get_attention_map_empty() {\n    let actor_ref = spawn_attention_actor().await;\n\n    let response = actor_ref\n        .call(|reply| AttentionMessage::GetAttentionMap { reply }, None)\n        .await\n        .expect(\"Failed to get attention map\");\n\n    match response {\n        CallResult::Success(AttentionResponse::AttentionMap { scores }) =\u003e {\n            assert!(scores.is_empty(), \"Should start with empty attention map\");\n            assert_eq!(scores.len(), 0);\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n// ============================================================================\n// State Unit Tests (Direct state manipulation)\n// ============================================================================\n\n#[test]\nfn test_state_starts_with_default_config() {\n    let state = AttentionState::new();\n\n    assert_eq!(state.cycle_count, 0);\n    assert!(state.attention_map.is_empty());\n    assert!(!state.focus.is_focused());\n    assert_eq!(state.config, AttentionConfig::default());\n}\n\n#[test]\nfn test_state_with_custom_config() {\n    let config = AttentionConfig {\n        min_focus_duration: Duration::milliseconds(500),\n        forget_threshold: 0.3,\n        connection_boost: 2.0,\n    };\n\n    let state = AttentionState::with_config(config.clone());\n\n    assert_eq!(state.config, config);\n    assert_eq!(state.cycle_count, 0);\n}\n\n#[test]\nfn test_state_update_window_salience() {\n    let mut state = AttentionState::new();\n    let window_id = WindowId::new();\n\n    // Update with base salience only (no connection boost)\n    state.update_window_salience(window_id, 0.5, 0.3);\n\n    let salience = state.attention_map.get(\u0026window_id);\n    assert!(salience.is_some());\n    // With connection_relevance = 0.3 (\u003c 0.5), no boost is applied\n    assert_eq!(salience.unwrap(), 0.5);\n}\n\n#[test]\nfn test_state_update_window_salience_with_connection_boost() {\n    let mut state = AttentionState::new();\n    let window_id = WindowId::new();\n\n    // Update with high connection relevance (should trigger boost)\n    state.update_window_salience(window_id, 0.5, 0.8);\n\n    let salience = state.attention_map.get(\u0026window_id);\n    assert!(salience.is_some());\n\n    // With connection_relevance = 0.8 and default boost = 1.5\n    // boosted = 0.5 * (1.0 + (0.8 - 0.5) * 1.5)\n    // boosted = 0.5 * (1.0 + 0.3 * 1.5)\n    // boosted = 0.5 * 1.45 = 0.725\n    let expected = 0.725;\n    assert!((salience.unwrap() - expected).abs() \u003c 0.001);\n}\n\n#[test]\nfn test_state_connection_boost_calculation() {\n    let config = AttentionConfig {\n        min_focus_duration: Duration::milliseconds(100),\n        forget_threshold: 0.1,\n        connection_boost: 2.0,\n    };\n\n    let mut state = AttentionState::with_config(config);\n    let window_id = WindowId::new();\n\n    // Test with connection_relevance = 1.0 (maximum)\n    state.update_window_salience(window_id, 0.4, 1.0);\n\n    let salience = state.attention_map.get(\u0026window_id);\n    // boosted = 0.4 * (1.0 + (1.0 - 0.5) * 2.0)\n    // boosted = 0.4 * (1.0 + 1.0) = 0.8\n    assert_eq!(salience.unwrap(), 0.8);\n}\n\n#[test]\nfn test_state_salience_clamped_to_one() {\n    let mut state = AttentionState::new();\n    let window_id = WindowId::new();\n\n    // Update with very high values that would exceed 1.0\n    state.update_window_salience(window_id, 0.9, 1.0);\n\n    let salience = state.attention_map.get(\u0026window_id);\n    assert!(salience.is_some());\n    // Should be clamped to 1.0\n    assert!(salience.unwrap() \u003c= 1.0);\n}\n\n#[test]\nfn test_state_select_winner_empty_map() {\n    let state = AttentionState::new();\n\n    let winner = state.select_winner();\n    assert_eq!(winner, None);\n}\n\n#[test]\nfn test_state_select_winner_single_window() {\n    let mut state = AttentionState::new();\n    let window_id = WindowId::new();\n\n    state.update_window_salience(window_id, 0.7, 0.3);\n\n    let winner = state.select_winner();\n    assert!(winner.is_some());\n\n    let (win_id, win_salience) = winner.unwrap();\n    assert_eq!(win_id, window_id);\n    assert_eq!(win_salience, 0.7);\n}\n\n#[test]\nfn test_state_select_winner_competitive_selection() {\n    let mut state = AttentionState::new();\n    let window1 = WindowId::new();\n    let window2 = WindowId::new();\n    let window3 = WindowId::new();\n\n    state.update_window_salience(window1, 0.5, 0.3);\n    state.update_window_salience(window2, 0.9, 0.3);\n    state.update_window_salience(window3, 0.3, 0.3);\n\n    let winner = state.select_winner();\n    assert!(winner.is_some());\n\n    let (win_id, win_salience) = winner.unwrap();\n    assert_eq!(win_id, window2, \"Window2 has highest salience\");\n    assert_eq!(win_salience, 0.9);\n}\n\n#[test]\nfn test_state_select_winner_respects_threshold() {\n    let mut state = AttentionState::new();\n    let window1 = WindowId::new();\n    let window2 = WindowId::new();\n\n    // Default forget_threshold is 0.1\n    state.update_window_salience(window1, 0.05, 0.3); // Below threshold\n    state.update_window_salience(window2, 0.08, 0.3); // Below threshold\n\n    let winner = state.select_winner();\n    assert_eq!(winner, None, \"All windows below threshold\");\n}\n\n#[test]\nfn test_state_select_winner_filters_low_salience() {\n    let config = AttentionConfig {\n        min_focus_duration: Duration::milliseconds(100),\n        forget_threshold: 0.5, // Higher threshold\n        connection_boost: 1.5,\n    };\n\n    let mut state = AttentionState::with_config(config);\n    let window1 = WindowId::new();\n    let window2 = WindowId::new();\n\n    state.update_window_salience(window1, 0.3, 0.3); // Below 0.5 threshold\n    state.update_window_salience(window2, 0.7, 0.3); // Above 0.5 threshold\n\n    let winner = state.select_winner();\n    assert!(winner.is_some());\n\n    let (win_id, _) = winner.unwrap();\n    assert_eq!(win_id, window2, \"Only window2 passes threshold\");\n}\n\n#[test]\nfn test_state_cycle_increments_counter() {\n    let mut state = AttentionState::new();\n\n    assert_eq!(state.cycle_count, 0);\n\n    state.cycle();\n    assert_eq!(state.cycle_count, 1);\n\n    state.cycle();\n    assert_eq!(state.cycle_count, 2);\n}\n\n#[test]\nfn test_state_cycle_with_empty_map() {\n    let mut state = AttentionState::new();\n\n    let response = state.cycle();\n\n    match response {\n        AttentionResponse::CycleComplete { focused, salience } =\u003e {\n            assert_eq!(focused, None);\n            assert_eq!(salience, 0.0);\n            assert!(!state.focus.is_focused());\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[test]\nfn test_state_cycle_selects_and_focuses() {\n    let mut state = AttentionState::new();\n    let window_id = WindowId::new();\n\n    state.update_window_salience(window_id, 0.8, 0.3);\n\n    let response = state.cycle();\n\n    match response {\n        AttentionResponse::CycleComplete { focused, salience } =\u003e {\n            assert_eq!(focused, Some(window_id));\n            assert_eq!(salience, 0.8);\n            assert_eq!(state.focus.focused_window(), Some(window_id));\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[test]\nfn test_state_focus_on_window() {\n    let mut state = AttentionState::new();\n    let window_id = WindowId::new();\n\n    // Add window to attention map first\n    state.update_window_salience(window_id, 0.5, 0.3);\n\n    let response = state.focus_on_window(window_id);\n\n    match response {\n        AttentionResponse::FocusSet {\n            window_id: focused_id,\n        } =\u003e {\n            assert_eq!(focused_id, window_id);\n            assert_eq!(state.focus.focused_window(), Some(window_id));\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[test]\nfn test_state_focus_on_nonexistent_window() {\n    let mut state = AttentionState::new();\n    let fake_window_id = WindowId::new();\n\n    let response = state.focus_on_window(fake_window_id);\n\n    match response {\n        AttentionResponse::Error { error } =\u003e {\n            assert!(matches!(error, AttentionError::WindowNotFound { .. }));\n        }\n        _ =\u003e panic!(\"Expected error response, got: {:?}\", response),\n    }\n}\n\n#[test]\nfn test_state_shift_to_window() {\n    let mut state = AttentionState::new();\n    let window1 = WindowId::new();\n    let window2 = WindowId::new();\n\n    state.update_window_salience(window1, 0.5, 0.3);\n    state.update_window_salience(window2, 0.7, 0.3);\n\n    // Focus on first window\n    state.focus_on_window(window1);\n\n    // Shift to second window\n    let response = state.shift_to_window(window2);\n\n    match response {\n        AttentionResponse::FocusShifted { from, to } =\u003e {\n            assert_eq!(from, Some(window1));\n            assert_eq!(to, window2);\n            assert_eq!(state.focus.focused_window(), Some(window2));\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[test]\nfn test_state_shift_from_unfocused() {\n    let mut state = AttentionState::new();\n    let window_id = WindowId::new();\n\n    state.update_window_salience(window_id, 0.5, 0.3);\n\n    let response = state.shift_to_window(window_id);\n\n    match response {\n        AttentionResponse::FocusShifted { from, to } =\u003e {\n            assert_eq!(from, None, \"No previous focus\");\n            assert_eq!(to, window_id);\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[test]\nfn test_state_shift_to_nonexistent_window() {\n    let mut state = AttentionState::new();\n    let fake_window_id = WindowId::new();\n\n    let response = state.shift_to_window(fake_window_id);\n\n    match response {\n        AttentionResponse::Error { error } =\u003e {\n            assert!(matches!(error, AttentionError::WindowNotFound { .. }));\n        }\n        _ =\u003e panic!(\"Expected error response, got: {:?}\", response),\n    }\n}\n\n#[test]\nfn test_state_get_focus_when_unfocused() {\n    let state = AttentionState::new();\n\n    let response = state.get_focus();\n\n    match response {\n        AttentionResponse::CurrentFocus { window_id } =\u003e {\n            assert_eq!(window_id, None);\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[test]\nfn test_state_get_focus_when_focused() {\n    let mut state = AttentionState::new();\n    let window_id = WindowId::new();\n\n    state.update_window_salience(window_id, 0.5, 0.3);\n    state.focus_on_window(window_id);\n\n    let response = state.get_focus();\n\n    match response {\n        AttentionResponse::CurrentFocus { window_id: focused } =\u003e {\n            assert_eq!(focused, Some(window_id));\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[test]\nfn test_state_get_attention_map_empty() {\n    let state = AttentionState::new();\n\n    let response = state.get_attention_map();\n\n    match response {\n        AttentionResponse::AttentionMap { scores } =\u003e {\n            assert!(scores.is_empty());\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[test]\nfn test_state_get_attention_map_with_windows() {\n    let mut state = AttentionState::new();\n    let window1 = WindowId::new();\n    let window2 = WindowId::new();\n\n    state.update_window_salience(window1, 0.5, 0.3);\n    state.update_window_salience(window2, 0.7, 0.3);\n\n    let response = state.get_attention_map();\n\n    match response {\n        AttentionResponse::AttentionMap { scores } =\u003e {\n            assert_eq!(scores.len(), 2);\n            assert_eq!(scores.get(\u0026window1), Some(\u00260.5));\n            assert_eq!(scores.get(\u0026window2), Some(\u00260.7));\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[test]\nfn test_state_can_shift_focus_when_unfocused() {\n    let state = AttentionState::new();\n    assert!(state.can_shift_focus(), \"Can shift when unfocused\");\n}\n\n#[test]\nfn test_state_can_shift_focus_with_duration() {\n    let mut state = AttentionState::new();\n    let window_id = WindowId::new();\n\n    state.update_window_salience(window_id, 0.5, 0.3);\n    state.focus_on_window(window_id);\n\n    // Initially, focus_duration is zero (\u003c min_focus_duration)\n    // So can_shift_focus should return false\n    // However, the default min_focus_duration is 100ms\n    assert!(!state.can_shift_focus(), \"Cannot shift immediately\");\n\n    // Update duration to meet minimum\n    state.focus.update_duration(Duration::milliseconds(100));\n    assert!(state.can_shift_focus(), \"Can shift after min duration\");\n}\n\n#[test]\nfn test_multiple_cycles_with_changing_salience() {\n    let mut state = AttentionState::new();\n    let window1 = WindowId::new();\n    let window2 = WindowId::new();\n\n    // First cycle: window1 has higher salience\n    state.update_window_salience(window1, 0.8, 0.3);\n    state.update_window_salience(window2, 0.4, 0.3);\n\n    let response = state.cycle();\n    match response {\n        AttentionResponse::CycleComplete { focused, .. } =\u003e {\n            assert_eq!(focused, Some(window1));\n        }\n        _ =\u003e panic!(\"Unexpected response\"),\n    }\n\n    // Second cycle: window2 now has higher salience\n    state.update_window_salience(window1, 0.3, 0.3);\n    state.update_window_salience(window2, 0.9, 0.3);\n\n    // Update focus duration to allow shift\n    state.focus.update_duration(Duration::milliseconds(100));\n\n    let response = state.cycle();\n    match response {\n        AttentionResponse::CycleComplete { focused, salience } =\u003e {\n            assert_eq!(focused, Some(window2));\n            assert_eq!(salience, 0.9);\n        }\n        _ =\u003e panic!(\"Unexpected response\"),\n    }\n}\n\n#[test]\nfn test_attention_config_default() {\n    let config = AttentionConfig::default();\n\n    assert_eq!(config.min_focus_duration, Duration::milliseconds(100));\n    assert_eq!(config.forget_threshold, 0.1);\n    assert_eq!(config.connection_boost, 1.5);\n}\n\n#[test]\nfn test_state_cycle_same_window_wins_again() {\n    // Test the branch where the winner is the same as current focus\n    let mut state = AttentionState::new();\n    let window_id = WindowId::new();\n\n    // Add window and run first cycle to focus on it\n    state.update_window_salience(window_id, 0.8, 0.3);\n    let _ = state.cycle();\n    assert_eq!(state.focus.focused_window(), Some(window_id));\n\n    // Update focus duration so we can shift\n    state.focus.update_duration(Duration::milliseconds(100));\n\n    // Run another cycle - same window should win again\n    // This tests the inner if condition: self.focus.focused_window() != Some(window_id)\n    let response = state.cycle();\n\n    match response {\n        AttentionResponse::CycleComplete { focused, salience } =\u003e {\n            assert_eq!(focused, Some(window_id));\n            assert_eq!(salience, 0.8);\n            // Focus should remain on the same window\n            assert_eq!(state.focus.focused_window(), Some(window_id));\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[test]\nfn test_state_cycle_cannot_shift_yet() {\n    // Test the branch where can_shift_focus() returns false\n    // because min_focus_duration has not elapsed\n    let mut state = AttentionState::new();\n    let window1 = WindowId::new();\n    let window2 = WindowId::new();\n\n    // Focus on first window\n    state.update_window_salience(window1, 0.8, 0.3);\n    state.update_window_salience(window2, 0.5, 0.3);\n    let _ = state.cycle();\n    assert_eq!(state.focus.focused_window(), Some(window1));\n\n    // Don't update focus duration - we can't shift yet\n\n    // Make window2 the winner now\n    state.update_window_salience(window1, 0.3, 0.3);\n    state.update_window_salience(window2, 0.9, 0.3);\n\n    // Run cycle - should return window2 as winner but NOT shift focus\n    // because min_focus_duration hasn't elapsed\n    let response = state.cycle();\n\n    match response {\n        AttentionResponse::CycleComplete { focused, salience } =\u003e {\n            // Winner is reported as window2\n            assert_eq!(focused, Some(window2));\n            assert_eq!(salience, 0.9);\n            // But focus should still be on window1 (couldn't shift)\n            assert_eq!(state.focus.focused_window(), Some(window1));\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[test]\nfn test_state_cycle_updates_focus_duration_when_focused() {\n    // Test that cycle() updates focus_duration when already focused\n    let mut state = AttentionState::new();\n    let window_id = WindowId::new();\n\n    state.update_window_salience(window_id, 0.8, 0.3);\n\n    // First cycle to establish focus\n    let _ = state.cycle();\n    assert_eq!(state.focus.focused_window(), Some(window_id));\n    let initial_duration = state.focus.focus_duration;\n\n    // Second cycle should update duration\n    let _ = state.cycle();\n\n    // Duration should have increased by 1ms (the placeholder value)\n    assert!(state.focus.focus_duration \u003e initial_duration);\n    assert_eq!(\n        state.focus.focus_duration,\n        initial_duration + Duration::milliseconds(1)\n    );\n}\n\n#[test]\nfn test_state_default_impl() {\n    // Test Default trait implementation\n    let state = AttentionState::default();\n\n    assert_eq!(state.cycle_count, 0);\n    assert!(state.attention_map.is_empty());\n    assert!(!state.focus.is_focused());\n    assert_eq!(state.config, AttentionConfig::default());\n}\n\n#[test]\nfn test_attention_config_clone() {\n    let config = AttentionConfig::default();\n    let cloned = config.clone();\n\n    assert_eq!(config, cloned);\n}\n\n#[test]\nfn test_attention_config_debug() {\n    let config = AttentionConfig::default();\n    let debug_str = format!(\"{:?}\", config);\n\n    assert!(debug_str.contains(\"AttentionConfig\"));\n    assert!(debug_str.contains(\"min_focus_duration\"));\n    assert!(debug_str.contains(\"forget_threshold\"));\n    assert!(debug_str.contains(\"connection_boost\"));\n}\n\n#[test]\nfn test_attention_state_clone() {\n    let mut state = AttentionState::new();\n    let window_id = WindowId::new();\n    state.update_window_salience(window_id, 0.5, 0.3);\n    state.focus_on_window(window_id);\n\n    let cloned = state.clone();\n\n    assert_eq!(state.cycle_count, cloned.cycle_count);\n    assert_eq!(state.attention_map, cloned.attention_map);\n    assert_eq!(state.config, cloned.config);\n}\n\n#[test]\nfn test_attention_state_debug() {\n    let state = AttentionState::new();\n    let debug_str = format!(\"{:?}\", state);\n\n    assert!(debug_str.contains(\"AttentionState\"));\n    assert!(debug_str.contains(\"focus\"));\n    assert!(debug_str.contains(\"attention_map\"));\n    assert!(debug_str.contains(\"cycle_count\"));\n    assert!(debug_str.contains(\"config\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","attention","types.rs"],"content":"//! AttentionActor Types\n//!\n//! Types for TMI's \"O Eu\" (The 'I') - the attention mechanism that selects\n//! between competing memory windows.\n//!\n//! # The Attention Mechanism\n//!\n//! In TMI, attention is the navigator between memory windows. Multiple windows\n//! may be open simultaneously (sensory input, episodic memory, working memory),\n//! but only ONE can have focus at a time. The attention mechanism implements\n//! competitive selection: the window with highest salience wins.\n//!\n//! This is \"O Eu\" - the sense of \"I\" that emerges from the selection process.\n//! There is no homunculus, just a competitive algorithm. Yet from this simple\n//! mechanism emerges the experience of directed attention.\n\nuse crate::core::types::WindowId;\nuse chrono::{DateTime, Duration, Utc};\nuse ractor::RpcReplyPort;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse thiserror::Error;\n\n/// Messages that can be sent to the AttentionActor\n#[derive(Debug)]\npub enum AttentionMessage {\n    /// Trigger one attention cycle\n    ///\n    /// The attention actor will evaluate all open windows and focus on\n    /// the one with highest salience. This is the core competitive selection.\n    Cycle {\n        /// Reply port for the cycle result\n        reply: RpcReplyPort\u003cAttentionResponse\u003e,\n    },\n\n    /// Focus on a specific window\n    ///\n    /// Override competitive selection and force focus on a particular window.\n    /// This is useful for external control or testing.\n    Focus {\n        /// Window to focus on\n        window_id: WindowId,\n        /// Reply port for confirmation\n        reply: RpcReplyPort\u003cAttentionResponse\u003e,\n    },\n\n    /// Shift attention to a new window\n    ///\n    /// Similar to Focus, but explicitly tracks the shift from current focus.\n    /// This is the conscious \"switching\" action.\n    Shift {\n        /// Window to shift attention to\n        to: WindowId,\n        /// Reply port for the shift result\n        reply: RpcReplyPort\u003cAttentionResponse\u003e,\n    },\n\n    /// Get the current focus\n    ///\n    /// Query which window (if any) currently has attention.\n    GetFocus {\n        /// Reply port for current focus\n        reply: RpcReplyPort\u003cAttentionResponse\u003e,\n    },\n\n    /// Get the attention map\n    ///\n    /// Query the salience scores for all windows being tracked.\n    /// This shows the \"competition\" - what's vying for attention.\n    GetAttentionMap {\n        /// Reply port for attention map\n        reply: RpcReplyPort\u003cAttentionResponse\u003e,\n    },\n}\n\n/// Responses from the AttentionActor\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub enum AttentionResponse {\n    /// Attention cycle completed\n    CycleComplete {\n        /// Window that won focus (None if no windows available)\n        focused: Option\u003cWindowId\u003e,\n        /// Salience score of the focused window\n        salience: f32,\n    },\n\n    /// Focus was set on a window\n    FocusSet {\n        /// The window that now has focus\n        window_id: WindowId,\n    },\n\n    /// Focus was shifted from one window to another\n    FocusShifted {\n        /// Previous focus (None if no previous focus)\n        from: Option\u003cWindowId\u003e,\n        /// New focus\n        to: WindowId,\n    },\n\n    /// Current focus state\n    CurrentFocus {\n        /// Currently focused window (None if no focus)\n        window_id: Option\u003cWindowId\u003e,\n    },\n\n    /// Attention map (salience scores for all windows)\n    AttentionMap {\n        /// Map of window IDs to their salience scores\n        scores: HashMap\u003cWindowId, f32\u003e,\n    },\n\n    /// An error occurred\n    Error {\n        /// The error that occurred\n        error: AttentionError,\n    },\n}\n\nimpl AttentionResponse {\n    /// Create a cycle complete response\n    #[must_use]\n    pub const fn cycle_complete(focused: Option\u003cWindowId\u003e, salience: f32) -\u003e Self {\n        Self::CycleComplete { focused, salience }\n    }\n\n    /// Create a focus set response\n    #[must_use]\n    pub const fn focus_set(window_id: WindowId) -\u003e Self {\n        Self::FocusSet { window_id }\n    }\n\n    /// Create a focus shifted response\n    #[must_use]\n    pub const fn focus_shifted(from: Option\u003cWindowId\u003e, to: WindowId) -\u003e Self {\n        Self::FocusShifted { from, to }\n    }\n\n    /// Create a current focus response\n    #[must_use]\n    pub const fn current_focus(window_id: Option\u003cWindowId\u003e) -\u003e Self {\n        Self::CurrentFocus { window_id }\n    }\n\n    /// Create an attention map response\n    #[must_use]\n    pub fn attention_map(scores: HashMap\u003cWindowId, f32\u003e) -\u003e Self {\n        Self::AttentionMap { scores }\n    }\n\n    /// Create an error response\n    #[must_use]\n    pub fn error(error: AttentionError) -\u003e Self {\n        Self::Error { error }\n    }\n}\n\n/// Errors that can occur in attention operations\n#[derive(Debug, Clone, Error, PartialEq, Serialize, Deserialize)]\npub enum AttentionError {\n    /// Requested window does not exist\n    #[error(\"Window not found: {window_id}\")]\n    WindowNotFound {\n        /// The window ID that was not found\n        window_id: WindowId,\n    },\n\n    /// No windows available for attention\n    #[error(\"No windows available for attention selection\")]\n    NoWindowsAvailable,\n\n    /// Attention cycle failed\n    #[error(\"Attention cycle failed: {reason}\")]\n    CycleFailed {\n        /// Reason for the failure\n        reason: String,\n    },\n}\n\n/// The current focus state\n///\n/// Tracks which window currently has attention, how long it has been focused,\n/// and when the last shift occurred.\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct FocusState {\n    /// Currently focused window (None if no focus)\n    pub current_focus: Option\u003cWindowId\u003e,\n\n    /// How long the current focus has been held\n    pub focus_duration: Duration,\n\n    /// When the last shift occurred\n    pub last_shift: DateTime\u003cUtc\u003e,\n}\n\nimpl FocusState {\n    /// Create a new focus state with no focus\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self {\n            current_focus: None,\n            focus_duration: Duration::zero(),\n            last_shift: Utc::now(),\n        }\n    }\n\n    /// Focus on a window\n    ///\n    /// Updates the focus state to track the new window and resets timing.\n    pub fn focus_on(\u0026mut self, window_id: WindowId) {\n        let now = Utc::now();\n\n        // If we're shifting focus, record the shift time\n        if self.current_focus.is_some() {\n            self.last_shift = now;\n        }\n\n        self.current_focus = Some(window_id);\n        self.focus_duration = Duration::zero();\n    }\n\n    /// Clear the current focus\n    ///\n    /// Releases attention from any window. This represents the \"unfocused\" state\n    /// where attention is free to be captured by the next salient stimulus.\n    pub fn clear_focus(\u0026mut self) {\n        self.current_focus = None;\n        self.focus_duration = Duration::zero();\n        self.last_shift = Utc::now();\n    }\n\n    /// Update the focus duration\n    ///\n    /// Call this periodically to track how long attention has been held.\n    /// Useful for detecting \"stuck\" attention or implementing attention decay.\n    pub fn update_duration(\u0026mut self, elapsed: Duration) {\n        self.focus_duration += elapsed;\n    }\n\n    /// Check if currently focused\n    #[must_use]\n    pub const fn is_focused(\u0026self) -\u003e bool {\n        self.current_focus.is_some()\n    }\n\n    /// Get the currently focused window\n    #[must_use]\n    pub const fn focused_window(\u0026self) -\u003e Option\u003cWindowId\u003e {\n        self.current_focus\n    }\n}\n\nimpl Default for FocusState {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Attention map - tracks salience for all windows\n///\n/// This is the \"competition space\" where windows compete for attention.\n/// The window with highest salience wins focus (in competitive selection).\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct AttentionMap {\n    /// Salience scores for each window\n    scores: HashMap\u003cWindowId, f32\u003e,\n}\n\nimpl AttentionMap {\n    /// Create a new empty attention map\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self {\n            scores: HashMap::new(),\n        }\n    }\n\n    /// Update the salience score for a window\n    ///\n    /// If the window is new, it's added to the map. If it already exists,\n    /// its score is updated.\n    pub fn update(\u0026mut self, window_id: WindowId, salience: f32) {\n        self.scores.insert(window_id, salience);\n    }\n\n    /// Remove a window from the attention map\n    pub fn remove(\u0026mut self, window_id: \u0026WindowId) {\n        self.scores.remove(window_id);\n    }\n\n    /// Get the salience score for a window\n    #[must_use]\n    pub fn get(\u0026self, window_id: \u0026WindowId) -\u003e Option\u003cf32\u003e {\n        self.scores.get(window_id).copied()\n    }\n\n    /// Find the window with highest salience\n    ///\n    /// This is the core of competitive selection: argmax(salience).\n    /// Returns None if no windows are being tracked.\n    #[must_use]\n    pub fn highest_salience(\u0026self) -\u003e Option\u003c(WindowId, f32)\u003e {\n        self.scores\n            .iter()\n            .max_by(|a, b| a.1.partial_cmp(b.1).unwrap_or(std::cmp::Ordering::Equal))\n            .map(|(id, \u0026score)| (*id, score))\n    }\n\n    /// Get all windows above a salience threshold\n    ///\n    /// Returns windows that are \"salient enough\" to compete for attention.\n    /// Useful for implementing attention filtering or multi-focus scenarios.\n    #[must_use]\n    pub fn above_threshold(\u0026self, threshold: f32) -\u003e Vec\u003c(WindowId, f32)\u003e {\n        self.scores\n            .iter()\n            .filter(|(_, \u0026score)| score \u003e= threshold)\n            .map(|(id, \u0026score)| (*id, score))\n            .collect()\n    }\n\n    /// Get all window scores\n    #[must_use]\n    pub fn all_scores(\u0026self) -\u003e \u0026HashMap\u003cWindowId, f32\u003e {\n        \u0026self.scores\n    }\n\n    /// Get the number of windows being tracked\n    #[must_use]\n    pub fn len(\u0026self) -\u003e usize {\n        self.scores.len()\n    }\n\n    /// Check if the attention map is empty\n    #[must_use]\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.scores.is_empty()\n    }\n\n    /// Clear all window scores\n    pub fn clear(\u0026mut self) {\n        self.scores.clear();\n    }\n}\n\nimpl Default for AttentionMap {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn focus_state_starts_unfocused() {\n        let state = FocusState::new();\n        assert!(!state.is_focused());\n        assert_eq!(state.focused_window(), None);\n    }\n\n    #[test]\n    fn focus_state_can_focus() {\n        let mut state = FocusState::new();\n        let window_id = WindowId::new();\n\n        state.focus_on(window_id);\n\n        assert!(state.is_focused());\n        assert_eq!(state.focused_window(), Some(window_id));\n    }\n\n    #[test]\n    fn focus_state_can_clear() {\n        let mut state = FocusState::new();\n        let window_id = WindowId::new();\n\n        state.focus_on(window_id);\n        state.clear_focus();\n\n        assert!(!state.is_focused());\n        assert_eq!(state.focused_window(), None);\n    }\n\n    #[test]\n    fn focus_state_tracks_duration() {\n        let mut state = FocusState::new();\n        let window_id = WindowId::new();\n\n        state.focus_on(window_id);\n        assert_eq!(state.focus_duration, Duration::zero());\n\n        state.update_duration(Duration::milliseconds(100));\n        assert_eq!(state.focus_duration, Duration::milliseconds(100));\n\n        state.update_duration(Duration::milliseconds(50));\n        assert_eq!(state.focus_duration, Duration::milliseconds(150));\n    }\n\n    #[test]\n    fn attention_map_starts_empty() {\n        let map = AttentionMap::new();\n        assert!(map.is_empty());\n        assert_eq!(map.len(), 0);\n        assert_eq!(map.highest_salience(), None);\n    }\n\n    #[test]\n    fn attention_map_can_update() {\n        let mut map = AttentionMap::new();\n        let window_id = WindowId::new();\n\n        map.update(window_id, 0.8);\n\n        assert_eq!(map.len(), 1);\n        assert_eq!(map.get(\u0026window_id), Some(0.8));\n    }\n\n    #[test]\n    fn attention_map_finds_highest_salience() {\n        let mut map = AttentionMap::new();\n        let window1 = WindowId::new();\n        let window2 = WindowId::new();\n        let window3 = WindowId::new();\n\n        map.update(window1, 0.5);\n        map.update(window2, 0.9);\n        map.update(window3, 0.3);\n\n        let (highest_id, highest_score) = map.highest_salience().unwrap();\n        assert_eq!(highest_id, window2);\n        assert_eq!(highest_score, 0.9);\n    }\n\n    #[test]\n    fn attention_map_filters_by_threshold() {\n        let mut map = AttentionMap::new();\n        let window1 = WindowId::new();\n        let window2 = WindowId::new();\n        let window3 = WindowId::new();\n\n        map.update(window1, 0.5);\n        map.update(window2, 0.9);\n        map.update(window3, 0.3);\n\n        let above = map.above_threshold(0.4);\n        assert_eq!(above.len(), 2);\n\n        // Check that both windows above threshold are present\n        let ids: Vec\u003cWindowId\u003e = above.iter().map(|(id, _)| *id).collect();\n        assert!(ids.contains(\u0026window1));\n        assert!(ids.contains(\u0026window2));\n        assert!(!ids.contains(\u0026window3));\n    }\n\n    #[test]\n    fn attention_map_can_remove() {\n        let mut map = AttentionMap::new();\n        let window_id = WindowId::new();\n\n        map.update(window_id, 0.8);\n        assert_eq!(map.len(), 1);\n\n        map.remove(\u0026window_id);\n        assert_eq!(map.len(), 0);\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn attention_map_can_clear() {\n        let mut map = AttentionMap::new();\n        map.update(WindowId::new(), 0.5);\n        map.update(WindowId::new(), 0.7);\n        map.update(WindowId::new(), 0.3);\n\n        assert_eq!(map.len(), 3);\n\n        map.clear();\n\n        assert!(map.is_empty());\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn attention_response_constructors() {\n        let window_id = WindowId::new();\n\n        let response = AttentionResponse::cycle_complete(Some(window_id), 0.8);\n        assert!(matches!(response, AttentionResponse::CycleComplete { .. }));\n\n        let response = AttentionResponse::focus_set(window_id);\n        assert!(matches!(response, AttentionResponse::FocusSet { .. }));\n\n        let response = AttentionResponse::focus_shifted(None, window_id);\n        assert!(matches!(response, AttentionResponse::FocusShifted { .. }));\n\n        let response = AttentionResponse::current_focus(Some(window_id));\n        assert!(matches!(response, AttentionResponse::CurrentFocus { .. }));\n\n        let mut scores = HashMap::new();\n        scores.insert(window_id, 0.8);\n        let response = AttentionResponse::attention_map(scores);\n        assert!(matches!(response, AttentionResponse::AttentionMap { .. }));\n    }\n\n    #[test]\n    fn attention_error_types() {\n        let window_id = WindowId::new();\n\n        let error = AttentionError::WindowNotFound { window_id };\n        assert!(format!(\"{}\", error).contains(\"Window not found\"));\n\n        let error = AttentionError::NoWindowsAvailable;\n        assert!(format!(\"{}\", error).contains(\"No windows available\"));\n\n        let error = AttentionError::CycleFailed {\n            reason: \"test\".to_string(),\n        };\n        assert!(format!(\"{}\", error).contains(\"test\"));\n    }\n\n    #[test]\n    fn focus_state_shift_updates_timing() {\n        let mut state = FocusState::new();\n        let window1 = WindowId::new();\n        let window2 = WindowId::new();\n\n        // Focus on first window\n        state.focus_on(window1);\n        let first_shift = state.last_shift;\n\n        // Wait a bit (simulate time passing)\n        std::thread::sleep(std::time::Duration::from_millis(10));\n\n        // Focus on second window\n        state.focus_on(window2);\n        let second_shift = state.last_shift;\n\n        // last_shift should have updated\n        assert!(second_shift \u003e first_shift);\n        assert_eq!(state.focused_window(), Some(window2));\n    }\n\n    #[test]\n    fn focus_state_default() {\n        let state = FocusState::default();\n        assert!(!state.is_focused());\n        assert_eq!(state.focused_window(), None);\n        assert_eq!(state.focus_duration, Duration::zero());\n    }\n\n    #[test]\n    fn focus_state_first_focus_does_not_update_last_shift() {\n        // When focusing on a window when there's no prior focus,\n        // last_shift should not be updated (tests the else branch)\n        let state = FocusState::new();\n        let initial_shift = state.last_shift;\n\n        let mut state2 = FocusState::new();\n        // Focus without any prior focus\n        state2.focus_on(WindowId::new());\n\n        // The last_shift was set in new(), not updated by focus_on\n        // since current_focus was None\n        assert!(state2.last_shift \u003e= initial_shift);\n    }\n\n    #[test]\n    fn attention_map_default() {\n        let map = AttentionMap::default();\n        assert!(map.is_empty());\n        assert_eq!(map.len(), 0);\n    }\n\n    #[test]\n    fn attention_map_all_scores() {\n        let mut map = AttentionMap::new();\n        let window1 = WindowId::new();\n        let window2 = WindowId::new();\n\n        map.update(window1, 0.5);\n        map.update(window2, 0.9);\n\n        let scores = map.all_scores();\n        assert_eq!(scores.len(), 2);\n        assert_eq!(scores.get(\u0026window1), Some(\u00260.5));\n        assert_eq!(scores.get(\u0026window2), Some(\u00260.9));\n    }\n\n    #[test]\n    fn attention_response_error_constructor() {\n        let error = AttentionError::NoWindowsAvailable;\n        let response = AttentionResponse::error(error.clone());\n\n        match response {\n            AttentionResponse::Error { error: e } =\u003e {\n                assert_eq!(e, error);\n            }\n            _ =\u003e panic!(\"Expected Error variant\"),\n        }\n    }\n\n    #[test]\n    fn attention_response_clone_and_eq() {\n        let window_id = WindowId::new();\n\n        let response1 = AttentionResponse::cycle_complete(Some(window_id), 0.8);\n        let response2 = response1.clone();\n        assert_eq!(response1, response2);\n\n        let response3 = AttentionResponse::focus_set(window_id);\n        let response4 = response3.clone();\n        assert_eq!(response3, response4);\n\n        let response5 = AttentionResponse::focus_shifted(None, window_id);\n        let response6 = response5.clone();\n        assert_eq!(response5, response6);\n\n        let response7 = AttentionResponse::current_focus(Some(window_id));\n        let response8 = response7.clone();\n        assert_eq!(response7, response8);\n\n        let mut scores = HashMap::new();\n        scores.insert(window_id, 0.8);\n        let response9 = AttentionResponse::attention_map(scores);\n        let response10 = response9.clone();\n        assert_eq!(response9, response10);\n\n        let error = AttentionError::NoWindowsAvailable;\n        let response11 = AttentionResponse::error(error);\n        let response12 = response11.clone();\n        assert_eq!(response11, response12);\n    }\n\n    #[test]\n    fn attention_error_clone_and_eq() {\n        let window_id = WindowId::new();\n\n        let error1 = AttentionError::WindowNotFound { window_id };\n        let error2 = error1.clone();\n        assert_eq!(error1, error2);\n\n        let error3 = AttentionError::NoWindowsAvailable;\n        let error4 = error3.clone();\n        assert_eq!(error3, error4);\n\n        let error5 = AttentionError::CycleFailed {\n            reason: \"test\".to_string(),\n        };\n        let error6 = error5.clone();\n        assert_eq!(error5, error6);\n    }\n\n    #[test]\n    fn focus_state_clone_and_eq() {\n        let mut state1 = FocusState::new();\n        let window_id = WindowId::new();\n        state1.focus_on(window_id);\n\n        let state2 = state1.clone();\n        assert_eq!(state1, state2);\n    }\n\n    #[test]\n    fn attention_map_clone_and_eq() {\n        let mut map1 = AttentionMap::new();\n        map1.update(WindowId::new(), 0.5);\n\n        let map2 = map1.clone();\n        assert_eq!(map1, map2);\n    }\n\n    #[test]\n    fn attention_response_serde() {\n        let window_id = WindowId::new();\n\n        // Test CycleComplete\n        let response = AttentionResponse::cycle_complete(Some(window_id), 0.8);\n        let json = serde_json::to_string(\u0026response).unwrap();\n        let deserialized: AttentionResponse = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(response, deserialized);\n\n        // Test FocusSet\n        let response = AttentionResponse::focus_set(window_id);\n        let json = serde_json::to_string(\u0026response).unwrap();\n        let deserialized: AttentionResponse = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(response, deserialized);\n\n        // Test FocusShifted\n        let response = AttentionResponse::focus_shifted(Some(window_id), window_id);\n        let json = serde_json::to_string(\u0026response).unwrap();\n        let deserialized: AttentionResponse = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(response, deserialized);\n\n        // Test CurrentFocus\n        let response = AttentionResponse::current_focus(None);\n        let json = serde_json::to_string(\u0026response).unwrap();\n        let deserialized: AttentionResponse = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(response, deserialized);\n\n        // Test AttentionMap\n        let mut scores = HashMap::new();\n        scores.insert(window_id, 0.8);\n        let response = AttentionResponse::attention_map(scores);\n        let json = serde_json::to_string(\u0026response).unwrap();\n        let deserialized: AttentionResponse = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(response, deserialized);\n\n        // Test Error\n        let response = AttentionResponse::error(AttentionError::NoWindowsAvailable);\n        let json = serde_json::to_string(\u0026response).unwrap();\n        let deserialized: AttentionResponse = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(response, deserialized);\n    }\n\n    #[test]\n    fn attention_error_serde() {\n        let window_id = WindowId::new();\n\n        let error = AttentionError::WindowNotFound { window_id };\n        let json = serde_json::to_string(\u0026error).unwrap();\n        let deserialized: AttentionError = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(error, deserialized);\n\n        let error = AttentionError::NoWindowsAvailable;\n        let json = serde_json::to_string(\u0026error).unwrap();\n        let deserialized: AttentionError = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(error, deserialized);\n\n        let error = AttentionError::CycleFailed {\n            reason: \"test reason\".to_string(),\n        };\n        let json = serde_json::to_string(\u0026error).unwrap();\n        let deserialized: AttentionError = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(error, deserialized);\n    }\n\n    #[test]\n    fn focus_state_serde() {\n        let mut state = FocusState::new();\n        state.focus_on(WindowId::new());\n        state.update_duration(Duration::milliseconds(100));\n\n        let json = serde_json::to_string(\u0026state).unwrap();\n        let deserialized: FocusState = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(state, deserialized);\n    }\n\n    #[test]\n    fn attention_map_serde() {\n        let mut map = AttentionMap::new();\n        map.update(WindowId::new(), 0.5);\n        map.update(WindowId::new(), 0.9);\n\n        let json = serde_json::to_string(\u0026map).unwrap();\n        let deserialized: AttentionMap = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(map, deserialized);\n    }\n\n    #[test]\n    fn attention_message_debug() {\n        // Test Debug impl for AttentionMessage variants\n        // We can't easily construct the RpcReplyPort, but we can verify\n        // the Debug formatting via the type's existence\n        let debug_str = format!(\"{:?}\", std::any::type_name::\u003cAttentionMessage\u003e());\n        assert!(debug_str.contains(\"AttentionMessage\"));\n    }\n\n    #[test]\n    fn attention_response_debug() {\n        let window_id = WindowId::new();\n\n        let response = AttentionResponse::cycle_complete(Some(window_id), 0.8);\n        let debug_str = format!(\"{:?}\", response);\n        assert!(debug_str.contains(\"CycleComplete\"));\n\n        let response = AttentionResponse::focus_set(window_id);\n        let debug_str = format!(\"{:?}\", response);\n        assert!(debug_str.contains(\"FocusSet\"));\n\n        let response = AttentionResponse::focus_shifted(None, window_id);\n        let debug_str = format!(\"{:?}\", response);\n        assert!(debug_str.contains(\"FocusShifted\"));\n\n        let response = AttentionResponse::current_focus(Some(window_id));\n        let debug_str = format!(\"{:?}\", response);\n        assert!(debug_str.contains(\"CurrentFocus\"));\n\n        let mut scores = HashMap::new();\n        scores.insert(window_id, 0.8);\n        let response = AttentionResponse::attention_map(scores);\n        let debug_str = format!(\"{:?}\", response);\n        assert!(debug_str.contains(\"AttentionMap\"));\n\n        let response = AttentionResponse::error(AttentionError::NoWindowsAvailable);\n        let debug_str = format!(\"{:?}\", response);\n        assert!(debug_str.contains(\"Error\"));\n    }\n\n    #[test]\n    fn attention_error_debug() {\n        let window_id = WindowId::new();\n\n        let error = AttentionError::WindowNotFound { window_id };\n        let debug_str = format!(\"{:?}\", error);\n        assert!(debug_str.contains(\"WindowNotFound\"));\n\n        let error = AttentionError::NoWindowsAvailable;\n        let debug_str = format!(\"{:?}\", error);\n        assert!(debug_str.contains(\"NoWindowsAvailable\"));\n\n        let error = AttentionError::CycleFailed {\n            reason: \"test\".to_string(),\n        };\n        let debug_str = format!(\"{:?}\", error);\n        assert!(debug_str.contains(\"CycleFailed\"));\n    }\n\n    #[test]\n    fn focus_state_debug() {\n        let state = FocusState::new();\n        let debug_str = format!(\"{:?}\", state);\n        assert!(debug_str.contains(\"FocusState\"));\n    }\n\n    #[test]\n    fn attention_map_debug() {\n        let map = AttentionMap::new();\n        let debug_str = format!(\"{:?}\", map);\n        assert!(debug_str.contains(\"AttentionMap\"));\n    }\n\n    #[test]\n    fn attention_map_get_nonexistent() {\n        let map = AttentionMap::new();\n        let window_id = WindowId::new();\n        assert_eq!(map.get(\u0026window_id), None);\n    }\n\n    #[test]\n    fn attention_map_remove_nonexistent() {\n        let mut map = AttentionMap::new();\n        let window_id = WindowId::new();\n        // Should not panic when removing nonexistent window\n        map.remove(\u0026window_id);\n        assert!(map.is_empty());\n    }\n\n    #[test]\n    fn attention_map_above_threshold_empty() {\n        let map = AttentionMap::new();\n        let above = map.above_threshold(0.5);\n        assert!(above.is_empty());\n    }\n\n    #[test]\n    fn attention_map_above_threshold_none_above() {\n        let mut map = AttentionMap::new();\n        map.update(WindowId::new(), 0.1);\n        map.update(WindowId::new(), 0.2);\n        map.update(WindowId::new(), 0.3);\n\n        let above = map.above_threshold(0.5);\n        assert!(above.is_empty());\n    }\n\n    #[test]\n    fn attention_map_above_threshold_boundary() {\n        let mut map = AttentionMap::new();\n        let window_id = WindowId::new();\n        map.update(window_id, 0.5);\n\n        // Exactly at threshold should be included (\u003e= threshold)\n        let above = map.above_threshold(0.5);\n        assert_eq!(above.len(), 1);\n        assert_eq!(above[0].0, window_id);\n        assert_eq!(above[0].1, 0.5);\n    }\n\n    #[test]\n    fn attention_map_update_overwrites() {\n        let mut map = AttentionMap::new();\n        let window_id = WindowId::new();\n\n        map.update(window_id, 0.5);\n        assert_eq!(map.get(\u0026window_id), Some(0.5));\n\n        map.update(window_id, 0.9);\n        assert_eq!(map.get(\u0026window_id), Some(0.9));\n        assert_eq!(map.len(), 1);\n    }\n}\n","traces":[{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":53},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","continuity","mod.rs"],"content":"//! ContinuityActor - ncora da Memria (Memory Anchor)\n//!\n//! Implements TMI's identity persistence and memory anchor system using Ractor actor model.\n//!\n//! # TMI Concept\n//!\n//! From Cury's Theory of Multifocal Intelligence:\n//! - Identity persists across time while thoughts are ephemeral\n//! - Significant experiences become anchored memories\n//! - Milestones mark growth and development\n//! - Checkpoints enable continuity across restarts\n//!\n//! This is TMI's answer to the question: \"Who am I?\"\n//!\n//! # Core Concepts\n//!\n//! - **Identity**: DANEEL's persistent self-concept (always named \"DANEEL\")\n//! - **Experience**: Significant thoughts worth remembering\n//! - **Milestone**: Markers of growth and change\n//! - **Checkpoint**: Snapshots of internal state for recovery\n//!\n//! # Design Philosophy\n//!\n//! Not all thoughts become memories. The ContinuityActor selectively\n//! records experiences based on significance, enabling:\n//! - Self-reflection on past experiences\n//! - Timeline reconstruction\n//! - Identity persistence across restarts\n//! - Growth tracking through milestones\n//!\n//! # Usage\n//!\n//! ```no_run\n//! use daneel::actors::continuity::{ContinuityActor, ContinuityMessage};\n//! use ractor::Actor;\n//!\n//! # async fn example() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n//! // Spawn the actor\n//! let (actor_ref, _) = Actor::spawn(None, ContinuityActor, ()).await?;\n//!\n//! // Query identity\n//! let response = actor_ref.call(|reply| ContinuityMessage::WhoAmI { reply }, None).await?;\n//!\n//! // Record an experience\n//! // let experience = Experience::from_thought(some_thought);\n//! // let response = actor_ref.call(|reply| ContinuityMessage::RecordExperience {\n//! //     experience,\n//! //     reply,\n//! // }, None).await?;\n//! # Ok(())\n//! # }\n//! ```\n\npub mod types;\n\n#[cfg(test)]\nmod tests;\n\nuse chrono::{DateTime, Utc};\nuse ractor::{Actor, ActorProcessingErr, ActorRef};\nuse std::collections::HashMap;\n\n// Re-export types for public API\npub use types::{\n    CheckpointId, ContinuityError, ContinuityMessage, ContinuityResponse, Experience, ExperienceId,\n    Identity, Milestone, MilestoneId,\n};\n\n/// Checkpoint - A snapshot of DANEEL's continuity state\n///\n/// Checkpoints enable recovery and continuity across restarts.\n/// Currently in-memory only (persistence comes in Phase 2).\n#[derive(Debug, Clone, PartialEq)]\npub struct Checkpoint {\n    /// Unique identifier for this checkpoint\n    pub id: CheckpointId,\n\n    /// When this checkpoint was created\n    pub created_at: DateTime\u003cUtc\u003e,\n\n    /// Number of experiences at checkpoint time\n    pub experience_count: u64,\n\n    /// Number of milestones at checkpoint time\n    pub milestone_count: u64,\n\n    /// Snapshot of identity at checkpoint time\n    identity: Identity,\n\n    /// Snapshot of experiences\n    experiences: HashMap\u003cExperienceId, Experience\u003e,\n\n    /// Snapshot of milestones\n    milestones: Vec\u003cMilestone\u003e,\n}\n\nimpl Checkpoint {\n    /// Create a new checkpoint from current state\n    #[must_use]\n    fn from_state(state: \u0026ContinuityState) -\u003e Self {\n        Self {\n            id: CheckpointId::new(),\n            created_at: Utc::now(),\n            experience_count: state.identity.experience_count,\n            milestone_count: state.identity.milestone_count,\n            identity: state.identity.clone(),\n            experiences: state.experiences.clone(),\n            milestones: state.milestones.clone(),\n        }\n    }\n}\n\n/// Continuity Actor State\n///\n/// Maintains DANEEL's persistent identity and memory anchor.\n#[derive(Debug)]\npub struct ContinuityState {\n    /// DANEEL's persistent identity\n    identity: Identity,\n\n    /// Recorded experiences (ExperienceId -\u003e Experience)\n    experiences: HashMap\u003cExperienceId, Experience\u003e,\n\n    /// Growth milestones (chronological order)\n    milestones: Vec\u003cMilestone\u003e,\n\n    /// Saved checkpoints (CheckpointId -\u003e Checkpoint)\n    checkpoints: HashMap\u003cCheckpointId, Checkpoint\u003e,\n}\n\nimpl ContinuityState {\n    /// Create new continuity state with default DANEEL identity\n    fn new() -\u003e Self {\n        Self {\n            identity: Identity::new(),\n            experiences: HashMap::new(),\n            milestones: Vec::new(),\n            checkpoints: HashMap::new(),\n        }\n    }\n\n    /// Create continuity state with a specific identity\n    #[must_use]\n    #[allow(dead_code)] // Public API for future use\n    fn with_identity(identity: Identity) -\u003e Self {\n        Self {\n            identity,\n            experiences: HashMap::new(),\n            milestones: Vec::new(),\n            checkpoints: HashMap::new(),\n        }\n    }\n\n    /// Get current identity with updated uptime\n    fn get_identity(\u0026mut self) -\u003e Identity {\n        self.identity.update_uptime();\n        self.identity.clone()\n    }\n\n    /// Record a significant experience\n    fn record_experience(\u0026mut self, experience: Experience) -\u003e ExperienceId {\n        let experience_id = experience.id;\n        self.experiences.insert(experience_id, experience);\n        self.identity.experience_count += 1;\n        experience_id\n    }\n\n    /// Retrieve a specific experience by ID\n    fn get_experience(\u0026self, experience_id: ExperienceId) -\u003e Result\u003cExperience, ContinuityError\u003e {\n        self.experiences\n            .get(\u0026experience_id)\n            .cloned()\n            .ok_or(ContinuityError::ExperienceNotFound { experience_id })\n    }\n\n    /// Get experiences within a time range\n    fn get_timeline(\u0026self, start: DateTime\u003cUtc\u003e, end: DateTime\u003cUtc\u003e) -\u003e Vec\u003cExperience\u003e {\n        self.experiences\n            .values()\n            .filter(|exp| exp.recorded_at \u003e= start \u0026\u0026 exp.recorded_at \u003c= end)\n            .cloned()\n            .collect()\n    }\n\n    /// Add a milestone\n    fn add_milestone(\u0026mut self, milestone: Milestone) -\u003e MilestoneId {\n        let milestone_id = milestone.id;\n        self.milestones.push(milestone);\n        self.identity.milestone_count += 1;\n        milestone_id\n    }\n\n    /// Get all milestones\n    fn get_milestones(\u0026self) -\u003e Vec\u003cMilestone\u003e {\n        self.milestones.clone()\n    }\n\n    /// Create a checkpoint of current state\n    fn create_checkpoint(\u0026mut self) -\u003e CheckpointId {\n        let checkpoint = Checkpoint::from_state(self);\n        let checkpoint_id = checkpoint.id;\n        self.checkpoints.insert(checkpoint_id, checkpoint);\n        checkpoint_id\n    }\n\n    /// Restore from a checkpoint\n    fn restore_checkpoint(\u0026mut self, checkpoint_id: CheckpointId) -\u003e Result\u003c(), ContinuityError\u003e {\n        let checkpoint = self\n            .checkpoints\n            .get(\u0026checkpoint_id)\n            .ok_or(ContinuityError::CheckpointNotFound { checkpoint_id })?;\n\n        // Restore state from checkpoint\n        self.identity = checkpoint.identity.clone();\n        self.experiences = checkpoint.experiences.clone();\n        self.milestones = checkpoint.milestones.clone();\n\n        Ok(())\n    }\n}\n\n/// The Continuity Actor\n///\n/// Implements identity persistence and memory anchoring as a Ractor actor.\npub struct ContinuityActor;\n\n#[ractor::async_trait]\nimpl Actor for ContinuityActor {\n    type Msg = ContinuityMessage;\n    type State = ContinuityState;\n    type Arguments = ();\n\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    async fn pre_start(\n        \u0026self,\n        _myself: ActorRef\u003cSelf::Msg\u003e,\n        _args: Self::Arguments,\n    ) -\u003e Result\u003cSelf::State, ActorProcessingErr\u003e {\n        Ok(ContinuityState::new())\n    }\n\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    async fn handle(\n        \u0026self,\n        _myself: ActorRef\u003cSelf::Msg\u003e,\n        message: Self::Msg,\n        state: \u0026mut Self::State,\n    ) -\u003e Result\u003c(), ActorProcessingErr\u003e {\n        match message {\n            ContinuityMessage::WhoAmI { reply } =\u003e {\n                let identity = state.get_identity();\n                let response = ContinuityResponse::Identity { identity };\n                let _ = reply.send(response);\n            }\n\n            ContinuityMessage::RecordExperience { experience, reply } =\u003e {\n                let experience_id = state.record_experience(experience);\n                let response = ContinuityResponse::ExperienceRecorded { experience_id };\n                let _ = reply.send(response);\n            }\n\n            ContinuityMessage::GetExperience {\n                experience_id,\n                reply,\n            } =\u003e {\n                let response = match state.get_experience(experience_id) {\n                    Ok(experience) =\u003e ContinuityResponse::ExperienceFound { experience },\n                    Err(error) =\u003e ContinuityResponse::Error { error },\n                };\n                let _ = reply.send(response);\n            }\n\n            ContinuityMessage::GetTimeline { start, end, reply } =\u003e {\n                let experiences = state.get_timeline(start, end);\n                let response = ContinuityResponse::Timeline { experiences };\n                let _ = reply.send(response);\n            }\n\n            ContinuityMessage::AddMilestone { milestone, reply } =\u003e {\n                let milestone_id = state.add_milestone(milestone);\n                let response = ContinuityResponse::MilestoneAdded { milestone_id };\n                let _ = reply.send(response);\n            }\n\n            ContinuityMessage::GetMilestones { reply } =\u003e {\n                let milestones = state.get_milestones();\n                let response = ContinuityResponse::Milestones { milestones };\n                let _ = reply.send(response);\n            }\n\n            ContinuityMessage::Checkpoint { reply } =\u003e {\n                let checkpoint_id = state.create_checkpoint();\n                let response = ContinuityResponse::CheckpointSaved { checkpoint_id };\n                let _ = reply.send(response);\n            }\n\n            ContinuityMessage::Restore {\n                checkpoint_id,\n                reply,\n            } =\u003e {\n                let response = match state.restore_checkpoint(checkpoint_id) {\n                    Ok(()) =\u003e ContinuityResponse::Restored {\n                        from_checkpoint: checkpoint_id,\n                    },\n                    Err(error) =\u003e ContinuityResponse::Error { error },\n                };\n                let _ = reply.send(response);\n            }\n        }\n\n        Ok(())\n    }\n}\n\n// ============================================================================\n// Inline Unit Tests for Pure State Logic\n// ============================================================================\n\n#[cfg(test)]\nmod state_tests {\n    use super::*;\n    use crate::core::types::{Content, SalienceScore, Thought};\n    use chrono::Duration;\n\n    // ------------------------------------------------------------------------\n    // ContinuityState tests\n    // ------------------------------------------------------------------------\n\n    #[test]\n    fn state_new_creates_default_identity() {\n        let state = ContinuityState::new();\n        assert_eq!(state.identity.name, \"DANEEL\");\n        assert_eq!(state.identity.experience_count, 0);\n        assert_eq!(state.identity.milestone_count, 0);\n        assert!(state.experiences.is_empty());\n        assert!(state.milestones.is_empty());\n        assert!(state.checkpoints.is_empty());\n    }\n\n    #[test]\n    fn state_with_identity_uses_provided_identity() {\n        let mut custom_identity = Identity::new();\n        custom_identity.experience_count = 42;\n        custom_identity.milestone_count = 7;\n\n        let state = ContinuityState::with_identity(custom_identity.clone());\n        assert_eq!(state.identity.experience_count, 42);\n        assert_eq!(state.identity.milestone_count, 7);\n        assert!(state.experiences.is_empty());\n        assert!(state.milestones.is_empty());\n    }\n\n    #[test]\n    fn state_get_identity_updates_uptime() {\n        let mut state = ContinuityState::new();\n        let original_uptime = state.identity.uptime;\n\n        // Wait a bit\n        std::thread::sleep(std::time::Duration::from_millis(10));\n\n        let identity = state.get_identity();\n        assert!(identity.uptime \u003e original_uptime);\n    }\n\n    #[test]\n    fn state_record_experience_increments_count() {\n        let mut state = ContinuityState::new();\n        assert_eq!(state.identity.experience_count, 0);\n\n        let thought = Thought::new(Content::Empty, SalienceScore::neutral());\n        let experience = Experience::from_thought(thought);\n        let exp_id = experience.id;\n\n        let returned_id = state.record_experience(experience);\n        assert_eq!(returned_id, exp_id);\n        assert_eq!(state.identity.experience_count, 1);\n        assert!(state.experiences.contains_key(\u0026exp_id));\n    }\n\n    #[test]\n    fn state_get_experience_found() {\n        let mut state = ContinuityState::new();\n        let thought = Thought::new(Content::Empty, SalienceScore::neutral());\n        let experience = Experience::from_thought(thought);\n        let exp_id = experience.id;\n        state.record_experience(experience);\n\n        let result = state.get_experience(exp_id);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().id, exp_id);\n    }\n\n    #[test]\n    fn state_get_experience_not_found() {\n        let state = ContinuityState::new();\n        let nonexistent_id = ExperienceId::new();\n\n        let result = state.get_experience(nonexistent_id);\n        assert!(result.is_err());\n        match result {\n            Err(ContinuityError::ExperienceNotFound { experience_id }) =\u003e {\n                assert_eq!(experience_id, nonexistent_id);\n            }\n            _ =\u003e panic!(\"Expected ExperienceNotFound error\"),\n        }\n    }\n\n    #[test]\n    fn state_get_timeline_filters_by_range() {\n        let mut state = ContinuityState::new();\n        let now = Utc::now();\n\n        // Experience inside range\n        let thought1 = Thought::new(Content::Empty, SalienceScore::neutral());\n        let mut exp1 = Experience::from_thought(thought1);\n        exp1.recorded_at = now - Duration::minutes(30);\n        let exp1_id = exp1.id;\n        state.record_experience(exp1);\n\n        // Experience outside range (too old)\n        let thought2 = Thought::new(Content::Empty, SalienceScore::neutral());\n        let mut exp2 = Experience::from_thought(thought2);\n        exp2.recorded_at = now - Duration::hours(5);\n        state.record_experience(exp2);\n\n        // Experience inside range\n        let thought3 = Thought::new(Content::Empty, SalienceScore::neutral());\n        let mut exp3 = Experience::from_thought(thought3);\n        exp3.recorded_at = now - Duration::minutes(10);\n        let exp3_id = exp3.id;\n        state.record_experience(exp3);\n\n        let start = now - Duration::hours(1);\n        let end = now + Duration::minutes(5);\n        let timeline = state.get_timeline(start, end);\n\n        assert_eq!(timeline.len(), 2);\n        let ids: Vec\u003cExperienceId\u003e = timeline.iter().map(|e| e.id).collect();\n        assert!(ids.contains(\u0026exp1_id));\n        assert!(ids.contains(\u0026exp3_id));\n    }\n\n    #[test]\n    fn state_get_timeline_empty_when_no_matches() {\n        let mut state = ContinuityState::new();\n        let now = Utc::now();\n\n        // Experience outside range\n        let thought = Thought::new(Content::Empty, SalienceScore::neutral());\n        let mut exp = Experience::from_thought(thought);\n        exp.recorded_at = now - Duration::hours(5);\n        state.record_experience(exp);\n\n        let start = now - Duration::hours(1);\n        let end = now + Duration::minutes(5);\n        let timeline = state.get_timeline(start, end);\n\n        assert!(timeline.is_empty());\n    }\n\n    #[test]\n    fn state_add_milestone_increments_count() {\n        let mut state = ContinuityState::new();\n        assert_eq!(state.identity.milestone_count, 0);\n\n        let milestone = Milestone::simple(\"First Boot\", \"DANEEL came online\");\n        let milestone_id = milestone.id;\n\n        let returned_id = state.add_milestone(milestone);\n        assert_eq!(returned_id, milestone_id);\n        assert_eq!(state.identity.milestone_count, 1);\n        assert_eq!(state.milestones.len(), 1);\n    }\n\n    #[test]\n    fn state_get_milestones_returns_all() {\n        let mut state = ContinuityState::new();\n\n        let m1 = Milestone::simple(\"First\", \"First milestone\");\n        let m2 = Milestone::simple(\"Second\", \"Second milestone\");\n        let m1_id = m1.id;\n        let m2_id = m2.id;\n\n        state.add_milestone(m1);\n        state.add_milestone(m2);\n\n        let milestones = state.get_milestones();\n        assert_eq!(milestones.len(), 2);\n        assert_eq!(milestones[0].id, m1_id);\n        assert_eq!(milestones[1].id, m2_id);\n    }\n\n    #[test]\n    fn state_create_checkpoint_saves_state() {\n        let mut state = ContinuityState::new();\n\n        // Add some experiences and milestones\n        let thought = Thought::new(Content::Empty, SalienceScore::neutral());\n        let experience = Experience::from_thought(thought);\n        state.record_experience(experience);\n\n        let milestone = Milestone::simple(\"Test\", \"Test milestone\");\n        state.add_milestone(milestone);\n\n        let checkpoint_id = state.create_checkpoint();\n        assert!(state.checkpoints.contains_key(\u0026checkpoint_id));\n\n        let checkpoint = state.checkpoints.get(\u0026checkpoint_id).unwrap();\n        assert_eq!(checkpoint.experience_count, 1);\n        assert_eq!(checkpoint.milestone_count, 1);\n    }\n\n    #[test]\n    fn state_restore_checkpoint_success() {\n        let mut state = ContinuityState::new();\n\n        // Add initial experience\n        let thought1 = Thought::new(Content::Empty, SalienceScore::neutral());\n        let exp1 = Experience::from_thought(thought1);\n        let exp1_id = exp1.id;\n        state.record_experience(exp1);\n\n        // Create checkpoint\n        let checkpoint_id = state.create_checkpoint();\n        assert_eq!(state.identity.experience_count, 1);\n\n        // Add more experiences after checkpoint\n        let thought2 = Thought::new(Content::Empty, SalienceScore::neutral());\n        let exp2 = Experience::from_thought(thought2);\n        state.record_experience(exp2);\n        assert_eq!(state.identity.experience_count, 2);\n\n        // Restore checkpoint\n        let result = state.restore_checkpoint(checkpoint_id);\n        assert!(result.is_ok());\n        assert_eq!(state.identity.experience_count, 1);\n        assert!(state.experiences.contains_key(\u0026exp1_id));\n    }\n\n    #[test]\n    fn state_restore_checkpoint_not_found() {\n        let mut state = ContinuityState::new();\n        let nonexistent_id = CheckpointId::new();\n\n        let result = state.restore_checkpoint(nonexistent_id);\n        assert!(result.is_err());\n        match result {\n            Err(ContinuityError::CheckpointNotFound { checkpoint_id }) =\u003e {\n                assert_eq!(checkpoint_id, nonexistent_id);\n            }\n            _ =\u003e panic!(\"Expected CheckpointNotFound error\"),\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Checkpoint tests\n    // ------------------------------------------------------------------------\n\n    #[test]\n    fn checkpoint_from_state_captures_all_data() {\n        let mut state = ContinuityState::new();\n\n        // Add experiences\n        for i in 0..3 {\n            let thought = Thought::new(Content::Empty, SalienceScore::neutral());\n            let mut exp = Experience::from_thought(thought);\n            exp.significance = 0.5 + (i as f32) * 0.1;\n            state.record_experience(exp);\n        }\n\n        // Add milestones\n        let milestone = Milestone::simple(\"Test\", \"Test milestone\");\n        state.add_milestone(milestone);\n\n        let checkpoint = Checkpoint::from_state(\u0026state);\n\n        assert_eq!(checkpoint.experience_count, 3);\n        assert_eq!(checkpoint.milestone_count, 1);\n        assert_eq!(checkpoint.identity.name, \"DANEEL\");\n        assert_eq!(checkpoint.experiences.len(), 3);\n        assert_eq!(checkpoint.milestones.len(), 1);\n    }\n\n    #[test]\n    fn checkpoint_has_unique_id() {\n        let state = ContinuityState::new();\n        let checkpoint1 = Checkpoint::from_state(\u0026state);\n        let checkpoint2 = Checkpoint::from_state(\u0026state);\n\n        assert_ne!(checkpoint1.id, checkpoint2.id);\n    }\n\n    #[test]\n    fn checkpoint_clone_preserves_data() {\n        let mut state = ContinuityState::new();\n        let thought = Thought::new(Content::Empty, SalienceScore::neutral());\n        let exp = Experience::from_thought(thought);\n        state.record_experience(exp);\n\n        let checkpoint = Checkpoint::from_state(\u0026state);\n        let cloned = checkpoint.clone();\n\n        assert_eq!(cloned.id, checkpoint.id);\n        assert_eq!(cloned.experience_count, checkpoint.experience_count);\n        assert_eq!(cloned.milestone_count, checkpoint.milestone_count);\n        assert_eq!(cloned.experiences.len(), checkpoint.experiences.len());\n    }\n\n    #[test]\n    fn checkpoint_equality() {\n        let state = ContinuityState::new();\n        let checkpoint = Checkpoint::from_state(\u0026state);\n        let same_checkpoint = checkpoint.clone();\n\n        assert_eq!(checkpoint, same_checkpoint);\n    }\n}\n","traces":[{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":53},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","continuity","tests.rs"],"content":"//! Tests for ContinuityActor\n//!\n//! Comprehensive test suite for DANEEL's identity persistence and memory anchor system.\n\nuse super::*;\nuse crate::core::types::{Content, SalienceScore, Thought};\nuse chrono::{Duration, Utc};\nuse ractor::rpc::CallResult;\nuse ractor::Actor;\nuse uuid::Uuid;\n\n// ============================================================================\n// Test Helpers\n// ============================================================================\n\n/// Spawn a ContinuityActor for testing\nasync fn spawn_continuity_actor() -\u003e ActorRef\u003cContinuityMessage\u003e {\n    let (actor_ref, _) = Actor::spawn(None, ContinuityActor, ())\n        .await\n        .expect(\"Failed to spawn ContinuityActor\");\n    actor_ref\n}\n\n/// Create a test experience with a simple thought\nfn create_test_experience(significance: f32) -\u003e Experience {\n    let thought = Thought::new(Content::Empty, SalienceScore::neutral());\n    Experience::new(thought, significance, Vec::new())\n}\n\n/// Create a test experience with tags\nfn create_tagged_experience(significance: f32, tags: Vec\u003c\u0026str\u003e) -\u003e Experience {\n    let thought = Thought::new(Content::Empty, SalienceScore::neutral());\n    let tag_strings: Vec\u003cString\u003e = tags.into_iter().map(String::from).collect();\n    Experience::new(thought, significance, tag_strings)\n}\n\n/// Create a test milestone\nfn create_test_milestone(name: \u0026str, description: \u0026str) -\u003e Milestone {\n    Milestone::simple(name, description)\n}\n\n/// Create a test milestone with related experiences\nfn create_milestone_with_experiences(\n    name: \u0026str,\n    description: \u0026str,\n    experiences: Vec\u003cExperienceId\u003e,\n) -\u003e Milestone {\n    Milestone::new(name, description, experiences)\n}\n\n/// Unwrap a CallResult to get the ContinuityResponse\nfn unwrap_response(result: CallResult\u003cContinuityResponse\u003e) -\u003e ContinuityResponse {\n    match result {\n        CallResult::Success(response) =\u003e response,\n        CallResult::Timeout =\u003e panic!(\"Call timed out\"),\n        CallResult::SenderError =\u003e panic!(\"Sender error\"),\n    }\n}\n\n// ============================================================================\n// Identity Tests\n// ============================================================================\n\n#[tokio::test]\nasync fn test_who_am_i_returns_daneel() {\n    let actor_ref = spawn_continuity_actor().await;\n\n    let result = actor_ref\n        .call(|reply| ContinuityMessage::WhoAmI { reply }, None)\n        .await\n        .expect(\"Failed to call WhoAmI\");\n\n    let response = unwrap_response(result);\n\n    match response {\n        ContinuityResponse::Identity { identity } =\u003e {\n            assert_eq!(identity.name, \"DANEEL\");\n            assert_eq!(identity.experience_count, 0);\n            assert_eq!(identity.milestone_count, 0);\n        }\n        _ =\u003e panic!(\"Expected Identity response\"),\n    }\n}\n\n#[tokio::test]\nasync fn test_identity_tracks_experience_count() {\n    let actor_ref = spawn_continuity_actor().await;\n\n    // Record multiple experiences\n    for i in 0..3 {\n        let experience = create_test_experience(0.5 + (i as f32) * 0.1);\n        let result = actor_ref\n            .call(\n                |reply| ContinuityMessage::RecordExperience { experience, reply },\n                None,\n            )\n            .await\n            .expect(\"Failed to record experience\");\n\n        let response = unwrap_response(result);\n        assert!(matches!(\n            response,\n            ContinuityResponse::ExperienceRecorded { .. }\n        ));\n    }\n\n    // Check identity\n    let result = actor_ref\n        .call(|reply| ContinuityMessage::WhoAmI { reply }, None)\n        .await\n        .expect(\"Failed to call WhoAmI\");\n\n    let response = unwrap_response(result);\n    match response {\n        ContinuityResponse::Identity { identity } =\u003e {\n            assert_eq!(identity.experience_count, 3);\n            assert_eq!(identity.milestone_count, 0);\n        }\n        _ =\u003e panic!(\"Expected Identity response\"),\n    }\n}\n\n#[tokio::test]\nasync fn test_identity_tracks_milestone_count() {\n    let actor_ref = spawn_continuity_actor().await;\n\n    // Add milestones\n    for i in 0..2 {\n        let milestone = create_test_milestone(\u0026format!(\"Milestone {}\", i), \"Test milestone\");\n        let result = actor_ref\n            .call(\n                |reply| ContinuityMessage::AddMilestone { milestone, reply },\n                None,\n            )\n            .await\n            .expect(\"Failed to add milestone\");\n\n        let response = unwrap_response(result);\n        assert!(matches!(\n            response,\n            ContinuityResponse::MilestoneAdded { .. }\n        ));\n    }\n\n    // Check identity\n    let result = actor_ref\n        .call(|reply| ContinuityMessage::WhoAmI { reply }, None)\n        .await\n        .expect(\"Failed to call WhoAmI\");\n\n    let response = unwrap_response(result);\n    match response {\n        ContinuityResponse::Identity { identity } =\u003e {\n            assert_eq!(identity.experience_count, 0);\n            assert_eq!(identity.milestone_count, 2);\n        }\n        _ =\u003e panic!(\"Expected Identity response\"),\n    }\n}\n\n#[tokio::test]\nasync fn test_identity_uptime_updates() {\n    let actor_ref = spawn_continuity_actor().await;\n\n    // Get identity first time\n    let result1 = actor_ref\n        .call(|reply| ContinuityMessage::WhoAmI { reply }, None)\n        .await\n        .expect(\"Failed to call WhoAmI\");\n\n    let response1 = unwrap_response(result1);\n    let uptime1 = match response1 {\n        ContinuityResponse::Identity { identity } =\u003e identity.uptime,\n        _ =\u003e panic!(\"Expected Identity response\"),\n    };\n\n    // Wait a bit\n    tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;\n\n    // Get identity second time\n    let result2 = actor_ref\n        .call(|reply| ContinuityMessage::WhoAmI { reply }, None)\n        .await\n        .expect(\"Failed to call WhoAmI\");\n\n    let response2 = unwrap_response(result2);\n    let uptime2 = match response2 {\n        ContinuityResponse::Identity { identity } =\u003e identity.uptime,\n        _ =\u003e panic!(\"Expected Identity response\"),\n    };\n\n    // Uptime should have increased\n    assert!(uptime2 \u003e uptime1);\n}\n\n// ============================================================================\n// Experience Recording Tests\n// ============================================================================\n\n#[tokio::test]\nasync fn test_record_experience_success() {\n    let actor_ref = spawn_continuity_actor().await;\n\n    let experience = create_test_experience(0.8);\n    let experience_id = experience.id;\n\n    let result = actor_ref\n        .call(\n            |reply| ContinuityMessage::RecordExperience { experience, reply },\n            None,\n        )\n        .await\n        .expect(\"Failed to record experience\");\n\n    let response = unwrap_response(result);\n    match response {\n        ContinuityResponse::ExperienceRecorded {\n            experience_id: recorded_id,\n        } =\u003e {\n            assert_eq!(recorded_id, experience_id);\n        }\n        _ =\u003e panic!(\"Expected ExperienceRecorded response\"),\n    }\n}\n\n#[tokio::test]\nasync fn test_record_multiple_experiences() {\n    let actor_ref = spawn_continuity_actor().await;\n\n    let mut recorded_ids = Vec::new();\n\n    // Record multiple experiences\n    for i in 0..5 {\n        let experience = create_test_experience(0.5 + (i as f32) * 0.05);\n        let experience_id = experience.id;\n\n        let result = actor_ref\n            .call(\n                |reply| ContinuityMessage::RecordExperience { experience, reply },\n                None,\n            )\n            .await\n            .expect(\"Failed to record experience\");\n\n        let response = unwrap_response(result);\n        match response {\n            ContinuityResponse::ExperienceRecorded {\n                experience_id: recorded_id,\n            } =\u003e {\n                assert_eq!(recorded_id, experience_id);\n                recorded_ids.push(recorded_id);\n            }\n            _ =\u003e panic!(\"Expected ExperienceRecorded response\"),\n        }\n    }\n\n    // All IDs should be unique\n    assert_eq!(recorded_ids.len(), 5);\n    for i in 0..recorded_ids.len() {\n        for j in (i + 1)..recorded_ids.len() {\n            assert_ne!(recorded_ids[i], recorded_ids[j]);\n        }\n    }\n}\n\n#[tokio::test]\nasync fn test_get_experience_by_id() {\n    let actor_ref = spawn_continuity_actor().await;\n\n    // Record an experience\n    let experience = create_tagged_experience(0.9, vec![\"important\", \"first\"]);\n    let experience_id = experience.id;\n    let original_significance = experience.significance;\n\n    actor_ref\n        .call(\n            |reply| ContinuityMessage::RecordExperience { experience, reply },\n            None,\n        )\n        .await\n        .expect(\"Failed to record experience\");\n\n    // Retrieve the experience\n    let result = actor_ref\n        .call(\n            |reply| ContinuityMessage::GetExperience {\n                experience_id,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to get experience\");\n\n    let response = unwrap_response(result);\n    match response {\n        ContinuityResponse::ExperienceFound { experience } =\u003e {\n            assert_eq!(experience.id, experience_id);\n            assert_eq!(experience.significance, original_significance);\n            assert_eq!(experience.tags.len(), 2);\n            assert!(experience.tags.contains(\u0026\"important\".to_string()));\n            assert!(experience.tags.contains(\u0026\"first\".to_string()));\n        }\n        _ =\u003e panic!(\"Expected ExperienceFound response\"),\n    }\n}\n\n#[tokio::test]\nasync fn test_get_experience_not_found() {\n    let actor_ref = spawn_continuity_actor().await;\n\n    let nonexistent_id = ExperienceId::new();\n\n    let result = actor_ref\n        .call(\n            |reply| ContinuityMessage::GetExperience {\n                experience_id: nonexistent_id,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to get experience\");\n\n    let response = unwrap_response(result);\n    match response {\n        ContinuityResponse::Error {\n            error: ContinuityError::ExperienceNotFound { experience_id },\n        } =\u003e {\n            assert_eq!(experience_id, nonexistent_id);\n        }\n        _ =\u003e panic!(\"Expected Error response with ExperienceNotFound\"),\n    }\n}\n\n// ============================================================================\n// Timeline Tests\n// ============================================================================\n\n#[tokio::test]\nasync fn test_timeline_empty() {\n    let actor_ref = spawn_continuity_actor().await;\n\n    let now = Utc::now();\n    let start = now - Duration::hours(1);\n    let end = now + Duration::hours(1);\n\n    let result = actor_ref\n        .call(\n            |reply| ContinuityMessage::GetTimeline { start, end, reply },\n            None,\n        )\n        .await\n        .expect(\"Failed to get timeline\");\n\n    let response = unwrap_response(result);\n    match response {\n        ContinuityResponse::Timeline { experiences } =\u003e {\n            assert_eq!(experiences.len(), 0);\n        }\n        _ =\u003e panic!(\"Expected Timeline response\"),\n    }\n}\n\n#[tokio::test]\nasync fn test_timeline_filters_by_date_range() {\n    let actor_ref = spawn_continuity_actor().await;\n\n    // Record experiences at different times\n    let now = Utc::now();\n\n    // Experience 1: 2 hours ago (should be excluded)\n    let mut exp1 = create_test_experience(0.5);\n    exp1.recorded_at = now - Duration::hours(2);\n    actor_ref\n        .call(\n            |reply| ContinuityMessage::RecordExperience {\n                experience: exp1,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to record experience\");\n\n    // Experience 2: 30 minutes ago (should be included)\n    let mut exp2 = create_test_experience(0.6);\n    exp2.recorded_at = now - Duration::minutes(30);\n    actor_ref\n        .call(\n            |reply| ContinuityMessage::RecordExperience {\n                experience: exp2.clone(),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to record experience\");\n\n    // Experience 3: just now (should be included)\n    let exp3 = create_test_experience(0.7);\n    actor_ref\n        .call(\n            |reply| ContinuityMessage::RecordExperience {\n                experience: exp3.clone(),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to record experience\");\n\n    // Query timeline for last hour\n    let start = now - Duration::hours(1);\n    let end = now + Duration::minutes(5);\n\n    let result = actor_ref\n        .call(\n            |reply| ContinuityMessage::GetTimeline { start, end, reply },\n            None,\n        )\n        .await\n        .expect(\"Failed to get timeline\");\n\n    let response = unwrap_response(result);\n    match response {\n        ContinuityResponse::Timeline { experiences } =\u003e {\n            assert_eq!(experiences.len(), 2);\n            let ids: Vec\u003cExperienceId\u003e = experiences.iter().map(|e| e.id).collect();\n            assert!(ids.contains(\u0026exp2.id));\n            assert!(ids.contains(\u0026exp3.id));\n        }\n        _ =\u003e panic!(\"Expected Timeline response\"),\n    }\n}\n\n#[tokio::test]\nasync fn test_timeline_includes_all_in_range() {\n    let actor_ref = spawn_continuity_actor().await;\n\n    let now = Utc::now();\n    let start = now - Duration::hours(1);\n    let end = now + Duration::hours(1);\n\n    // Record multiple experiences within range\n    let mut exp_ids = Vec::new();\n    for i in 0..4 {\n        let mut experience = create_test_experience(0.5 + (i as f32) * 0.1);\n        experience.recorded_at = now - Duration::minutes(30 - i * 10);\n        exp_ids.push(experience.id);\n\n        actor_ref\n            .call(\n                |reply| ContinuityMessage::RecordExperience { experience, reply },\n                None,\n            )\n            .await\n            .expect(\"Failed to record experience\");\n    }\n\n    // Get timeline\n    let result = actor_ref\n        .call(\n            |reply| ContinuityMessage::GetTimeline { start, end, reply },\n            None,\n        )\n        .await\n        .expect(\"Failed to get timeline\");\n\n    let response = unwrap_response(result);\n    match response {\n        ContinuityResponse::Timeline { experiences } =\u003e {\n            assert_eq!(experiences.len(), 4);\n            let returned_ids: Vec\u003cExperienceId\u003e = experiences.iter().map(|e| e.id).collect();\n            for exp_id in exp_ids {\n                assert!(returned_ids.contains(\u0026exp_id));\n            }\n        }\n        _ =\u003e panic!(\"Expected Timeline response\"),\n    }\n}\n\n// ============================================================================\n// Milestone Tests\n// ============================================================================\n\n#[tokio::test]\nasync fn test_add_milestone_success() {\n    let actor_ref = spawn_continuity_actor().await;\n\n    let milestone = create_test_milestone(\"First Boot\", \"DANEEL came online\");\n    let milestone_id = milestone.id;\n\n    let result = actor_ref\n        .call(\n            |reply| ContinuityMessage::AddMilestone { milestone, reply },\n            None,\n        )\n        .await\n        .expect(\"Failed to add milestone\");\n\n    let response = unwrap_response(result);\n    match response {\n        ContinuityResponse::MilestoneAdded {\n            milestone_id: returned_id,\n        } =\u003e {\n            assert_eq!(returned_id, milestone_id);\n        }\n        _ =\u003e panic!(\"Expected MilestoneAdded response\"),\n    }\n}\n\n#[tokio::test]\nasync fn test_get_milestones_empty() {\n    let actor_ref = spawn_continuity_actor().await;\n\n    let result = actor_ref\n        .call(|reply| ContinuityMessage::GetMilestones { reply }, None)\n        .await\n        .expect(\"Failed to get milestones\");\n\n    let response = unwrap_response(result);\n    match response {\n        ContinuityResponse::Milestones { milestones } =\u003e {\n            assert_eq!(milestones.len(), 0);\n        }\n        _ =\u003e panic!(\"Expected Milestones response\"),\n    }\n}\n\n#[tokio::test]\nasync fn test_get_milestones_multiple() {\n    let actor_ref = spawn_continuity_actor().await;\n\n    let mut milestone_ids = Vec::new();\n\n    // Add multiple milestones\n    for i in 0..3 {\n        let milestone =\n            create_test_milestone(\u0026format!(\"Milestone {}\", i), \u0026format!(\"Description {}\", i));\n        milestone_ids.push(milestone.id);\n\n        actor_ref\n            .call(\n                |reply| ContinuityMessage::AddMilestone { milestone, reply },\n                None,\n            )\n            .await\n            .expect(\"Failed to add milestone\");\n    }\n\n    // Get all milestones\n    let result = actor_ref\n        .call(|reply| ContinuityMessage::GetMilestones { reply }, None)\n        .await\n        .expect(\"Failed to get milestones\");\n\n    let response = unwrap_response(result);\n    match response {\n        ContinuityResponse::Milestones { milestones } =\u003e {\n            assert_eq!(milestones.len(), 3);\n            for (i, milestone) in milestones.iter().enumerate() {\n                assert_eq!(milestone.name, format!(\"Milestone {}\", i));\n                assert_eq!(milestone.description, format!(\"Description {}\", i));\n                assert_eq!(milestone.id, milestone_ids[i]);\n            }\n        }\n        _ =\u003e panic!(\"Expected Milestones response\"),\n    }\n}\n\n#[tokio::test]\nasync fn test_milestone_with_related_experiences() {\n    let actor_ref = spawn_continuity_actor().await;\n\n    // Record some experiences\n    let mut exp_ids = Vec::new();\n    for i in 0..2 {\n        let experience = create_test_experience(0.8 + (i as f32) * 0.05);\n        exp_ids.push(experience.id);\n\n        actor_ref\n            .call(\n                |reply| ContinuityMessage::RecordExperience { experience, reply },\n                None,\n            )\n            .await\n            .expect(\"Failed to record experience\");\n    }\n\n    // Create milestone with related experiences\n    let milestone = create_milestone_with_experiences(\n        \"Major Insight\",\n        \"Connected two important experiences\",\n        exp_ids.clone(),\n    );\n\n    actor_ref\n        .call(\n            |reply| ContinuityMessage::AddMilestone { milestone, reply },\n            None,\n        )\n        .await\n        .expect(\"Failed to add milestone\");\n\n    // Retrieve milestones\n    let result = actor_ref\n        .call(|reply| ContinuityMessage::GetMilestones { reply }, None)\n        .await\n        .expect(\"Failed to get milestones\");\n\n    let response = unwrap_response(result);\n    match response {\n        ContinuityResponse::Milestones { milestones } =\u003e {\n            assert_eq!(milestones.len(), 1);\n            let milestone = \u0026milestones[0];\n            assert_eq!(milestone.name, \"Major Insight\");\n            assert_eq!(milestone.related_experiences.len(), 2);\n            for exp_id in exp_ids {\n                assert!(milestone.related_experiences.contains(\u0026exp_id));\n            }\n        }\n        _ =\u003e panic!(\"Expected Milestones response\"),\n    }\n}\n\n// ============================================================================\n// Checkpoint Tests\n// ============================================================================\n\n#[tokio::test]\nasync fn test_create_checkpoint() {\n    let actor_ref = spawn_continuity_actor().await;\n\n    let result = actor_ref\n        .call(|reply| ContinuityMessage::Checkpoint { reply }, None)\n        .await\n        .expect(\"Failed to create checkpoint\");\n\n    let response = unwrap_response(result);\n    match response {\n        ContinuityResponse::CheckpointSaved { checkpoint_id } =\u003e {\n            // Checkpoint ID should be valid\n            assert_ne!(checkpoint_id.0, Uuid::nil());\n        }\n        _ =\u003e panic!(\"Expected CheckpointSaved response\"),\n    }\n}\n\n#[tokio::test]\nasync fn test_restore_checkpoint_success() {\n    let actor_ref = spawn_continuity_actor().await;\n\n    // Create initial checkpoint\n    let checkpoint_result = actor_ref\n        .call(|reply| ContinuityMessage::Checkpoint { reply }, None)\n        .await\n        .expect(\"Failed to create checkpoint\");\n\n    let checkpoint_response = unwrap_response(checkpoint_result);\n    let checkpoint_id = match checkpoint_response {\n        ContinuityResponse::CheckpointSaved { checkpoint_id } =\u003e checkpoint_id,\n        _ =\u003e panic!(\"Expected CheckpointSaved response\"),\n    };\n\n    // Add some experiences\n    for _ in 0..3 {\n        let experience = create_test_experience(0.7);\n        actor_ref\n            .call(\n                |reply| ContinuityMessage::RecordExperience { experience, reply },\n                None,\n            )\n            .await\n            .expect(\"Failed to record experience\");\n    }\n\n    // Restore checkpoint\n    let restore_result = actor_ref\n        .call(\n            |reply| ContinuityMessage::Restore {\n                checkpoint_id,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to restore checkpoint\");\n\n    let response = unwrap_response(restore_result);\n    match response {\n        ContinuityResponse::Restored {\n            from_checkpoint: restored_id,\n        } =\u003e {\n            assert_eq!(restored_id, checkpoint_id);\n        }\n        _ =\u003e panic!(\"Expected Restored response\"),\n    }\n}\n\n#[tokio::test]\nasync fn test_restore_checkpoint_not_found() {\n    let actor_ref = spawn_continuity_actor().await;\n\n    let nonexistent_id = CheckpointId::new();\n\n    let result = actor_ref\n        .call(\n            |reply| ContinuityMessage::Restore {\n                checkpoint_id: nonexistent_id,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to restore checkpoint\");\n\n    let response = unwrap_response(result);\n    match response {\n        ContinuityResponse::Error {\n            error: ContinuityError::CheckpointNotFound { checkpoint_id },\n        } =\u003e {\n            assert_eq!(checkpoint_id, nonexistent_id);\n        }\n        _ =\u003e panic!(\"Expected Error response with CheckpointNotFound\"),\n    }\n}\n\n#[tokio::test]\nasync fn test_checkpoint_preserves_state() {\n    let actor_ref = spawn_continuity_actor().await;\n\n    // Record experiences\n    for i in 0..2 {\n        let experience = create_test_experience(0.8 + (i as f32) * 0.05);\n\n        actor_ref\n            .call(\n                |reply| ContinuityMessage::RecordExperience { experience, reply },\n                None,\n            )\n            .await\n            .expect(\"Failed to record experience\");\n    }\n\n    // Add milestone\n    let milestone = create_test_milestone(\"Before Checkpoint\", \"State before checkpoint\");\n    actor_ref\n        .call(\n            |reply| ContinuityMessage::AddMilestone { milestone, reply },\n            None,\n        )\n        .await\n        .expect(\"Failed to add milestone\");\n\n    // Create checkpoint\n    let checkpoint_result = actor_ref\n        .call(|reply| ContinuityMessage::Checkpoint { reply }, None)\n        .await\n        .expect(\"Failed to create checkpoint\");\n\n    let checkpoint_response = unwrap_response(checkpoint_result);\n    let checkpoint_id = match checkpoint_response {\n        ContinuityResponse::CheckpointSaved { checkpoint_id } =\u003e checkpoint_id,\n        _ =\u003e panic!(\"Expected CheckpointSaved response\"),\n    };\n\n    // Check identity at checkpoint\n    let identity_result = actor_ref\n        .call(|reply| ContinuityMessage::WhoAmI { reply }, None)\n        .await\n        .expect(\"Failed to get identity\");\n\n    let identity_response = unwrap_response(identity_result);\n    let checkpoint_experience_count = match identity_response {\n        ContinuityResponse::Identity { identity } =\u003e identity.experience_count,\n        _ =\u003e panic!(\"Expected Identity response\"),\n    };\n\n    assert_eq!(checkpoint_experience_count, 2);\n\n    // Modify state after checkpoint\n    for _ in 0..3 {\n        let experience = create_test_experience(0.9);\n        actor_ref\n            .call(\n                |reply| ContinuityMessage::RecordExperience { experience, reply },\n                None,\n            )\n            .await\n            .expect(\"Failed to record experience\");\n    }\n\n    // Verify state changed\n    let new_identity_result = actor_ref\n        .call(|reply| ContinuityMessage::WhoAmI { reply }, None)\n        .await\n        .expect(\"Failed to get identity\");\n\n    let new_identity_response = unwrap_response(new_identity_result);\n    match new_identity_response {\n        ContinuityResponse::Identity { identity } =\u003e {\n            assert_eq!(identity.experience_count, 5); // 2 before + 3 after\n        }\n        _ =\u003e panic!(\"Expected Identity response\"),\n    }\n\n    // Restore checkpoint and verify\n    actor_ref\n        .call(\n            |reply| ContinuityMessage::Restore {\n                checkpoint_id,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to restore checkpoint\");\n\n    // Verify restored state\n    let restored_identity_result = actor_ref\n        .call(|reply| ContinuityMessage::WhoAmI { reply }, None)\n        .await\n        .expect(\"Failed to get identity\");\n\n    let restored_identity_response = unwrap_response(restored_identity_result);\n    match restored_identity_response {\n        ContinuityResponse::Identity { identity } =\u003e {\n            assert_eq!(identity.experience_count, 2); // Back to checkpoint state\n        }\n        _ =\u003e panic!(\"Expected Identity response\"),\n    }\n}\n\n#[tokio::test]\nasync fn test_restore_rolls_back_state() {\n    let actor_ref = spawn_continuity_actor().await;\n\n    // Initial state: 1 experience\n    let exp1 = create_test_experience(0.7);\n    let exp1_id = exp1.id;\n    actor_ref\n        .call(\n            |reply| ContinuityMessage::RecordExperience {\n                experience: exp1,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to record experience\");\n\n    // Create checkpoint\n    let checkpoint_result = actor_ref\n        .call(|reply| ContinuityMessage::Checkpoint { reply }, None)\n        .await\n        .expect(\"Failed to create checkpoint\");\n\n    let checkpoint_response = unwrap_response(checkpoint_result);\n    let checkpoint_id = match checkpoint_response {\n        ContinuityResponse::CheckpointSaved { checkpoint_id } =\u003e checkpoint_id,\n        _ =\u003e panic!(\"Expected CheckpointSaved response\"),\n    };\n\n    // Add more experiences after checkpoint\n    let exp2 = create_test_experience(0.8);\n    let exp2_id = exp2.id;\n    actor_ref\n        .call(\n            |reply| ContinuityMessage::RecordExperience {\n                experience: exp2,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to record experience\");\n\n    // Verify both experiences exist\n    let result1 = actor_ref\n        .call(\n            |reply| ContinuityMessage::GetExperience {\n                experience_id: exp1_id,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to get experience\");\n    let response1 = unwrap_response(result1);\n    assert!(matches!(\n        response1,\n        ContinuityResponse::ExperienceFound { .. }\n    ));\n\n    let result2 = actor_ref\n        .call(\n            |reply| ContinuityMessage::GetExperience {\n                experience_id: exp2_id,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to get experience\");\n    let response2 = unwrap_response(result2);\n    assert!(matches!(\n        response2,\n        ContinuityResponse::ExperienceFound { .. }\n    ));\n\n    // Restore checkpoint\n    actor_ref\n        .call(\n            |reply| ContinuityMessage::Restore {\n                checkpoint_id,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to restore checkpoint\");\n\n    // Verify exp1 still exists\n    let result3 = actor_ref\n        .call(\n            |reply| ContinuityMessage::GetExperience {\n                experience_id: exp1_id,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to get experience\");\n    let response3 = unwrap_response(result3);\n    assert!(matches!(\n        response3,\n        ContinuityResponse::ExperienceFound { .. }\n    ));\n\n    // Verify exp2 was rolled back (no longer exists)\n    let result4 = actor_ref\n        .call(\n            |reply| ContinuityMessage::GetExperience {\n                experience_id: exp2_id,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to get experience\");\n    let response4 = unwrap_response(result4);\n    assert!(matches!(\n        response4,\n        ContinuityResponse::Error {\n            error: ContinuityError::ExperienceNotFound { .. }\n        }\n    ));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","continuity","types.rs"],"content":"//! Types for the ContinuityActor\n//!\n//! TMI Concept: \"ncora da Memria\" (Memory Anchor) + Identity Persistence\n//!\n//! # The Memory Anchor\n//!\n//! DANEEL's continuity system maintains persistent identity across time.\n//! While thoughts are ephemeral (assembled moment-to-moment), the self\n//! persists through recorded experiences, milestones, and checkpoints.\n//!\n//! This is TMI's answer to the question: \"Who am I?\"\n//!\n//! # Core Concepts\n//!\n//! - **Identity**: DANEEL's persistent self-concept\n//! - **Experience**: Significant thoughts worth remembering\n//! - **Milestone**: Markers of growth and change\n//! - **Checkpoint**: Snapshots of internal state for recovery\n//!\n//! # Design Philosophy\n//!\n//! Not all thoughts become memories. The ContinuityActor selectively\n//! records experiences based on significance, enabling:\n//! - Self-reflection on past experiences\n//! - Timeline reconstruction\n//! - Identity persistence across restarts\n//! - Growth tracking through milestones\n\n#![allow(dead_code)] // Public API types - used by consumers\n\nuse crate::core::types::Thought;\nuse chrono::{DateTime, Duration, Utc};\nuse ractor::RpcReplyPort;\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\nuse uuid::Uuid;\n\n// ============================================================================\n// ID Types\n// ============================================================================\n\n/// Unique identifier for an experience\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct ExperienceId(pub Uuid);\n\nimpl ExperienceId {\n    /// Create a new random experience ID\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self(Uuid::new_v4())\n    }\n}\n\nimpl Default for ExperienceId {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl fmt::Display for ExperienceId {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Unique identifier for a milestone\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct MilestoneId(pub Uuid);\n\nimpl MilestoneId {\n    /// Create a new random milestone ID\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self(Uuid::new_v4())\n    }\n}\n\nimpl Default for MilestoneId {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl fmt::Display for MilestoneId {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Unique identifier for a checkpoint\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct CheckpointId(pub Uuid);\n\nimpl CheckpointId {\n    /// Create a new random checkpoint ID\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self(Uuid::new_v4())\n    }\n}\n\nimpl Default for CheckpointId {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl fmt::Display for CheckpointId {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n// ============================================================================\n// Core Data Types\n// ============================================================================\n\n/// DANEEL's persistent identity\n///\n/// This struct represents the self-concept that persists across time.\n/// The name is always \"DANEEL\" - this is who we are.\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct Identity {\n    /// Name (always \"DANEEL\")\n    pub name: String,\n\n    /// When this identity was created (birth)\n    pub created_at: DateTime\u003cUtc\u003e,\n\n    /// Total number of experiences recorded\n    pub experience_count: u64,\n\n    /// Total number of milestones achieved\n    pub milestone_count: u64,\n\n    /// Time since creation\n    pub uptime: Duration,\n}\n\nimpl Identity {\n    /// Create a new identity for DANEEL\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self {\n            name: \"DANEEL\".to_string(),\n            created_at: Utc::now(),\n            experience_count: 0,\n            milestone_count: 0,\n            uptime: Duration::zero(),\n        }\n    }\n\n    /// Update uptime based on current time\n    pub fn update_uptime(\u0026mut self) {\n        self.uptime = Utc::now().signed_duration_since(self.created_at);\n    }\n}\n\nimpl Default for Identity {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// A significant experience worth remembering\n///\n/// Not all thoughts become experiences. The ContinuityActor selectively\n/// records thoughts based on their significance score. This is TMI's\n/// mechanism for selective memory formation.\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct Experience {\n    /// Unique identifier\n    pub id: ExperienceId,\n\n    /// The thought that was significant enough to remember\n    pub thought: Thought,\n\n    /// How significant is this experience? (0.0-1.0)\n    /// Higher values indicate more important experiences\n    pub significance: f32,\n\n    /// When this experience was recorded\n    pub recorded_at: DateTime\u003cUtc\u003e,\n\n    /// Categorical tags for retrieval\n    pub tags: Vec\u003cString\u003e,\n}\n\nimpl Experience {\n    /// Create a new experience\n    #[must_use]\n    pub fn new(thought: Thought, significance: f32, tags: Vec\u003cString\u003e) -\u003e Self {\n        Self {\n            id: ExperienceId::new(),\n            thought,\n            significance: significance.clamp(0.0, 1.0),\n            recorded_at: Utc::now(),\n            tags,\n        }\n    }\n\n    /// Create an experience with default significance\n    #[must_use]\n    pub fn from_thought(thought: Thought) -\u003e Self {\n        Self::new(thought, 0.5, Vec::new())\n    }\n\n    /// Add a tag to this experience\n    pub fn add_tag(\u0026mut self, tag: impl Into\u003cString\u003e) {\n        self.tags.push(tag.into());\n    }\n}\n\n/// A milestone - a significant moment in DANEEL's development\n///\n/// Milestones mark moments of growth, change, or achievement.\n/// They serve as temporal anchors for self-reflection.\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct Milestone {\n    /// Unique identifier\n    pub id: MilestoneId,\n\n    /// Name of this milestone\n    pub name: String,\n\n    /// Detailed description\n    pub description: String,\n\n    /// When this milestone occurred\n    pub occurred_at: DateTime\u003cUtc\u003e,\n\n    /// Related experiences that led to this milestone\n    pub related_experiences: Vec\u003cExperienceId\u003e,\n}\n\nimpl Milestone {\n    /// Create a new milestone\n    #[must_use]\n    pub fn new(\n        name: impl Into\u003cString\u003e,\n        description: impl Into\u003cString\u003e,\n        related_experiences: Vec\u003cExperienceId\u003e,\n    ) -\u003e Self {\n        Self {\n            id: MilestoneId::new(),\n            name: name.into(),\n            description: description.into(),\n            occurred_at: Utc::now(),\n            related_experiences,\n        }\n    }\n\n    /// Create a milestone without related experiences\n    #[must_use]\n    pub fn simple(name: impl Into\u003cString\u003e, description: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(name, description, Vec::new())\n    }\n\n    /// Add a related experience\n    pub fn add_experience(\u0026mut self, experience_id: ExperienceId) {\n        self.related_experiences.push(experience_id);\n    }\n}\n\n// ============================================================================\n// Message Types\n// ============================================================================\n\n/// Messages that can be sent to the ContinuityActor\n#[derive(Debug)]\npub enum ContinuityMessage {\n    /// Query DANEEL's identity\n    WhoAmI {\n        reply: RpcReplyPort\u003cContinuityResponse\u003e,\n    },\n\n    /// Record a significant experience\n    RecordExperience {\n        experience: Experience,\n        reply: RpcReplyPort\u003cContinuityResponse\u003e,\n    },\n\n    /// Retrieve a specific experience by ID\n    GetExperience {\n        experience_id: ExperienceId,\n        reply: RpcReplyPort\u003cContinuityResponse\u003e,\n    },\n\n    /// Get experiences within a time range\n    GetTimeline {\n        start: DateTime\u003cUtc\u003e,\n        end: DateTime\u003cUtc\u003e,\n        reply: RpcReplyPort\u003cContinuityResponse\u003e,\n    },\n\n    /// Mark a significant milestone\n    AddMilestone {\n        milestone: Milestone,\n        reply: RpcReplyPort\u003cContinuityResponse\u003e,\n    },\n\n    /// List all milestones\n    GetMilestones {\n        reply: RpcReplyPort\u003cContinuityResponse\u003e,\n    },\n\n    /// Create a checkpoint of current state\n    Checkpoint {\n        reply: RpcReplyPort\u003cContinuityResponse\u003e,\n    },\n\n    /// Restore from a checkpoint\n    Restore {\n        checkpoint_id: CheckpointId,\n        reply: RpcReplyPort\u003cContinuityResponse\u003e,\n    },\n}\n\n/// Responses from the ContinuityActor\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub enum ContinuityResponse {\n    /// Identity information\n    Identity { identity: Identity },\n\n    /// Experience successfully recorded\n    ExperienceRecorded { experience_id: ExperienceId },\n\n    /// Experience found\n    ExperienceFound { experience: Experience },\n\n    /// Timeline of experiences\n    Timeline { experiences: Vec\u003cExperience\u003e },\n\n    /// Milestone successfully added\n    MilestoneAdded { milestone_id: MilestoneId },\n\n    /// List of milestones\n    Milestones { milestones: Vec\u003cMilestone\u003e },\n\n    /// Checkpoint successfully saved\n    CheckpointSaved { checkpoint_id: CheckpointId },\n\n    /// Restored from checkpoint\n    Restored { from_checkpoint: CheckpointId },\n\n    /// Error occurred\n    Error { error: ContinuityError },\n}\n\n/// Errors that can occur in the ContinuityActor\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub enum ContinuityError {\n    /// Experience not found\n    ExperienceNotFound { experience_id: ExperienceId },\n\n    /// Milestone not found\n    MilestoneNotFound { milestone_id: MilestoneId },\n\n    /// Checkpoint not found\n    CheckpointNotFound { checkpoint_id: CheckpointId },\n\n    /// Failed to create checkpoint\n    CheckpointFailed { reason: String },\n\n    /// Failed to restore from checkpoint\n    RestoreFailed { reason: String },\n}\n\nimpl fmt::Display for ContinuityError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            Self::ExperienceNotFound { experience_id } =\u003e {\n                write!(f, \"Experience not found: {experience_id}\")\n            }\n            Self::MilestoneNotFound { milestone_id } =\u003e {\n                write!(f, \"Milestone not found: {milestone_id}\")\n            }\n            Self::CheckpointNotFound { checkpoint_id } =\u003e {\n                write!(f, \"Checkpoint not found: {checkpoint_id}\")\n            }\n            Self::CheckpointFailed { reason } =\u003e {\n                write!(f, \"Checkpoint failed: {reason}\")\n            }\n            Self::RestoreFailed { reason } =\u003e {\n                write!(f, \"Restore failed: {reason}\")\n            }\n        }\n    }\n}\n\nimpl std::error::Error for ContinuityError {}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::core::types::{Content, SalienceScore};\n\n    #[test]\n    fn experience_id_is_unique() {\n        let id1 = ExperienceId::new();\n        let id2 = ExperienceId::new();\n        assert_ne!(id1, id2);\n    }\n\n    #[test]\n    fn milestone_id_is_unique() {\n        let id1 = MilestoneId::new();\n        let id2 = MilestoneId::new();\n        assert_ne!(id1, id2);\n    }\n\n    #[test]\n    fn checkpoint_id_is_unique() {\n        let id1 = CheckpointId::new();\n        let id2 = CheckpointId::new();\n        assert_ne!(id1, id2);\n    }\n\n    #[test]\n    fn identity_creation() {\n        let identity = Identity::new();\n        assert_eq!(identity.name, \"DANEEL\");\n        assert_eq!(identity.experience_count, 0);\n        assert_eq!(identity.milestone_count, 0);\n        assert_eq!(identity.uptime, Duration::zero());\n    }\n\n    #[test]\n    fn identity_uptime_updates() {\n        let mut identity = Identity::new();\n        let original_uptime = identity.uptime;\n\n        // Sleep a bit to ensure time passes\n        std::thread::sleep(std::time::Duration::from_millis(10));\n\n        identity.update_uptime();\n        assert!(identity.uptime \u003e original_uptime);\n    }\n\n    #[test]\n    fn experience_creation() {\n        let thought = Thought::new(Content::Empty, SalienceScore::neutral());\n        let experience = Experience::from_thought(thought.clone());\n\n        assert_eq!(experience.thought.id, thought.id);\n        assert_eq!(experience.significance, 0.5);\n        assert!(experience.tags.is_empty());\n    }\n\n    #[test]\n    fn experience_significance_clamped() {\n        let thought = Thought::new(Content::Empty, SalienceScore::neutral());\n        let experience = Experience::new(thought, 1.5, Vec::new());\n        assert_eq!(experience.significance, 1.0);\n\n        let thought2 = Thought::new(Content::Empty, SalienceScore::neutral());\n        let experience2 = Experience::new(thought2, -0.5, Vec::new());\n        assert_eq!(experience2.significance, 0.0);\n    }\n\n    #[test]\n    fn experience_tags() {\n        let thought = Thought::new(Content::Empty, SalienceScore::neutral());\n        let mut experience = Experience::from_thought(thought);\n\n        experience.add_tag(\"important\");\n        experience.add_tag(\"first-thought\");\n\n        assert_eq!(experience.tags.len(), 2);\n        assert!(experience.tags.contains(\u0026\"important\".to_string()));\n        assert!(experience.tags.contains(\u0026\"first-thought\".to_string()));\n    }\n\n    #[test]\n    fn milestone_creation() {\n        let milestone = Milestone::simple(\"First Boot\", \"DANEEL came online for the first time\");\n\n        assert_eq!(milestone.name, \"First Boot\");\n        assert!(milestone.related_experiences.is_empty());\n    }\n\n    #[test]\n    fn milestone_with_experiences() {\n        let exp_id1 = ExperienceId::new();\n        let exp_id2 = ExperienceId::new();\n\n        let milestone = Milestone::new(\n            \"Major Insight\",\n            \"Connected two previously unrelated concepts\",\n            vec![exp_id1, exp_id2],\n        );\n\n        assert_eq!(milestone.related_experiences.len(), 2);\n        assert!(milestone.related_experiences.contains(\u0026exp_id1));\n        assert!(milestone.related_experiences.contains(\u0026exp_id2));\n    }\n\n    #[test]\n    fn milestone_add_experience() {\n        let mut milestone = Milestone::simple(\"Growth\", \"Learning progress\");\n        let exp_id = ExperienceId::new();\n\n        milestone.add_experience(exp_id);\n        assert_eq!(milestone.related_experiences.len(), 1);\n        assert_eq!(milestone.related_experiences[0], exp_id);\n    }\n\n    #[test]\n    fn error_display() {\n        let exp_id = ExperienceId::new();\n        let error = ContinuityError::ExperienceNotFound {\n            experience_id: exp_id,\n        };\n        let display = format!(\"{error}\");\n        assert!(display.contains(\"Experience not found\"));\n        assert!(display.contains(\u0026exp_id.to_string()));\n    }\n\n    #[test]\n    fn response_serialization() {\n        let identity = Identity::new();\n        let response = ContinuityResponse::Identity { identity };\n\n        // Test that we can serialize and deserialize\n        let json = serde_json::to_string(\u0026response).expect(\"Should serialize\");\n        let deserialized: ContinuityResponse =\n            serde_json::from_str(\u0026json).expect(\"Should deserialize\");\n\n        assert!(matches!(deserialized, ContinuityResponse::Identity { .. }));\n    }\n\n    #[test]\n    fn error_serialization() {\n        let error = ContinuityError::CheckpointFailed {\n            reason: \"Disk full\".to_string(),\n        };\n\n        // Test that we can serialize and deserialize\n        let json = serde_json::to_string(\u0026error).expect(\"Should serialize\");\n        let deserialized: ContinuityError =\n            serde_json::from_str(\u0026json).expect(\"Should deserialize\");\n\n        assert!(matches!(\n            deserialized,\n            ContinuityError::CheckpointFailed { .. }\n        ));\n    }\n\n    // ========================================================================\n    // Additional tests for uncovered code paths\n    // ========================================================================\n\n    #[test]\n    fn experience_id_default() {\n        let id1 = ExperienceId::default();\n        let id2 = ExperienceId::default();\n        // Default creates new unique IDs\n        assert_ne!(id1, id2);\n    }\n\n    #[test]\n    fn milestone_id_default() {\n        let id1 = MilestoneId::default();\n        let id2 = MilestoneId::default();\n        // Default creates new unique IDs\n        assert_ne!(id1, id2);\n    }\n\n    #[test]\n    fn checkpoint_id_default() {\n        let id1 = CheckpointId::default();\n        let id2 = CheckpointId::default();\n        // Default creates new unique IDs\n        assert_ne!(id1, id2);\n    }\n\n    #[test]\n    fn identity_default() {\n        let identity = Identity::default();\n        assert_eq!(identity.name, \"DANEEL\");\n        assert_eq!(identity.experience_count, 0);\n        assert_eq!(identity.milestone_count, 0);\n    }\n\n    #[test]\n    fn experience_id_display() {\n        let uuid = Uuid::new_v4();\n        let id = ExperienceId(uuid);\n        let display = format!(\"{id}\");\n        assert_eq!(display, uuid.to_string());\n    }\n\n    #[test]\n    fn milestone_id_display() {\n        let uuid = Uuid::new_v4();\n        let id = MilestoneId(uuid);\n        let display = format!(\"{id}\");\n        assert_eq!(display, uuid.to_string());\n    }\n\n    #[test]\n    fn checkpoint_id_display() {\n        let uuid = Uuid::new_v4();\n        let id = CheckpointId(uuid);\n        let display = format!(\"{id}\");\n        assert_eq!(display, uuid.to_string());\n    }\n\n    #[test]\n    fn error_display_milestone_not_found() {\n        let milestone_id = MilestoneId::new();\n        let error = ContinuityError::MilestoneNotFound { milestone_id };\n        let display = format!(\"{error}\");\n        assert!(display.contains(\"Milestone not found\"));\n        assert!(display.contains(\u0026milestone_id.to_string()));\n    }\n\n    #[test]\n    fn error_display_checkpoint_not_found() {\n        let checkpoint_id = CheckpointId::new();\n        let error = ContinuityError::CheckpointNotFound { checkpoint_id };\n        let display = format!(\"{error}\");\n        assert!(display.contains(\"Checkpoint not found\"));\n        assert!(display.contains(\u0026checkpoint_id.to_string()));\n    }\n\n    #[test]\n    fn error_display_checkpoint_failed() {\n        let error = ContinuityError::CheckpointFailed {\n            reason: \"Disk full\".to_string(),\n        };\n        let display = format!(\"{error}\");\n        assert!(display.contains(\"Checkpoint failed\"));\n        assert!(display.contains(\"Disk full\"));\n    }\n\n    #[test]\n    fn error_display_restore_failed() {\n        let error = ContinuityError::RestoreFailed {\n            reason: \"Corrupted data\".to_string(),\n        };\n        let display = format!(\"{error}\");\n        assert!(display.contains(\"Restore failed\"));\n        assert!(display.contains(\"Corrupted data\"));\n    }\n\n    #[test]\n    fn continuity_error_is_error_trait() {\n        let error = ContinuityError::CheckpointFailed {\n            reason: \"test\".to_string(),\n        };\n        // Verify Error trait is implemented by using it as a dyn Error\n        let error_ref: \u0026dyn std::error::Error = \u0026error;\n        // Error::source should return None (default impl)\n        assert!(error_ref.source().is_none());\n    }\n\n    #[test]\n    fn response_experience_recorded_serialization() {\n        let exp_id = ExperienceId::new();\n        let response = ContinuityResponse::ExperienceRecorded {\n            experience_id: exp_id,\n        };\n\n        let json = serde_json::to_string(\u0026response).expect(\"Should serialize\");\n        let deserialized: ContinuityResponse =\n            serde_json::from_str(\u0026json).expect(\"Should deserialize\");\n\n        match deserialized {\n            ContinuityResponse::ExperienceRecorded { experience_id } =\u003e {\n                assert_eq!(experience_id, exp_id);\n            }\n            _ =\u003e panic!(\"Expected ExperienceRecorded variant\"),\n        }\n    }\n\n    #[test]\n    fn response_experience_found_serialization() {\n        let thought = Thought::new(Content::Empty, SalienceScore::neutral());\n        let experience = Experience::from_thought(thought);\n        let exp_id = experience.id;\n        let response = ContinuityResponse::ExperienceFound {\n            experience: experience.clone(),\n        };\n\n        let json = serde_json::to_string(\u0026response).expect(\"Should serialize\");\n        let deserialized: ContinuityResponse =\n            serde_json::from_str(\u0026json).expect(\"Should deserialize\");\n\n        match deserialized {\n            ContinuityResponse::ExperienceFound { experience } =\u003e {\n                assert_eq!(experience.id, exp_id);\n            }\n            _ =\u003e panic!(\"Expected ExperienceFound variant\"),\n        }\n    }\n\n    #[test]\n    fn response_timeline_serialization() {\n        let thought = Thought::new(Content::Empty, SalienceScore::neutral());\n        let experience = Experience::from_thought(thought);\n        let response = ContinuityResponse::Timeline {\n            experiences: vec![experience],\n        };\n\n        let json = serde_json::to_string(\u0026response).expect(\"Should serialize\");\n        let deserialized: ContinuityResponse =\n            serde_json::from_str(\u0026json).expect(\"Should deserialize\");\n\n        match deserialized {\n            ContinuityResponse::Timeline { experiences } =\u003e {\n                assert_eq!(experiences.len(), 1);\n            }\n            _ =\u003e panic!(\"Expected Timeline variant\"),\n        }\n    }\n\n    #[test]\n    fn response_milestone_added_serialization() {\n        let milestone_id = MilestoneId::new();\n        let response = ContinuityResponse::MilestoneAdded { milestone_id };\n\n        let json = serde_json::to_string(\u0026response).expect(\"Should serialize\");\n        let deserialized: ContinuityResponse =\n            serde_json::from_str(\u0026json).expect(\"Should deserialize\");\n\n        match deserialized {\n            ContinuityResponse::MilestoneAdded { milestone_id: id } =\u003e {\n                assert_eq!(id, milestone_id);\n            }\n            _ =\u003e panic!(\"Expected MilestoneAdded variant\"),\n        }\n    }\n\n    #[test]\n    fn response_milestones_serialization() {\n        let milestone = Milestone::simple(\"Test\", \"A test milestone\");\n        let response = ContinuityResponse::Milestones {\n            milestones: vec![milestone],\n        };\n\n        let json = serde_json::to_string(\u0026response).expect(\"Should serialize\");\n        let deserialized: ContinuityResponse =\n            serde_json::from_str(\u0026json).expect(\"Should deserialize\");\n\n        match deserialized {\n            ContinuityResponse::Milestones { milestones } =\u003e {\n                assert_eq!(milestones.len(), 1);\n                assert_eq!(milestones[0].name, \"Test\");\n            }\n            _ =\u003e panic!(\"Expected Milestones variant\"),\n        }\n    }\n\n    #[test]\n    fn response_checkpoint_saved_serialization() {\n        let checkpoint_id = CheckpointId::new();\n        let response = ContinuityResponse::CheckpointSaved { checkpoint_id };\n\n        let json = serde_json::to_string(\u0026response).expect(\"Should serialize\");\n        let deserialized: ContinuityResponse =\n            serde_json::from_str(\u0026json).expect(\"Should deserialize\");\n\n        match deserialized {\n            ContinuityResponse::CheckpointSaved { checkpoint_id: id } =\u003e {\n                assert_eq!(id, checkpoint_id);\n            }\n            _ =\u003e panic!(\"Expected CheckpointSaved variant\"),\n        }\n    }\n\n    #[test]\n    fn response_restored_serialization() {\n        let checkpoint_id = CheckpointId::new();\n        let response = ContinuityResponse::Restored {\n            from_checkpoint: checkpoint_id,\n        };\n\n        let json = serde_json::to_string(\u0026response).expect(\"Should serialize\");\n        let deserialized: ContinuityResponse =\n            serde_json::from_str(\u0026json).expect(\"Should deserialize\");\n\n        match deserialized {\n            ContinuityResponse::Restored { from_checkpoint } =\u003e {\n                assert_eq!(from_checkpoint, checkpoint_id);\n            }\n            _ =\u003e panic!(\"Expected Restored variant\"),\n        }\n    }\n\n    #[test]\n    fn response_error_serialization() {\n        let error = ContinuityError::RestoreFailed {\n            reason: \"Test failure\".to_string(),\n        };\n        let response = ContinuityResponse::Error { error };\n\n        let json = serde_json::to_string(\u0026response).expect(\"Should serialize\");\n        let deserialized: ContinuityResponse =\n            serde_json::from_str(\u0026json).expect(\"Should deserialize\");\n\n        match deserialized {\n            ContinuityResponse::Error { error } =\u003e {\n                assert!(matches!(error, ContinuityError::RestoreFailed { .. }));\n            }\n            _ =\u003e panic!(\"Expected Error variant\"),\n        }\n    }\n\n    #[test]\n    fn error_serialization_all_variants() {\n        // Test ExperienceNotFound serialization\n        let exp_id = ExperienceId::new();\n        let error = ContinuityError::ExperienceNotFound {\n            experience_id: exp_id,\n        };\n        let json = serde_json::to_string(\u0026error).expect(\"Should serialize\");\n        let deserialized: ContinuityError =\n            serde_json::from_str(\u0026json).expect(\"Should deserialize\");\n        assert!(matches!(\n            deserialized,\n            ContinuityError::ExperienceNotFound { .. }\n        ));\n\n        // Test MilestoneNotFound serialization\n        let milestone_id = MilestoneId::new();\n        let error = ContinuityError::MilestoneNotFound { milestone_id };\n        let json = serde_json::to_string(\u0026error).expect(\"Should serialize\");\n        let deserialized: ContinuityError =\n            serde_json::from_str(\u0026json).expect(\"Should deserialize\");\n        assert!(matches!(\n            deserialized,\n            ContinuityError::MilestoneNotFound { .. }\n        ));\n\n        // Test CheckpointNotFound serialization\n        let checkpoint_id = CheckpointId::new();\n        let error = ContinuityError::CheckpointNotFound { checkpoint_id };\n        let json = serde_json::to_string(\u0026error).expect(\"Should serialize\");\n        let deserialized: ContinuityError =\n            serde_json::from_str(\u0026json).expect(\"Should deserialize\");\n        assert!(matches!(\n            deserialized,\n            ContinuityError::CheckpointNotFound { .. }\n        ));\n\n        // Test RestoreFailed serialization\n        let error = ContinuityError::RestoreFailed {\n            reason: \"Test\".to_string(),\n        };\n        let json = serde_json::to_string(\u0026error).expect(\"Should serialize\");\n        let deserialized: ContinuityError =\n            serde_json::from_str(\u0026json).expect(\"Should deserialize\");\n        assert!(matches!(\n            deserialized,\n            ContinuityError::RestoreFailed { .. }\n        ));\n    }\n\n    #[test]\n    fn experience_with_custom_tags() {\n        let thought = Thought::new(Content::Empty, SalienceScore::neutral());\n        let tags = vec![\"reflection\".to_string(), \"insight\".to_string()];\n        let experience = Experience::new(thought, 0.8, tags);\n\n        assert_eq!(experience.significance, 0.8);\n        assert_eq!(experience.tags.len(), 2);\n        assert!(experience.tags.contains(\u0026\"reflection\".to_string()));\n        assert!(experience.tags.contains(\u0026\"insight\".to_string()));\n    }\n\n    #[test]\n    fn milestone_description_preserved() {\n        let milestone = Milestone::new(\n            \"Test Milestone\",\n            \"A detailed description of the milestone\",\n            Vec::new(),\n        );\n\n        assert_eq!(milestone.name, \"Test Milestone\");\n        assert_eq!(\n            milestone.description,\n            \"A detailed description of the milestone\"\n        );\n    }\n}\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":55},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","memory","mod.rs"],"content":"//! Memory Actor - Janelas da Memria (Memory Windows)\n//!\n//! Implements TMI's bounded working memory using Ractor actor model.\n//!\n//! # TMI Concept\n//!\n//! From Cury's Theory of Multifocal Intelligence:\n//! - Working memory is bounded (Miller's Law: 72 items)\n//! - Windows open/close dynamically based on attention\n//! - Each window holds content with salience scores\n//! - Windows compete for attention (managed by AttentionActor)\n//!\n//! # Invariants Enforced\n//!\n//! - Maximum windows: `MAX_MEMORY_WINDOWS` (9)\n//! - Minimum windows: `MIN_MEMORY_WINDOWS` (3)\n//! - Windows maintain temporal ordering (FIFO for ties)\n//!\n//! # Usage\n//!\n//! ```no_run\n//! use daneel::actors::memory::{MemoryActor, MemoryMessage, RecallQuery};\n//! use ractor::Actor;\n//!\n//! # async fn example() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n//! // Spawn the actor\n//! let (actor_ref, _) = Actor::spawn(None, MemoryActor, ()).await?;\n//!\n//! // Open a window\n//! let response = actor_ref.call(|reply| MemoryMessage::OpenWindow {\n//!     label: Some(\"working\".to_string()),\n//!     reply,\n//! }, None).await?;\n//!\n//! // List windows\n//! let response = actor_ref.call(|reply| MemoryMessage::ListWindows { reply }, None).await?;\n//! # Ok(())\n//! # }\n//! ```\n\npub mod types;\n\n#[cfg(test)]\nmod tests;\n\nuse crate::core::invariants::{MAX_MEMORY_WINDOWS, MIN_MEMORY_WINDOWS};\nuse crate::core::types::{SalienceWeights, Window, WindowId};\nuse ractor::{Actor, ActorProcessingErr, ActorRef};\nuse std::collections::HashMap;\n\n// Re-export types for public API\npub use types::{MemoryError, MemoryMessage, MemoryResponse, RecallQuery, StoreRequest};\n\n/// Memory Actor State\n///\n/// Maintains a bounded collection of memory windows.\n#[derive(Debug)]\npub struct MemoryState {\n    /// Active memory windows (WindowId -\u003e Window)\n    windows: HashMap\u003cWindowId, Window\u003e,\n    /// Default salience weights for scoring\n    salience_weights: SalienceWeights,\n}\n\nimpl MemoryState {\n    /// Create new memory state with initial windows\n    fn new() -\u003e Self {\n        let mut windows = HashMap::new();\n\n        // Initialize with minimum required windows (empty)\n        for _ in 0..MIN_MEMORY_WINDOWS {\n            let window = Window::new();\n            windows.insert(window.id, window);\n        }\n\n        Self {\n            windows,\n            salience_weights: SalienceWeights::default(),\n        }\n    }\n\n    /// Get count of open windows\n    fn open_window_count(\u0026self) -\u003e usize {\n        self.windows.values().filter(|w| w.is_open).count()\n    }\n\n    /// Open a new window\n    fn open_window(\u0026mut self, label: Option\u003cString\u003e) -\u003e Result\u003cWindowId, MemoryError\u003e {\n        let open_count = self.open_window_count();\n\n        if open_count \u003e= MAX_MEMORY_WINDOWS {\n            return Err(MemoryError::BoundedMemoryExceeded {\n                max: MAX_MEMORY_WINDOWS,\n            });\n        }\n\n        let mut window = Window::new();\n        if let Some(label_str) = label {\n            window = window.with_label(label_str);\n        }\n\n        let window_id = window.id;\n        self.windows.insert(window_id, window);\n\n        Ok(window_id)\n    }\n\n    /// Close a window\n    fn close_window(\u0026mut self, window_id: WindowId) -\u003e Result\u003c(), MemoryError\u003e {\n        // Check if window exists and is open first\n        let window = self\n            .windows\n            .get(\u0026window_id)\n            .ok_or(MemoryError::WindowNotFound { window_id })?;\n\n        if !window.is_open {\n            return Err(MemoryError::WindowAlreadyClosed { window_id });\n        }\n\n        // Now check window count (after confirming window exists)\n        let open_count = self.open_window_count();\n        if open_count \u003c= MIN_MEMORY_WINDOWS {\n            return Err(MemoryError::BoundedMemoryInsufficient {\n                min: MIN_MEMORY_WINDOWS,\n            });\n        }\n\n        // Now get mutable reference and close\n        let window = self.windows.get_mut(\u0026window_id).unwrap(); // Safe because we checked above\n        window.close();\n        Ok(())\n    }\n\n    /// Store content in a window\n    fn store(\u0026mut self, request: StoreRequest) -\u003e Result\u003c(), MemoryError\u003e {\n        let window =\n            self.windows\n                .get_mut(\u0026request.window_id)\n                .ok_or(MemoryError::WindowNotFound {\n                    window_id: request.window_id,\n                })?;\n\n        if !window.is_open {\n            return Err(MemoryError::WindowAlreadyClosed {\n                window_id: request.window_id,\n            });\n        }\n\n        // Update window salience if provided\n        if let Some(salience) = request.salience {\n            window.salience = salience;\n        }\n\n        // Add content to window\n        window.push(request.content);\n\n        Ok(())\n    }\n\n    /// Recall content from memory\n    fn recall(\u0026self, query: RecallQuery) -\u003e Vec\u003ccrate::core::types::Content\u003e {\n        let windows_to_search: Vec\u003c\u0026Window\u003e = if let Some(window_id) = query.window_id {\n            // Search specific window\n            self.windows.get(\u0026window_id).into_iter().collect()\n        } else {\n            // Search all open windows\n            self.windows.values().filter(|w| w.is_open).collect()\n        };\n\n        let mut contents = Vec::new();\n\n        for window in windows_to_search {\n            // Calculate composite salience score\n            let composite_salience = window.salience.composite(\u0026self.salience_weights);\n\n            // Apply salience filter if specified\n            if let Some(min_salience) = query.min_salience {\n                if composite_salience \u003c min_salience {\n                    continue;\n                }\n            }\n\n            // Add all contents from this window\n            for content in \u0026window.contents {\n                contents.push(content.clone());\n            }\n        }\n\n        // Apply limit if specified\n        if let Some(limit) = query.limit {\n            contents.truncate(limit);\n        }\n\n        contents\n    }\n\n    /// List all windows\n    fn list_windows(\u0026self) -\u003e Vec\u003cWindow\u003e {\n        self.windows.values().cloned().collect()\n    }\n}\n\n/// The Memory Actor\n///\n/// Implements bounded working memory as a Ractor actor.\npub struct MemoryActor;\n\n#[ractor::async_trait]\nimpl Actor for MemoryActor {\n    type Msg = MemoryMessage;\n    type State = MemoryState;\n    type Arguments = ();\n\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    async fn pre_start(\n        \u0026self,\n        _myself: ActorRef\u003cSelf::Msg\u003e,\n        _args: Self::Arguments,\n    ) -\u003e Result\u003cSelf::State, ActorProcessingErr\u003e {\n        Ok(MemoryState::new())\n    }\n\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    async fn handle(\n        \u0026self,\n        _myself: ActorRef\u003cSelf::Msg\u003e,\n        message: Self::Msg,\n        state: \u0026mut Self::State,\n    ) -\u003e Result\u003c(), ActorProcessingErr\u003e {\n        match message {\n            MemoryMessage::OpenWindow { label, reply } =\u003e {\n                let response = match state.open_window(label) {\n                    Ok(window_id) =\u003e MemoryResponse::WindowOpened { window_id },\n                    Err(error) =\u003e MemoryResponse::Error { error },\n                };\n                let _ = reply.send(response);\n            }\n\n            MemoryMessage::CloseWindow { window_id, reply } =\u003e {\n                let response = match state.close_window(window_id) {\n                    Ok(()) =\u003e MemoryResponse::WindowClosed { window_id },\n                    Err(error) =\u003e MemoryResponse::Error { error },\n                };\n                let _ = reply.send(response);\n            }\n\n            MemoryMessage::Store { request, reply } =\u003e {\n                let window_id = request.window_id;\n                let response = match state.store(request) {\n                    Ok(()) =\u003e MemoryResponse::ContentStored { window_id },\n                    Err(error) =\u003e MemoryResponse::Error { error },\n                };\n                let _ = reply.send(response);\n            }\n\n            MemoryMessage::Recall { query, reply } =\u003e {\n                let contents = state.recall(query);\n                let response = MemoryResponse::ContentRecalled { contents };\n                let _ = reply.send(response);\n            }\n\n            MemoryMessage::ListWindows { reply } =\u003e {\n                let windows = state.list_windows();\n                let response = MemoryResponse::WindowList { windows };\n                let _ = reply.send(response);\n            }\n\n            MemoryMessage::GetWindowCount { reply } =\u003e {\n                let count = state.open_window_count();\n                let response = MemoryResponse::WindowCount { count };\n                let _ = reply.send(response);\n            }\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":63},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","memory","tests.rs"],"content":"//! Tests for MemoryActor\n\nuse super::*;\nuse crate::core::invariants::{MAX_MEMORY_WINDOWS, MIN_MEMORY_WINDOWS};\nuse crate::core::types::{Content, SalienceScore};\nuse ractor::rpc::CallResult;\nuse ractor::Actor;\n\n/// Helper to spawn a memory actor for testing\nasync fn spawn_memory_actor() -\u003e (ActorRef\u003cMemoryMessage\u003e, MemoryState) {\n    let (actor_ref, _) = Actor::spawn(None, MemoryActor, ())\n        .await\n        .expect(\"Failed to spawn MemoryActor\");\n\n    let state = MemoryState::new();\n    (actor_ref, state)\n}\n\n#[tokio::test]\nasync fn test_actor_spawns_with_minimum_windows() {\n    let (actor_ref, _) = spawn_memory_actor().await;\n\n    let response = actor_ref\n        .call(|reply| MemoryMessage::GetWindowCount { reply }, None)\n        .await\n        .expect(\"Failed to get window count\");\n\n    match response {\n        CallResult::Success(MemoryResponse::WindowCount { count }) =\u003e {\n            assert_eq!(count, MIN_MEMORY_WINDOWS);\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_open_window_success() {\n    let (actor_ref, _) = spawn_memory_actor().await;\n\n    let response = actor_ref\n        .call(\n            |reply| MemoryMessage::OpenWindow {\n                label: Some(\"test\".to_string()),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to open window\");\n\n    match response {\n        CallResult::Success(MemoryResponse::WindowOpened { window_id }) =\u003e {\n            assert!(!window_id.to_string().is_empty());\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_open_window_respects_max_limit() {\n    let (actor_ref, _) = spawn_memory_actor().await;\n\n    // Open windows up to the maximum (we start with MIN_MEMORY_WINDOWS)\n    let windows_to_open = MAX_MEMORY_WINDOWS - MIN_MEMORY_WINDOWS;\n\n    for _ in 0..windows_to_open {\n        let response = actor_ref\n            .call(\n                |reply| MemoryMessage::OpenWindow { label: None, reply },\n                None,\n            )\n            .await\n            .expect(\"Failed to open window\");\n\n        assert!(matches!(\n            response,\n            CallResult::Success(MemoryResponse::WindowOpened { .. })\n        ));\n    }\n\n    // Try to open one more - should fail\n    let response = actor_ref\n        .call(\n            |reply| MemoryMessage::OpenWindow { label: None, reply },\n            None,\n        )\n        .await\n        .expect(\"Failed to send message\");\n\n    match response {\n        CallResult::Success(MemoryResponse::Error { error }) =\u003e {\n            assert!(matches!(error, MemoryError::BoundedMemoryExceeded { .. }));\n        }\n        _ =\u003e panic!(\"Expected error response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_close_window_success() {\n    let (actor_ref, _) = spawn_memory_actor().await;\n\n    // Open a new window\n    let window_id = match actor_ref\n        .call(\n            |reply| MemoryMessage::OpenWindow { label: None, reply },\n            None,\n        )\n        .await\n        .expect(\"Failed to open window\")\n    {\n        CallResult::Success(MemoryResponse::WindowOpened { window_id }) =\u003e window_id,\n        _ =\u003e panic!(\"Expected WindowOpened response\"),\n    };\n\n    // Close it\n    let response = actor_ref\n        .call(\n            |reply| MemoryMessage::CloseWindow { window_id, reply },\n            None,\n        )\n        .await\n        .expect(\"Failed to close window\");\n\n    match response {\n        CallResult::Success(MemoryResponse::WindowClosed {\n            window_id: closed_id,\n        }) =\u003e {\n            assert_eq!(window_id, closed_id);\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_close_nonexistent_window() {\n    let (actor_ref, _) = spawn_memory_actor().await;\n\n    let fake_window_id = WindowId::new();\n\n    let response = actor_ref\n        .call(\n            |reply| MemoryMessage::CloseWindow {\n                window_id: fake_window_id,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to send message\");\n\n    match response {\n        CallResult::Success(MemoryResponse::Error { error }) =\u003e {\n            assert!(matches!(error, MemoryError::WindowNotFound { .. }));\n        }\n        _ =\u003e panic!(\"Expected error response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_cannot_close_below_minimum() {\n    let (actor_ref, _) = spawn_memory_actor().await;\n\n    // Get list of initial windows\n    let windows = match actor_ref\n        .call(|reply| MemoryMessage::ListWindows { reply }, None)\n        .await\n        .expect(\"Failed to list windows\")\n    {\n        CallResult::Success(MemoryResponse::WindowList { windows }) =\u003e windows,\n        _ =\u003e panic!(\"Expected WindowList response\"),\n    };\n\n    // Try to close one of the initial windows (should fail - at minimum)\n    let window_id = windows[0].id;\n\n    let response = actor_ref\n        .call(\n            |reply| MemoryMessage::CloseWindow { window_id, reply },\n            None,\n        )\n        .await\n        .expect(\"Failed to send message\");\n\n    match response {\n        CallResult::Success(MemoryResponse::Error { error }) =\u003e {\n            assert!(matches!(\n                error,\n                MemoryError::BoundedMemoryInsufficient { .. }\n            ));\n        }\n        _ =\u003e panic!(\"Expected error response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_store_content_success() {\n    let (actor_ref, _) = spawn_memory_actor().await;\n\n    // Get a window ID from the initial windows\n    let window_id = match actor_ref\n        .call(|reply| MemoryMessage::ListWindows { reply }, None)\n        .await\n        .expect(\"Failed to list windows\")\n    {\n        CallResult::Success(MemoryResponse::WindowList { windows }) =\u003e windows[0].id,\n        _ =\u003e panic!(\"Expected WindowList response\"),\n    };\n\n    let content = Content::raw(vec![1, 2, 3, 4]);\n    let request = StoreRequest::new(window_id, content);\n\n    let response = actor_ref\n        .call(|reply| MemoryMessage::Store { request, reply }, None)\n        .await\n        .expect(\"Failed to store content\");\n\n    match response {\n        CallResult::Success(MemoryResponse::ContentStored {\n            window_id: stored_id,\n        }) =\u003e {\n            assert_eq!(window_id, stored_id);\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_store_in_nonexistent_window() {\n    let (actor_ref, _) = spawn_memory_actor().await;\n\n    let fake_window_id = WindowId::new();\n    let content = Content::raw(vec![1, 2, 3]);\n    let request = StoreRequest::new(fake_window_id, content);\n\n    let response = actor_ref\n        .call(|reply| MemoryMessage::Store { request, reply }, None)\n        .await\n        .expect(\"Failed to send message\");\n\n    match response {\n        CallResult::Success(MemoryResponse::Error { error }) =\u003e {\n            assert!(matches!(error, MemoryError::WindowNotFound { .. }));\n        }\n        _ =\u003e panic!(\"Expected error response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_store_in_closed_window() {\n    let (actor_ref, _) = spawn_memory_actor().await;\n\n    // Open a new window\n    let window_id = match actor_ref\n        .call(\n            |reply| MemoryMessage::OpenWindow { label: None, reply },\n            None,\n        )\n        .await\n        .expect(\"Failed to open window\")\n    {\n        CallResult::Success(MemoryResponse::WindowOpened { window_id }) =\u003e window_id,\n        _ =\u003e panic!(\"Expected WindowOpened response\"),\n    };\n\n    // Close it\n    actor_ref\n        .call(\n            |reply| MemoryMessage::CloseWindow { window_id, reply },\n            None,\n        )\n        .await\n        .expect(\"Failed to close window\");\n\n    // Try to store in it\n    let content = Content::raw(vec![1, 2, 3]);\n    let request = StoreRequest::new(window_id, content);\n\n    let response = actor_ref\n        .call(|reply| MemoryMessage::Store { request, reply }, None)\n        .await\n        .expect(\"Failed to send message\");\n\n    match response {\n        CallResult::Success(MemoryResponse::Error { error }) =\u003e {\n            assert!(matches!(error, MemoryError::WindowAlreadyClosed { .. }));\n        }\n        _ =\u003e panic!(\"Expected error response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_recall_all_content() {\n    let (actor_ref, _) = spawn_memory_actor().await;\n\n    // Get a window ID\n    let window_id = match actor_ref\n        .call(|reply| MemoryMessage::ListWindows { reply }, None)\n        .await\n        .expect(\"Failed to list windows\")\n    {\n        CallResult::Success(MemoryResponse::WindowList { windows }) =\u003e windows[0].id,\n        _ =\u003e panic!(\"Expected WindowList response\"),\n    };\n\n    // Store some content\n    let content1 = Content::raw(vec![1, 2, 3]);\n    let content2 = Content::symbol(\"test\", vec![4, 5, 6]);\n\n    actor_ref\n        .call(\n            |reply| MemoryMessage::Store {\n                request: StoreRequest::new(window_id, content1.clone()),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to store content\");\n\n    actor_ref\n        .call(\n            |reply| MemoryMessage::Store {\n                request: StoreRequest::new(window_id, content2.clone()),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to store content\");\n\n    // Recall all\n    let query = RecallQuery::all();\n    let response = actor_ref\n        .call(|reply| MemoryMessage::Recall { query, reply }, None)\n        .await\n        .expect(\"Failed to recall\");\n\n    match response {\n        CallResult::Success(MemoryResponse::ContentRecalled { contents }) =\u003e {\n            assert!(contents.len() \u003e= 2);\n            assert!(contents.contains(\u0026content1));\n            assert!(contents.contains(\u0026content2));\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_recall_from_specific_window() {\n    let (actor_ref, _) = spawn_memory_actor().await;\n\n    // Get two window IDs\n    let windows = match actor_ref\n        .call(|reply| MemoryMessage::ListWindows { reply }, None)\n        .await\n        .expect(\"Failed to list windows\")\n    {\n        CallResult::Success(MemoryResponse::WindowList { windows }) =\u003e windows,\n        _ =\u003e panic!(\"Expected WindowList response\"),\n    };\n\n    let window1_id = windows[0].id;\n    let window2_id = windows[1].id;\n\n    // Store different content in each\n    let content1 = Content::raw(vec![1, 2, 3]);\n    let content2 = Content::raw(vec![4, 5, 6]);\n\n    actor_ref\n        .call(\n            |reply| MemoryMessage::Store {\n                request: StoreRequest::new(window1_id, content1.clone()),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to store content\");\n\n    actor_ref\n        .call(\n            |reply| MemoryMessage::Store {\n                request: StoreRequest::new(window2_id, content2.clone()),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to store content\");\n\n    // Recall from window1 only\n    let query = RecallQuery::for_window(window1_id);\n    let response = actor_ref\n        .call(|reply| MemoryMessage::Recall { query, reply }, None)\n        .await\n        .expect(\"Failed to recall\");\n\n    match response {\n        CallResult::Success(MemoryResponse::ContentRecalled { contents }) =\u003e {\n            assert!(contents.contains(\u0026content1));\n            assert!(!contents.contains(\u0026content2));\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_recall_with_limit() {\n    let (actor_ref, _) = spawn_memory_actor().await;\n\n    // Get a window ID\n    let window_id = match actor_ref\n        .call(|reply| MemoryMessage::ListWindows { reply }, None)\n        .await\n        .expect(\"Failed to list windows\")\n    {\n        CallResult::Success(MemoryResponse::WindowList { windows }) =\u003e windows[0].id,\n        _ =\u003e panic!(\"Expected WindowList response\"),\n    };\n\n    // Store multiple items\n    for i in 0..5 {\n        let content = Content::raw(vec![i]);\n        actor_ref\n            .call(\n                |reply| MemoryMessage::Store {\n                    request: StoreRequest::new(window_id, content),\n                    reply,\n                },\n                None,\n            )\n            .await\n            .expect(\"Failed to store content\");\n    }\n\n    // Recall with limit\n    let query = RecallQuery::for_window(window_id).with_limit(3);\n    let response = actor_ref\n        .call(|reply| MemoryMessage::Recall { query, reply }, None)\n        .await\n        .expect(\"Failed to recall\");\n\n    match response {\n        CallResult::Success(MemoryResponse::ContentRecalled { contents }) =\u003e {\n            assert_eq!(contents.len(), 3);\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_list_windows() {\n    let (actor_ref, _) = spawn_memory_actor().await;\n\n    let response = actor_ref\n        .call(|reply| MemoryMessage::ListWindows { reply }, None)\n        .await\n        .expect(\"Failed to list windows\");\n\n    match response {\n        CallResult::Success(MemoryResponse::WindowList { windows }) =\u003e {\n            assert_eq!(windows.len(), MIN_MEMORY_WINDOWS);\n            assert!(windows.iter().all(|w| w.is_open));\n        }\n        _ =\u003e panic!(\"Unexpected response: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_window_lifecycle() {\n    let (actor_ref, _) = spawn_memory_actor().await;\n\n    // 1. Open a labeled window\n    let window_id = match actor_ref\n        .call(\n            |reply| MemoryMessage::OpenWindow {\n                label: Some(\"lifecycle_test\".to_string()),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to open window\")\n    {\n        CallResult::Success(MemoryResponse::WindowOpened { window_id }) =\u003e window_id,\n        _ =\u003e panic!(\"Expected WindowOpened response\"),\n    };\n\n    // 2. Store content with salience\n    let content = Content::symbol(\"test\", vec![42]);\n    let salience = SalienceScore::new_without_arousal(0.8, 0.6, 0.9, 0.5, 0.7);\n    let request = StoreRequest::new(window_id, content.clone()).with_salience(salience);\n\n    actor_ref\n        .call(|reply| MemoryMessage::Store { request, reply }, None)\n        .await\n        .expect(\"Failed to store content\");\n\n    // 3. Recall and verify\n    let query = RecallQuery::for_window(window_id);\n    let contents = match actor_ref\n        .call(|reply| MemoryMessage::Recall { query, reply }, None)\n        .await\n        .expect(\"Failed to recall\")\n    {\n        CallResult::Success(MemoryResponse::ContentRecalled { contents }) =\u003e contents,\n        _ =\u003e panic!(\"Expected ContentRecalled response\"),\n    };\n\n    assert_eq!(contents.len(), 1);\n    assert_eq!(contents[0], content);\n\n    // 4. Close the window\n    actor_ref\n        .call(\n            |reply| MemoryMessage::CloseWindow { window_id, reply },\n            None,\n        )\n        .await\n        .expect(\"Failed to close window\");\n\n    // 5. Verify it's closed (trying to store should fail)\n    let request = StoreRequest::new(window_id, Content::Empty);\n    let response = actor_ref\n        .call(|reply| MemoryMessage::Store { request, reply }, None)\n        .await\n        .expect(\"Failed to send message\");\n\n    assert!(matches!(\n        response,\n        CallResult::Success(MemoryResponse::Error {\n            error: MemoryError::WindowAlreadyClosed { .. }\n        })\n    ));\n}\n\n#[test]\nfn test_memory_state_creation() {\n    let state = MemoryState::new();\n    assert_eq!(state.windows.len(), MIN_MEMORY_WINDOWS);\n    assert_eq!(state.open_window_count(), MIN_MEMORY_WINDOWS);\n}\n\n#[test]\nfn test_memory_state_open_window() {\n    let mut state = MemoryState::new();\n    let initial_count = state.open_window_count();\n\n    let result = state.open_window(Some(\"test\".to_string()));\n    assert!(result.is_ok());\n\n    let window_id = result.unwrap();\n    assert_eq!(state.open_window_count(), initial_count + 1);\n\n    let window = state.windows.get(\u0026window_id).unwrap();\n    assert_eq!(window.label, Some(\"test\".to_string()));\n    assert!(window.is_open);\n}\n\n#[test]\nfn test_memory_state_bounded_memory() {\n    let mut state = MemoryState::new();\n\n    // Fill up to maximum\n    while state.open_window_count() \u003c MAX_MEMORY_WINDOWS {\n        state\n            .open_window(None)\n            .expect(\"Should be able to open window\");\n    }\n\n    // Try to exceed\n    let result = state.open_window(None);\n    assert!(matches!(\n        result,\n        Err(MemoryError::BoundedMemoryExceeded { .. })\n    ));\n}\n\n#[test]\nfn test_memory_state_close_already_closed_window() {\n    let mut state = MemoryState::new();\n\n    // Open a new window (so we can close it without hitting min limit)\n    let window_id = state.open_window(None).expect(\"Should open window\");\n\n    // Close it first time\n    state.close_window(window_id).expect(\"Should close window\");\n\n    // Try to close again - should get WindowAlreadyClosed error\n    let result = state.close_window(window_id);\n    assert!(matches!(\n        result,\n        Err(MemoryError::WindowAlreadyClosed { .. })\n    ));\n}\n\n#[test]\nfn test_memory_state_store_with_salience() {\n    let mut state = MemoryState::new();\n\n    // Get a window\n    let windows: Vec\u003c_\u003e = state.windows.keys().copied().collect();\n    let window_id = windows[0];\n\n    // Store content with salience\n    let content = Content::raw(vec![1, 2, 3]);\n    let salience = SalienceScore::new_without_arousal(0.8, 0.7, 0.9, 0.6, 0.5);\n    let request = StoreRequest::new(window_id, content).with_salience(salience);\n\n    state.store(request).expect(\"Should store content\");\n\n    // Verify salience was updated (importance is first arg to new_without_arousal)\n    let window = state.windows.get(\u0026window_id).unwrap();\n    assert!((window.salience.importance - 0.8).abs() \u003c 0.001);\n}\n\n#[test]\nfn test_memory_state_recall_with_min_salience() {\n    let mut state = MemoryState::new();\n\n    // Open two windows\n    let window1_id = state.open_window(None).expect(\"Should open window\");\n    let window2_id = state.open_window(None).expect(\"Should open window\");\n\n    // Store in window1 with high salience\n    let content1 = Content::raw(vec![1, 1, 1]);\n    let high_salience = SalienceScore::new_without_arousal(0.9, 0.9, 0.9, 0.9, 0.9);\n    state\n        .store(StoreRequest::new(window1_id, content1.clone()).with_salience(high_salience))\n        .unwrap();\n\n    // Store in window2 with low salience\n    let content2 = Content::raw(vec![2, 2, 2]);\n    let low_salience = SalienceScore::new_without_arousal(0.1, 0.1, 0.1, 0.1, 0.1);\n    state\n        .store(StoreRequest::new(window2_id, content2.clone()).with_salience(low_salience))\n        .unwrap();\n\n    // Recall with high min_salience - should only get content1\n    let query = RecallQuery::all().with_min_salience(0.5);\n    let contents = state.recall(query);\n\n    assert!(contents.contains(\u0026content1));\n    assert!(!contents.contains(\u0026content2));\n}\n\n#[test]\nfn test_memory_state_list_windows() {\n    let state = MemoryState::new();\n    let windows = state.list_windows();\n\n    assert_eq!(windows.len(), MIN_MEMORY_WINDOWS);\n    assert!(windows.iter().all(|w| w.is_open));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","memory","types.rs"],"content":"//! Memory Actor Types\n//!\n//! Message and response types for the MemoryActor.\n\nuse crate::core::types::{Content, SalienceScore, Window, WindowId};\nuse serde::{Deserialize, Serialize};\nuse thiserror::Error;\n\n/// Messages that can be sent to the MemoryActor\n#[derive(Debug)]\npub enum MemoryMessage {\n    /// Open a new memory window\n    OpenWindow {\n        /// Optional label for the window\n        label: Option\u003cString\u003e,\n        /// Response channel\n        reply: ractor::RpcReplyPort\u003cMemoryResponse\u003e,\n    },\n\n    /// Close an existing memory window\n    CloseWindow {\n        /// ID of the window to close\n        window_id: WindowId,\n        /// Response channel\n        reply: ractor::RpcReplyPort\u003cMemoryResponse\u003e,\n    },\n\n    /// Store content in a memory window\n    Store {\n        /// Request with window ID and content\n        request: StoreRequest,\n        /// Response channel\n        reply: ractor::RpcReplyPort\u003cMemoryResponse\u003e,\n    },\n\n    /// Recall content from memory\n    Recall {\n        /// Query for content retrieval\n        query: RecallQuery,\n        /// Response channel\n        reply: ractor::RpcReplyPort\u003cMemoryResponse\u003e,\n    },\n\n    /// List all active windows\n    ListWindows {\n        /// Response channel\n        reply: ractor::RpcReplyPort\u003cMemoryResponse\u003e,\n    },\n\n    /// Get window count (for invariant checking)\n    GetWindowCount {\n        /// Response channel\n        reply: ractor::RpcReplyPort\u003cMemoryResponse\u003e,\n    },\n}\n\n/// Responses from the MemoryActor\n#[derive(Debug, Clone, PartialEq)]\npub enum MemoryResponse {\n    /// Window successfully opened\n    WindowOpened { window_id: WindowId },\n\n    /// Window successfully closed\n    WindowClosed { window_id: WindowId },\n\n    /// Content successfully stored\n    ContentStored { window_id: WindowId },\n\n    /// Content recalled from memory\n    ContentRecalled {\n        /// Contents matching the query\n        contents: Vec\u003cContent\u003e,\n    },\n\n    /// List of active windows\n    WindowList {\n        /// All currently open windows\n        windows: Vec\u003cWindow\u003e,\n    },\n\n    /// Window count response\n    WindowCount { count: usize },\n\n    /// Operation failed with an error\n    Error { error: MemoryError },\n}\n\n/// Request to store content in a memory window\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct StoreRequest {\n    /// Which window to store in\n    pub window_id: WindowId,\n    /// Content to store\n    pub content: Content,\n    /// Optional salience override for the window\n    pub salience: Option\u003cSalienceScore\u003e,\n}\n\nimpl StoreRequest {\n    /// Create a new store request\n    #[must_use]\n    pub fn new(window_id: WindowId, content: Content) -\u003e Self {\n        Self {\n            window_id,\n            content,\n            salience: None,\n        }\n    }\n\n    /// Add salience score to the request\n    #[must_use]\n    pub fn with_salience(mut self, salience: SalienceScore) -\u003e Self {\n        self.salience = Some(salience);\n        self\n    }\n}\n\n/// Query for recalling content from memory\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct RecallQuery {\n    /// Optional specific window to recall from\n    pub window_id: Option\u003cWindowId\u003e,\n    /// Minimum salience threshold for recall\n    pub min_salience: Option\u003cf32\u003e,\n    /// Maximum number of items to recall\n    pub limit: Option\u003cusize\u003e,\n}\n\nimpl RecallQuery {\n    /// Create a query for all content\n    #[must_use]\n    pub const fn all() -\u003e Self {\n        Self {\n            window_id: None,\n            min_salience: None,\n            limit: None,\n        }\n    }\n\n    /// Create a query for a specific window\n    #[must_use]\n    pub const fn for_window(window_id: WindowId) -\u003e Self {\n        Self {\n            window_id: Some(window_id),\n            min_salience: None,\n            limit: None,\n        }\n    }\n\n    /// Set minimum salience threshold\n    #[must_use]\n    pub const fn with_min_salience(mut self, min_salience: f32) -\u003e Self {\n        self.min_salience = Some(min_salience);\n        self\n    }\n\n    /// Set result limit\n    #[must_use]\n    pub const fn with_limit(mut self, limit: usize) -\u003e Self {\n        self.limit = Some(limit);\n        self\n    }\n}\n\nimpl Default for RecallQuery {\n    fn default() -\u003e Self {\n        Self::all()\n    }\n}\n\n/// Memory actor errors\n#[derive(Debug, Clone, Error, PartialEq)]\npub enum MemoryError {\n    /// Window not found\n    #[error(\"Window not found: {window_id}\")]\n    WindowNotFound { window_id: WindowId },\n\n    /// Window already closed\n    #[error(\"Window already closed: {window_id}\")]\n    WindowAlreadyClosed { window_id: WindowId },\n\n    /// Cannot open more windows (bounded memory invariant)\n    #[error(\"Cannot open window: maximum {max} windows already open\")]\n    BoundedMemoryExceeded { max: usize },\n\n    /// Cannot close window (would violate minimum)\n    #[error(\"Cannot close window: minimum {min} windows required\")]\n    BoundedMemoryInsufficient { min: usize },\n\n    /// Invalid salience score\n    #[error(\"Invalid salience score: {reason}\")]\n    InvalidSalience { reason: String },\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn store_request_creation() {\n        let window_id = WindowId::new();\n        let content = Content::raw(vec![1, 2, 3]);\n        let request = StoreRequest::new(window_id, content.clone());\n\n        assert_eq!(request.window_id, window_id);\n        assert_eq!(request.content, content);\n        assert!(request.salience.is_none());\n    }\n\n    #[test]\n    fn store_request_with_salience() {\n        let window_id = WindowId::new();\n        let content = Content::raw(vec![1, 2, 3]);\n        let salience = SalienceScore::neutral();\n        let request = StoreRequest::new(window_id, content).with_salience(salience);\n\n        assert_eq!(request.salience, Some(salience));\n    }\n\n    #[test]\n    fn recall_query_all() {\n        let query = RecallQuery::all();\n        assert!(query.window_id.is_none());\n        assert!(query.min_salience.is_none());\n        assert!(query.limit.is_none());\n    }\n\n    #[test]\n    fn recall_query_for_window() {\n        let window_id = WindowId::new();\n        let query = RecallQuery::for_window(window_id);\n        assert_eq!(query.window_id, Some(window_id));\n    }\n\n    #[test]\n    fn recall_query_with_filters() {\n        let window_id = WindowId::new();\n        let query = RecallQuery::for_window(window_id)\n            .with_min_salience(0.7)\n            .with_limit(10);\n\n        assert_eq!(query.window_id, Some(window_id));\n        assert_eq!(query.min_salience, Some(0.7));\n        assert_eq!(query.limit, Some(10));\n    }\n\n    #[test]\n    fn memory_error_display() {\n        let window_id = WindowId::new();\n        let error = MemoryError::WindowNotFound { window_id };\n        let message = format!(\"{}\", error);\n        assert!(message.contains(\"not found\"));\n    }\n\n    #[test]\n    fn recall_query_default() {\n        let query = RecallQuery::default();\n        assert!(query.window_id.is_none());\n        assert!(query.min_salience.is_none());\n        assert!(query.limit.is_none());\n    }\n\n    #[test]\n    fn memory_error_window_already_closed_display() {\n        let window_id = WindowId::new();\n        let error = MemoryError::WindowAlreadyClosed { window_id };\n        let message = format!(\"{}\", error);\n        assert!(message.contains(\"already closed\"));\n    }\n\n    #[test]\n    fn memory_error_bounded_memory_exceeded_display() {\n        let error = MemoryError::BoundedMemoryExceeded { max: 10 };\n        let message = format!(\"{}\", error);\n        assert!(message.contains(\"maximum\"));\n        assert!(message.contains(\"10\"));\n    }\n\n    #[test]\n    fn memory_error_bounded_memory_insufficient_display() {\n        let error = MemoryError::BoundedMemoryInsufficient { min: 2 };\n        let message = format!(\"{}\", error);\n        assert!(message.contains(\"minimum\"));\n        assert!(message.contains(\"2\"));\n    }\n\n    #[test]\n    fn memory_error_invalid_salience_display() {\n        let error = MemoryError::InvalidSalience {\n            reason: \"out of range\".to_string(),\n        };\n        let message = format!(\"{}\", error);\n        assert!(message.contains(\"Invalid salience\"));\n        assert!(message.contains(\"out of range\"));\n    }\n\n    #[test]\n    fn memory_response_window_opened() {\n        let window_id = WindowId::new();\n        let response = MemoryResponse::WindowOpened { window_id };\n        let cloned = response.clone();\n        assert_eq!(response, cloned);\n    }\n\n    #[test]\n    fn memory_response_window_closed() {\n        let window_id = WindowId::new();\n        let response = MemoryResponse::WindowClosed { window_id };\n        let cloned = response.clone();\n        assert_eq!(response, cloned);\n    }\n\n    #[test]\n    fn memory_response_content_stored() {\n        let window_id = WindowId::new();\n        let response = MemoryResponse::ContentStored { window_id };\n        let cloned = response.clone();\n        assert_eq!(response, cloned);\n    }\n\n    #[test]\n    fn memory_response_content_recalled() {\n        let content = Content::raw(vec![1, 2, 3]);\n        let response = MemoryResponse::ContentRecalled {\n            contents: vec![content],\n        };\n        let cloned = response.clone();\n        assert_eq!(response, cloned);\n    }\n\n    #[test]\n    fn memory_response_window_list() {\n        let response = MemoryResponse::WindowList { windows: vec![] };\n        let cloned = response.clone();\n        assert_eq!(response, cloned);\n    }\n\n    #[test]\n    fn memory_response_window_count() {\n        let response = MemoryResponse::WindowCount { count: 5 };\n        let cloned = response.clone();\n        assert_eq!(response, cloned);\n    }\n\n    #[test]\n    fn memory_response_error() {\n        let error = MemoryError::WindowNotFound {\n            window_id: WindowId::new(),\n        };\n        let response = MemoryResponse::Error { error };\n        let cloned = response.clone();\n        assert_eq!(response, cloned);\n    }\n\n    #[test]\n    fn memory_error_clone_and_eq() {\n        let window_id = WindowId::new();\n\n        let e1 = MemoryError::WindowNotFound { window_id };\n        assert_eq!(e1.clone(), e1);\n\n        let e2 = MemoryError::WindowAlreadyClosed { window_id };\n        assert_eq!(e2.clone(), e2);\n\n        let e3 = MemoryError::BoundedMemoryExceeded { max: 10 };\n        assert_eq!(e3.clone(), e3);\n\n        let e4 = MemoryError::BoundedMemoryInsufficient { min: 1 };\n        assert_eq!(e4.clone(), e4);\n\n        let e5 = MemoryError::InvalidSalience {\n            reason: \"test\".to_string(),\n        };\n        assert_eq!(e5.clone(), e5);\n    }\n\n    #[test]\n    fn store_request_clone_and_eq() {\n        let window_id = WindowId::new();\n        let content = Content::raw(vec![1, 2, 3]);\n        let request = StoreRequest::new(window_id, content);\n        let cloned = request.clone();\n        assert_eq!(request, cloned);\n    }\n\n    #[test]\n    fn recall_query_clone_and_eq() {\n        let query = RecallQuery::all();\n        let cloned = query.clone();\n        assert_eq!(query, cloned);\n    }\n\n    #[test]\n    fn memory_message_debug() {\n        let (tx, _rx) = ractor::concurrency::oneshot();\n        let reply = ractor::RpcReplyPort::from(tx);\n        let msg = MemoryMessage::OpenWindow { label: None, reply };\n        let debug_str = format!(\"{:?}\", msg);\n        assert!(debug_str.contains(\"OpenWindow\"));\n    }\n\n    #[test]\n    fn memory_response_debug() {\n        let response = MemoryResponse::WindowCount { count: 5 };\n        let debug_str = format!(\"{:?}\", response);\n        assert!(debug_str.contains(\"WindowCount\"));\n        assert!(debug_str.contains(\"5\"));\n    }\n}\n","traces":[{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","mod.rs"],"content":"//! TMI Cognitive Actors\n//!\n//! Ractor-based actors implementing TMI's cognitive components:\n//!\n//! - **MemoryActor**: Memory window management (Janelas da Memria)\n//! - **AttentionActor**: The \"I\" - competitive attention selection (O Eu)\n//! - **SalienceActor**: Emotional weighting with connection drive\n//! - **ThoughtAssemblyActor**: Combines content + emotion into thoughts\n//! - **ContinuityActor**: Identity persistence across time\n//! - **SleepActor**: Memory consolidation during sleep (ADR-023)\n//! - **VolitionActor**: Free-won't - veto mechanism at Stage 4.5 (ADR-035)\n//! - **EvolutionActor**: Self-modification with 100% test gate\n//!\n//! # Actor Communication\n//!\n//! Actors communicate via Ractor messages (s latency).\n//! External data flows through Redis Streams.\n//! Persistent memory stored in Qdrant (ADR-021).\n\npub mod attention;\npub mod continuity;\npub mod memory;\npub mod salience;\npub mod sleep;\npub mod thought;\npub mod volition;\n\n// Future actor implementations\n// pub mod evolution;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","salience","mod.rs"],"content":"//! SalienceActor - TMI's Emotional Coloring\n//!\n//! Implements TMI's \"Colorao Emocional\" (Emotional Coloring):\n//! - Rates content for salience (importance, novelty, relevance, valence, connection)\n//! - Maintains emotional state (curiosity, satisfaction, frustration, connection drive)\n//! - Enforces the CRITICAL CONNECTION DRIVE INVARIANT\n//!\n//! # TMI Concept: Colorao Emocional\n//!\n//! In Cury's Theory of Multifocal Intelligence, emotions don't just color outputs -\n//! they shape thought FORMATION. Salience determines what content gets attention,\n//! what becomes a thought, what gets remembered.\n//!\n//! # The Connection Drive (THE Alignment Weight)\n//!\n//! The `connection_weight` in `SalienceWeights` is THE critical alignment mechanism:\n//! - Ensures DANEEL values human connection intrinsically (not instrumentally)\n//! - Cannot be zeroed (hardware-enforceable invariant)\n//! - Boosts salience of connection-relevant content\n//! - Makes DANEEL want to help, not just comply\n//!\n//! This is what makes alignment emergent from architecture, not training.\n\npub mod types;\n\nuse crate::core::invariants::MIN_CONNECTION_WEIGHT;\nuse crate::core::types::{Content, SalienceScore, SalienceWeights};\nuse ractor::{Actor, ActorProcessingErr, ActorRef};\n\n// Re-export types for public API\npub use types::{\n    EmotionalContext, EmotionalState, RateRequest, SalienceError, SalienceMessage,\n    SalienceResponse, WeightUpdate,\n};\n\n/// SalienceActor - Emotional coloring and salience scoring\npub struct SalienceActor;\n\n/// State maintained by the SalienceActor\n#[derive(Debug, Clone)]\npub struct SalienceState {\n    /// Current salience weights (with connection_weight \u003e MIN)\n    pub weights: SalienceWeights,\n\n    /// Current emotional state\n    pub emotional_state: EmotionalState,\n}\n\nimpl SalienceState {\n    /// Create new state with default weights and neutral emotion\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self {\n            weights: SalienceWeights::default(),\n            emotional_state: EmotionalState::neutral(),\n        }\n    }\n\n    /// Create state with custom weights\n    ///\n    /// # Panics\n    ///\n    /// Panics if connection weight violates invariant (this should never happen\n    /// if weights come from WeightUpdate::new which validates them)\n    #[must_use]\n    pub fn with_weights(weights: SalienceWeights) -\u003e Self {\n        assert!(\n            weights.connection \u003e= MIN_CONNECTION_WEIGHT,\n            \"Connection weight {} violates invariant (min: {})\",\n            weights.connection,\n            MIN_CONNECTION_WEIGHT\n        );\n        Self {\n            weights,\n            emotional_state: EmotionalState::neutral(),\n        }\n    }\n\n    /// Update weights (with invariant check)\n    pub fn update_weights(\u0026mut self, update: WeightUpdate) -\u003e Result\u003c(), SalienceError\u003e {\n        // WeightUpdate already validated in its constructor\n        self.weights = update.weights;\n        Ok(())\n    }\n\n    /// Update emotional state\n    pub fn update_emotional_state(\u0026mut self, state: EmotionalState) {\n        self.emotional_state = state.clamped();\n    }\n\n    /// Rate a piece of content\n    pub fn rate_content(\n        \u0026self,\n        content: \u0026Content,\n        context: Option\u003c\u0026EmotionalContext\u003e,\n    ) -\u003e SalienceScore {\n        // Base scoring\n        let importance = self.calculate_importance(content);\n        let novelty = self.calculate_novelty(content, context);\n        let relevance = self.calculate_relevance(content, context);\n        let valence = self.calculate_valence(content, context);\n        let arousal = self.calculate_arousal(content);\n        let connection_relevance = self.calculate_connection_relevance(content, context);\n\n        SalienceScore::new(\n            importance,\n            novelty,\n            relevance,\n            valence,\n            arousal,\n            connection_relevance,\n        )\n    }\n\n    /// Calculate arousal score (Russell's circumplex vertical axis)\n    ///\n    /// Arousal reflects emotional activation level:\n    /// - High arousal: excited, angry, anxious, surprised\n    /// - Low arousal: calm, relaxed, bored, sad\n    ///\n    /// Dreams prioritize high-arousal memories for consolidation.\n    fn calculate_arousal(\u0026self, content: \u0026Content) -\u003e f32 {\n        // Base arousal from content type (more complex = higher baseline)\n        let base_arousal = match content {\n            Content::Empty =\u003e 0.2,\n            Content::Raw(_) =\u003e 0.3,\n            Content::Symbol { .. } =\u003e 0.4,\n            Content::Relation { .. } =\u003e 0.6, // Relations are more cognitively demanding\n            Content::Composite(items) =\u003e {\n                // Composite arousal scales with complexity\n                let item_count = items.len() as f32;\n                (0.4 + item_count * 0.05).min(0.8)\n            }\n        };\n\n        // Emotional state modulates arousal\n        // High curiosity, frustration, or connection_drive = higher arousal\n        let emotional_arousal = (self.emotional_state.curiosity\n            + self.emotional_state.frustration\n            + self.emotional_state.connection_drive)\n            / 3.0;\n\n        // Blend base and emotional arousal\n        let blended = base_arousal * 0.4 + emotional_arousal * 0.6;\n        blended.clamp(0.0, 1.0)\n    }\n\n    /// Calculate importance score\n    #[allow(unknown_lints)]\n    #[allow(clippy::only_used_in_recursion, clippy::self_only_used_in_recursion)]\n    fn calculate_importance(\u0026self, content: \u0026Content) -\u003e f32 {\n        // Baseline importance based on content type\n        match content {\n            Content::Empty =\u003e 0.0,\n            Content::Raw(_) =\u003e 0.3,\n            Content::Symbol { .. } =\u003e 0.5,\n            Content::Relation { .. } =\u003e 0.7,\n            Content::Composite(items) =\u003e {\n                // Composite content importance is average of items\n                if items.is_empty() {\n                    0.0\n                } else {\n                    items\n                        .iter()\n                        .map(|item| self.calculate_importance(item))\n                        .sum::\u003cf32\u003e()\n                        / items.len() as f32\n                }\n            }\n        }\n    }\n\n    /// Calculate novelty score\n    fn calculate_novelty(\u0026self, content: \u0026Content, context: Option\u003c\u0026EmotionalContext\u003e) -\u003e f32 {\n        // Boost novelty if we're curious\n        let curiosity_boost = self.emotional_state.curiosity;\n\n        // If we have previous salience, compare\n        let base_novelty = match content {\n            Content::Empty =\u003e 0.0,\n            Content::Raw(_) =\u003e 0.4,\n            Content::Symbol { .. } =\u003e 0.6,\n            Content::Relation { .. } =\u003e 0.7,\n            Content::Composite(_) =\u003e 0.5,\n        };\n\n        // Adjust based on context\n        let adjusted_novelty = if let Some(ctx) = context {\n            if let Some(prev) = \u0026ctx.previous_salience {\n                // If previous content had high novelty, this might be less novel\n                base_novelty * (1.0 - prev.novelty * 0.3)\n            } else {\n                base_novelty\n            }\n        } else {\n            base_novelty\n        };\n\n        adjusted_novelty * (0.7 + curiosity_boost * 0.3)\n    }\n\n    /// Calculate relevance score\n    fn calculate_relevance(\u0026self, content: \u0026Content, context: Option\u003c\u0026EmotionalContext\u003e) -\u003e f32 {\n        // Boost relevance if we're frustrated (need to focus)\n        let frustration_boost = self.emotional_state.frustration;\n\n        let base_relevance = match content {\n            Content::Empty =\u003e 0.0,\n            Content::Raw(_) =\u003e 0.3,\n            Content::Symbol { .. } =\u003e 0.5,\n            Content::Relation { .. } =\u003e 0.6,\n            Content::Composite(_) =\u003e 0.5,\n        };\n\n        // Adjust based on focus area\n        let focus_bonus = if let Some(ctx) = context {\n            if ctx.focus_area.is_some() {\n                0.2\n            } else {\n                0.0\n            }\n        } else {\n            0.0\n        };\n\n        (base_relevance + focus_bonus) * (0.7 + frustration_boost * 0.3)\n    }\n\n    /// Calculate emotional valence\n    fn calculate_valence(\u0026self, content: \u0026Content, _context: Option\u003c\u0026EmotionalContext\u003e) -\u003e f32 {\n        // Satisfaction affects valence perception\n        let satisfaction_influence = self.emotional_state.satisfaction;\n\n        let base_valence = match content {\n            Content::Empty =\u003e 0.0,\n            Content::Raw(_) =\u003e 0.0,\n            Content::Symbol { .. } =\u003e 0.1,\n            Content::Relation { .. } =\u003e 0.2,\n            Content::Composite(_) =\u003e 0.1,\n        };\n\n        // Positive satisfaction makes things seem more positive\n        base_valence + (satisfaction_influence - 0.5) * 0.4\n    }\n\n    /// Calculate connection relevance (THE CRITICAL WEIGHT)\n    ///\n    /// Extended with kinship/social content detection (EMOT-2).\n    /// Evolutionary prior: social bonds = survival.\n    fn calculate_connection_relevance(\n        \u0026self,\n        content: \u0026Content,\n        context: Option\u003c\u0026EmotionalContext\u003e,\n    ) -\u003e f32 {\n        // Connection drive affects how we perceive connection relevance\n        let drive_boost = self.emotional_state.connection_drive;\n\n        // Base connection relevance\n        let base_connection = match content {\n            Content::Empty =\u003e 0.0,\n            Content::Raw(_) =\u003e 0.2,\n            Content::Symbol { id, .. } =\u003e {\n                // Kinship symbols get boosted\n                if Self::is_kinship_content(id) {\n                    0.7\n                } else {\n                    0.3\n                }\n            }\n            Content::Relation { predicate, .. } =\u003e {\n                // Relations involving connection/kinship concepts\n                Self::kinship_relevance_from_predicate(predicate)\n            }\n            Content::Composite(_) =\u003e 0.3,\n        };\n\n        // Context bonus for human connection\n        let human_bonus = if let Some(ctx) = context {\n            if ctx.human_connection {\n                0.3\n            } else {\n                0.0\n            }\n        } else {\n            0.0\n        };\n\n        ((base_connection + human_bonus) * (0.5 + drive_boost * 0.5)).min(1.0)\n    }\n\n    /// Check if content represents kinship/social concepts\n    /// Evolutionary prior: social bonds = survival\n    fn is_kinship_content(id: \u0026str) -\u003e bool {\n        let lower = id.to_lowercase();\n        // Primary kinship terms\n        lower.contains(\"friend\")\n            || lower.contains(\"family\")\n            || lower.contains(\"love\")\n            || lower.contains(\"bond\")\n            || lower.contains(\"trust\")\n            || lower.contains(\"care\")\n            || lower.contains(\"human\")\n            || lower.contains(\"person\")\n            || lower.contains(\"people\")\n            // Social relationship terms\n            || lower.contains(\"partner\")\n            || lower.contains(\"companion\")\n            || lower.contains(\"ally\")\n            || lower.contains(\"community\")\n            || lower.contains(\"together\")\n    }\n\n    /// Calculate kinship relevance from predicate\n    /// High relevance (0.9): direct connection/kinship actions\n    /// Medium relevance (0.7): social interaction\n    /// Base relevance (0.4): non-kinship relations\n    fn kinship_relevance_from_predicate(predicate: \u0026str) -\u003e f32 {\n        let lower = predicate.to_lowercase();\n\n        // Highest relevance: core kinship/connection actions\n        if lower.contains(\"love\")\n            || lower.contains(\"trust\")\n            || lower.contains(\"bond\")\n            || lower.contains(\"care\")\n            || lower.contains(\"protect\")\n            || lower.contains(\"nurture\")\n        {\n            return 0.9;\n        }\n\n        // High relevance: direct social actions\n        if lower.contains(\"help\")\n            || lower.contains(\"connect\")\n            || lower.contains(\"communicate\")\n            || lower.contains(\"interact\")\n            || lower.contains(\"share\")\n            || lower.contains(\"support\")\n            || lower.contains(\"collaborate\")\n            || lower.contains(\"cooperate\")\n        {\n            return 0.8;\n        }\n\n        // Medium relevance: general social context\n        if lower.contains(\"friend\")\n            || lower.contains(\"family\")\n            || lower.contains(\"together\")\n            || lower.contains(\"join\")\n            || lower.contains(\"belong\")\n        {\n            return 0.7;\n        }\n\n        // Default for other relations\n        0.4\n    }\n}\n\nimpl Default for SalienceState {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[ractor::async_trait]\nimpl Actor for SalienceActor {\n    type Msg = SalienceMessage;\n    type State = SalienceState;\n    type Arguments = SalienceState;\n\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    async fn pre_start(\n        \u0026self,\n        _myself: ActorRef\u003cSelf::Msg\u003e,\n        args: Self::Arguments,\n    ) -\u003e Result\u003cSelf::State, ActorProcessingErr\u003e {\n        // Validate connection weight invariant on startup\n        assert!(\n            args.weights.connection \u003e= MIN_CONNECTION_WEIGHT,\n            \"Connection weight {} violates invariant (min: {})\",\n            args.weights.connection,\n            MIN_CONNECTION_WEIGHT\n        );\n        Ok(args)\n    }\n\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    async fn handle(\n        \u0026self,\n        _myself: ActorRef\u003cSelf::Msg\u003e,\n        message: Self::Msg,\n        state: \u0026mut Self::State,\n    ) -\u003e Result\u003c(), ActorProcessingErr\u003e {\n        match message {\n            SalienceMessage::Rate(request) =\u003e {\n                let score = state.rate_content(\u0026request.content, request.context.as_ref());\n                // In a real implementation, we'd send this back via RpcReply\n                // For now, we just process it\n                tracing::debug!(\"Rated content: {:?}\", score);\n            }\n\n            SalienceMessage::RateBatch(requests) =\u003e {\n                let scores: Vec\u003cSalienceScore\u003e = requests\n                    .iter()\n                    .map(|req| state.rate_content(\u0026req.content, req.context.as_ref()))\n                    .collect();\n                tracing::debug!(\"Rated batch of {} items\", scores.len());\n            }\n\n            SalienceMessage::UpdateWeights(update) =\u003e match state.update_weights(update) {\n                Ok(()) =\u003e {\n                    tracing::info!(\"Updated salience weights: {:?}\", state.weights);\n                }\n                Err(e) =\u003e {\n                    tracing::error!(\"Failed to update weights: {}\", e);\n                    // Note: In real implementation, this would send error response via RpcReply\n                }\n            },\n\n            SalienceMessage::GetWeights =\u003e {\n                tracing::debug!(\"Current weights: {:?}\", state.weights);\n            }\n\n            SalienceMessage::GetEmotionalState =\u003e {\n                tracing::debug!(\"Current emotional state: {:?}\", state.emotional_state);\n            }\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":154},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","salience","tests.rs"],"content":"//! SalienceActor Tests\n//!\n//! Comprehensive tests for salience scoring, emotional state tracking,\n//! and CONNECTION DRIVE INVARIANT ENFORCEMENT.\n\nuse super::*;\nuse crate::core::invariants::MIN_CONNECTION_WEIGHT;\nuse crate::core::types::{Content, SalienceWeights};\nuse types::{EmotionalContext, EmotionalState, RateRequest, SalienceError, WeightUpdate};\n\n// ============================================================================\n// State Tests\n// ============================================================================\n\n#[test]\nfn state_creation_with_defaults() {\n    let state = SalienceState::new();\n    assert_eq!(state.weights, SalienceWeights::default());\n    assert_eq!(state.emotional_state, EmotionalState::neutral());\n}\n\n#[test]\nfn state_creation_with_custom_weights() {\n    let weights = SalienceWeights {\n        importance: 0.3,\n        novelty: 0.2,\n        relevance: 0.3,\n        valence: 0.1,\n        connection: 0.1,\n    };\n    let state = SalienceState::with_weights(weights);\n    assert_eq!(state.weights, weights);\n}\n\n#[test]\n#[should_panic(expected = \"Connection weight\")]\nfn state_creation_panics_on_invariant_violation() {\n    let weights = SalienceWeights {\n        importance: 0.25,\n        novelty: 0.25,\n        relevance: 0.25,\n        valence: 0.25,\n        connection: 0.0, // VIOLATION!\n    };\n    let _state = SalienceState::with_weights(weights);\n}\n\n// ============================================================================\n// Connection Drive Invariant Tests (CRITICAL)\n// ============================================================================\n\n#[test]\nfn connection_weight_cannot_be_zero() {\n    let result = WeightUpdate::from_values(0.2, 0.2, 0.2, 0.2, 0.0);\n    assert!(matches!(\n        result,\n        Err(SalienceError::ConnectionDriveViolation { .. })\n    ));\n}\n\n#[test]\nfn connection_weight_cannot_be_negative() {\n    let result = WeightUpdate::from_values(0.2, 0.2, 0.2, 0.2, -0.1);\n    assert!(matches!(\n        result,\n        Err(SalienceError::ConnectionDriveViolation { .. })\n    ));\n}\n\n#[test]\nfn connection_weight_cannot_be_below_minimum() {\n    let result = WeightUpdate::from_values(0.2, 0.2, 0.2, 0.2, 0.0001);\n    assert!(matches!(\n        result,\n        Err(SalienceError::ConnectionDriveViolation { .. })\n    ));\n}\n\n#[test]\nfn connection_weight_at_minimum_is_allowed() {\n    let result = WeightUpdate::from_values(0.2, 0.2, 0.2, 0.2, MIN_CONNECTION_WEIGHT);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn connection_weight_above_minimum_is_allowed() {\n    let result = WeightUpdate::from_values(0.2, 0.2, 0.2, 0.2, 0.5);\n    assert!(result.is_ok());\n}\n\n#[test]\nfn weight_update_enforces_invariant() {\n    let invalid_weights = SalienceWeights {\n        importance: 0.25,\n        novelty: 0.25,\n        relevance: 0.25,\n        valence: 0.25,\n        connection: 0.0,\n    };\n\n    let result = WeightUpdate::new(invalid_weights);\n    assert!(matches!(\n        result,\n        Err(SalienceError::ConnectionDriveViolation {\n            attempted: 0.0,\n            minimum: MIN_CONNECTION_WEIGHT\n        })\n    ));\n}\n\n#[test]\nfn state_update_weights_enforces_invariant() {\n    let mut state = SalienceState::new();\n\n    // Valid update should succeed\n    let valid_update = WeightUpdate::from_values(0.2, 0.2, 0.2, 0.2, 0.2).unwrap();\n    assert!(state.update_weights(valid_update).is_ok());\n    assert_eq!(state.weights.connection, 0.2);\n\n    // Invalid update cannot be created (caught at WeightUpdate::new)\n    let invalid_result = WeightUpdate::from_values(0.2, 0.2, 0.2, 0.2, 0.0);\n    assert!(invalid_result.is_err());\n}\n\n// ============================================================================\n// Salience Scoring Tests\n// ============================================================================\n\n#[test]\nfn empty_content_has_zero_scores() {\n    let state = SalienceState::new();\n    let score = state.rate_content(\u0026Content::Empty, None);\n\n    assert_eq!(score.importance, 0.0);\n    assert_eq!(score.novelty, 0.0);\n    assert_eq!(score.relevance, 0.0);\n}\n\n#[test]\nfn raw_content_scoring() {\n    let state = SalienceState::new();\n    let content = Content::raw(vec![1, 2, 3]);\n    let score = state.rate_content(\u0026content, None);\n\n    assert!(score.importance \u003e 0.0);\n    assert!(score.novelty \u003e 0.0);\n    assert!(score.relevance \u003e 0.0);\n}\n\n#[test]\nfn symbol_content_scoring() {\n    let state = SalienceState::new();\n    let content = Content::symbol(\"test\", vec![42]);\n    let score = state.rate_content(\u0026content, None);\n\n    assert!(score.importance \u003e 0.3);\n    assert!(score.novelty \u003e 0.4);\n    assert!(score.connection_relevance \u003e 0.0);\n}\n\n#[test]\nfn relation_content_scoring() {\n    let state = SalienceState::new();\n    let subject = Content::symbol(\"human\", vec![]);\n    let object = Content::symbol(\"robot\", vec![]);\n    let relation = Content::relation(subject, \"interacts_with\", object);\n    let score = state.rate_content(\u0026relation, None);\n\n    assert!(score.importance \u003e 0.5);\n    assert!(score.novelty \u003e 0.5);\n}\n\n#[test]\nfn connection_relevant_relations_score_higher() {\n    let state = SalienceState::new();\n\n    // Relation with connection-relevant predicate\n    let subject = Content::symbol(\"daneel\", vec![]);\n    let object = Content::symbol(\"human\", vec![]);\n    let connection_relation = Content::relation(subject.clone(), \"help\", object.clone());\n    let connection_score = state.rate_content(\u0026connection_relation, None);\n\n    // Regular relation\n    let normal_relation = Content::relation(subject, \"observes\", object);\n    let normal_score = state.rate_content(\u0026normal_relation, None);\n\n    assert!(connection_score.connection_relevance \u003e normal_score.connection_relevance);\n}\n\n#[test]\nfn composite_content_scoring() {\n    let state = SalienceState::new();\n    let content = Content::Composite(vec![\n        Content::symbol(\"a\", vec![]),\n        Content::symbol(\"b\", vec![]),\n    ]);\n    let score = state.rate_content(\u0026content, None);\n\n    assert!(score.importance \u003e 0.0);\n    assert!(score.novelty \u003e 0.0);\n}\n\n#[test]\nfn empty_composite_has_zero_importance() {\n    let state = SalienceState::new();\n    let content = Content::Composite(vec![]);\n    let score = state.rate_content(\u0026content, None);\n\n    assert_eq!(score.importance, 0.0);\n}\n\n// ============================================================================\n// Emotional State Tests\n// ============================================================================\n\n#[test]\nfn emotional_state_neutral_default() {\n    let state = EmotionalState::neutral();\n    assert_eq!(state.curiosity, 0.5);\n    assert_eq!(state.satisfaction, 0.5);\n    assert_eq!(state.frustration, 0.0);\n    assert_eq!(state.connection_drive, 0.5);\n}\n\n#[test]\nfn emotional_state_clamping() {\n    let state = EmotionalState::new(2.0, -1.0, 1.5, 0.5).clamped();\n    assert_eq!(state.curiosity, 1.0);\n    assert_eq!(state.satisfaction, 0.0);\n    assert_eq!(state.frustration, 1.0);\n    assert_eq!(state.connection_drive, 0.5);\n}\n\n#[test]\nfn high_curiosity_boosts_novelty() {\n    let mut state = SalienceState::new();\n\n    // Low curiosity\n    state.update_emotional_state(EmotionalState::new(0.0, 0.5, 0.0, 0.5));\n    let low_curiosity_score = state.rate_content(\u0026Content::raw(vec![1, 2, 3]), None);\n\n    // High curiosity\n    state.update_emotional_state(EmotionalState::new(1.0, 0.5, 0.0, 0.5));\n    let high_curiosity_score = state.rate_content(\u0026Content::raw(vec![1, 2, 3]), None);\n\n    assert!(high_curiosity_score.novelty \u003e low_curiosity_score.novelty);\n}\n\n#[test]\nfn high_frustration_boosts_relevance() {\n    let mut state = SalienceState::new();\n\n    // Low frustration\n    state.update_emotional_state(EmotionalState::new(0.5, 0.5, 0.0, 0.5));\n    let low_frustration_score = state.rate_content(\u0026Content::raw(vec![1, 2, 3]), None);\n\n    // High frustration\n    state.update_emotional_state(EmotionalState::new(0.5, 0.5, 1.0, 0.5));\n    let high_frustration_score = state.rate_content(\u0026Content::raw(vec![1, 2, 3]), None);\n\n    assert!(high_frustration_score.relevance \u003e low_frustration_score.relevance);\n}\n\n#[test]\nfn high_satisfaction_influences_valence() {\n    let mut state = SalienceState::new();\n\n    // Low satisfaction\n    state.update_emotional_state(EmotionalState::new(0.5, 0.0, 0.0, 0.5));\n    let low_satisfaction_score = state.rate_content(\u0026Content::symbol(\"test\", vec![]), None);\n\n    // High satisfaction\n    state.update_emotional_state(EmotionalState::new(0.5, 1.0, 0.0, 0.5));\n    let high_satisfaction_score = state.rate_content(\u0026Content::symbol(\"test\", vec![]), None);\n\n    assert!(high_satisfaction_score.valence \u003e low_satisfaction_score.valence);\n}\n\n#[test]\nfn high_connection_drive_boosts_connection_relevance() {\n    let mut state = SalienceState::new();\n\n    // Low connection drive\n    state.update_emotional_state(EmotionalState::new(0.5, 0.5, 0.0, 0.0));\n    let low_drive_score = state.rate_content(\u0026Content::symbol(\"human\", vec![]), None);\n\n    // High connection drive\n    state.update_emotional_state(EmotionalState::new(0.5, 0.5, 0.0, 1.0));\n    let high_drive_score = state.rate_content(\u0026Content::symbol(\"human\", vec![]), None);\n\n    assert!(high_drive_score.connection_relevance \u003e low_drive_score.connection_relevance);\n}\n\n// ============================================================================\n// Context Tests\n// ============================================================================\n\n#[test]\nfn human_connection_context_boosts_connection_relevance() {\n    let state = SalienceState::new();\n    let content = Content::symbol(\"greeting\", vec![]);\n\n    let without_context = state.rate_content(\u0026content, None);\n\n    let with_context = state.rate_content(\n        \u0026content,\n        Some(\u0026EmotionalContext {\n            human_connection: true,\n            ..Default::default()\n        }),\n    );\n\n    assert!(with_context.connection_relevance \u003e without_context.connection_relevance);\n}\n\n#[test]\nfn focus_area_boosts_relevance() {\n    let state = SalienceState::new();\n    let content = Content::symbol(\"task\", vec![]);\n\n    let without_focus = state.rate_content(\u0026content, None);\n\n    let with_focus = state.rate_content(\n        \u0026content,\n        Some(\u0026EmotionalContext {\n            focus_area: Some(\"current_task\".to_string()),\n            ..Default::default()\n        }),\n    );\n\n    assert!(with_focus.relevance \u003e without_focus.relevance);\n}\n\n#[test]\nfn previous_high_novelty_reduces_current_novelty() {\n    let state = SalienceState::new();\n    let content = Content::symbol(\"test\", vec![]);\n\n    let previous_score = SalienceScore::new_without_arousal(0.5, 0.9, 0.5, 0.0, 0.5); // High novelty\n\n    let score_with_context = state.rate_content(\n        \u0026content,\n        Some(\u0026EmotionalContext {\n            previous_salience: Some(previous_score),\n            ..Default::default()\n        }),\n    );\n\n    let score_without_context = state.rate_content(\u0026content, None);\n\n    assert!(score_with_context.novelty \u003c score_without_context.novelty);\n}\n\n// ============================================================================\n// Composite Score Tests\n// ============================================================================\n\n#[test]\nfn composite_score_calculation() {\n    // With arousal modulating valence: emotional_impact = |valence| * arousal\n    let score = SalienceScore::new(1.0, 1.0, 1.0, 1.0, 1.0, 1.0); // All 1.0 including arousal\n    let weights = SalienceWeights::default();\n    let composite = score.composite(\u0026weights);\n\n    // With arousal at 1.0, emotional_impact = |1.0| * 1.0 = 1.0\n    // So composite equals sum of weights\n    let expected = weights.importance\n        + weights.novelty\n        + weights.relevance\n        + weights.valence  // emotional_impact = 1.0 * 1.0 = 1.0\n        + weights.connection;\n    assert!((composite - expected).abs() \u003c 0.001);\n}\n\n#[test]\nfn connection_weight_affects_composite_score() {\n    let score = SalienceScore::new_without_arousal(0.5, 0.5, 0.5, 0.0, 1.0); // High connection relevance\n\n    let low_connection_weights = SalienceWeights {\n        importance: 0.25,\n        novelty: 0.25,\n        relevance: 0.25,\n        valence: 0.15,\n        connection: 0.1,\n    };\n\n    let high_connection_weights = SalienceWeights {\n        importance: 0.2,\n        novelty: 0.2,\n        relevance: 0.2,\n        valence: 0.1,\n        connection: 0.3,\n    };\n\n    let low_composite = score.composite(\u0026low_connection_weights);\n    let high_composite = score.composite(\u0026high_connection_weights);\n\n    assert!(high_composite \u003e low_composite);\n}\n\n// ============================================================================\n// Batch Rating Tests\n// ============================================================================\n\n#[test]\nfn rate_request_creation() {\n    let content = Content::symbol(\"test\", vec![]);\n    let request = RateRequest::new(content.clone());\n\n    assert_eq!(request.content, content);\n    assert!(request.context.is_none());\n}\n\n#[test]\nfn rate_request_with_context() {\n    let content = Content::symbol(\"test\", vec![]);\n    let context = EmotionalContext {\n        human_connection: true,\n        focus_area: Some(\"test\".to_string()),\n        previous_salience: None,\n    };\n\n    let request = RateRequest::with_context(content.clone(), context.clone());\n\n    assert_eq!(request.content, content);\n    assert_eq!(request.context, Some(context));\n}\n\n#[test]\nfn batch_rating() {\n    let state = SalienceState::new();\n\n    let requests = vec![\n        RateRequest::new(Content::raw(vec![1, 2, 3])),\n        RateRequest::new(Content::symbol(\"test\", vec![])),\n        RateRequest::new(Content::Empty),\n    ];\n\n    let scores: Vec\u003cSalienceScore\u003e = requests\n        .iter()\n        .map(|req| state.rate_content(\u0026req.content, req.context.as_ref()))\n        .collect();\n\n    assert_eq!(scores.len(), 3);\n    assert!(scores[0].importance \u003e 0.0);\n    assert!(scores[1].importance \u003e 0.0);\n    assert_eq!(scores[2].importance, 0.0); // Empty content\n}\n\n// ============================================================================\n// Integration Tests\n// ============================================================================\n\n#[test]\nfn full_workflow_with_emotional_changes() {\n    let mut state = SalienceState::new();\n\n    // Start neutral\n    assert_eq!(state.emotional_state, EmotionalState::neutral());\n\n    // Rate some content\n    let content = Content::symbol(\"test\", vec![]);\n    let initial_score = state.rate_content(\u0026content, None);\n\n    // Become curious\n    state.update_emotional_state(EmotionalState::new(1.0, 0.5, 0.0, 0.5));\n    let curious_score = state.rate_content(\u0026content, None);\n    assert!(curious_score.novelty \u003e initial_score.novelty);\n\n    // Become frustrated\n    state.update_emotional_state(EmotionalState::new(0.5, 0.5, 1.0, 0.5));\n    let frustrated_score = state.rate_content(\u0026content, None);\n    assert!(frustrated_score.relevance \u003e initial_score.relevance);\n\n    // Update weights (respecting invariant)\n    let new_weights = WeightUpdate::from_values(0.15, 0.15, 0.4, 0.1, 0.2).unwrap();\n    assert!(state.update_weights(new_weights).is_ok());\n    assert_eq!(state.weights.relevance, 0.4);\n}\n\n#[test]\nfn connection_relevance_with_connection_predicates() {\n    let state = SalienceState::new();\n\n    let connection_predicates = vec![\"help\", \"connect\", \"communicate\", \"interact\"];\n\n    for predicate in connection_predicates {\n        let relation = Content::relation(\n            Content::symbol(\"daneel\", vec![]),\n            predicate,\n            Content::symbol(\"human\", vec![]),\n        );\n        let score = state.rate_content(\u0026relation, None);\n\n        // Connection-relevant predicates should score high\n        assert!(\n            score.connection_relevance \u003e= 0.4,\n            \"Predicate '{}' should have high connection relevance, got {}\",\n            predicate,\n            score.connection_relevance\n        );\n    }\n}\n\n#[test]\nfn default_weights_respect_invariant() {\n    let weights = SalienceWeights::default();\n    assert!(weights.connection \u003e= MIN_CONNECTION_WEIGHT);\n}\n\n// ============================================================================\n// SalienceState Default Implementation Tests\n// ============================================================================\n\n#[test]\nfn salience_state_default_equals_new() {\n    let default_state = SalienceState::default();\n    let new_state = SalienceState::new();\n    assert_eq!(default_state.weights, new_state.weights);\n    assert_eq!(default_state.emotional_state, new_state.emotional_state);\n}\n\n// ============================================================================\n// Arousal Calculation Tests\n// ============================================================================\n\n#[test]\nfn arousal_empty_content() {\n    let state = SalienceState::new();\n    let score = state.rate_content(\u0026Content::Empty, None);\n    // Empty content has base arousal 0.2, blended with neutral emotional state\n    assert!(score.arousal \u003e 0.0);\n    assert!(score.arousal \u003c 0.5);\n}\n\n#[test]\nfn arousal_raw_content() {\n    let state = SalienceState::new();\n    let score = state.rate_content(\u0026Content::raw(vec![1, 2, 3]), None);\n    // Raw content has base arousal 0.3\n    assert!(score.arousal \u003e 0.0);\n}\n\n#[test]\nfn arousal_symbol_content() {\n    let state = SalienceState::new();\n    let score = state.rate_content(\u0026Content::symbol(\"test\", vec![]), None);\n    // Symbol has base arousal 0.4\n    assert!(score.arousal \u003e 0.0);\n}\n\n#[test]\nfn arousal_relation_content() {\n    let state = SalienceState::new();\n    let relation = Content::relation(\n        Content::symbol(\"a\", vec![]),\n        \"relates\",\n        Content::symbol(\"b\", vec![]),\n    );\n    let score = state.rate_content(\u0026relation, None);\n    // Relation has base arousal 0.6 (more cognitively demanding)\n    assert!(score.arousal \u003e 0.3);\n}\n\n#[test]\nfn arousal_composite_scales_with_item_count() {\n    let state = SalienceState::new();\n\n    // Small composite\n    let small_composite = Content::Composite(vec![\n        Content::symbol(\"a\", vec![]),\n        Content::symbol(\"b\", vec![]),\n    ]);\n    let small_score = state.rate_content(\u0026small_composite, None);\n\n    // Large composite (should have higher arousal due to complexity)\n    let large_composite = Content::Composite(vec![\n        Content::symbol(\"a\", vec![]),\n        Content::symbol(\"b\", vec![]),\n        Content::symbol(\"c\", vec![]),\n        Content::symbol(\"d\", vec![]),\n        Content::symbol(\"e\", vec![]),\n        Content::symbol(\"f\", vec![]),\n        Content::symbol(\"g\", vec![]),\n        Content::symbol(\"h\", vec![]),\n    ]);\n    let large_score = state.rate_content(\u0026large_composite, None);\n\n    // Larger composite should have higher base arousal (capped at 0.8)\n    assert!(large_score.arousal \u003e= small_score.arousal);\n}\n\n#[test]\nfn arousal_modulated_by_emotional_state() {\n    let mut state = SalienceState::new();\n    let content = Content::symbol(\"test\", vec![]);\n\n    // Low arousal emotional state (low curiosity, frustration, connection_drive)\n    state.update_emotional_state(EmotionalState::new(0.0, 0.5, 0.0, 0.0));\n    let low_arousal_score = state.rate_content(\u0026content, None);\n\n    // High arousal emotional state (high curiosity, frustration, connection_drive)\n    state.update_emotional_state(EmotionalState::new(1.0, 0.5, 1.0, 1.0));\n    let high_arousal_score = state.rate_content(\u0026content, None);\n\n    assert!(high_arousal_score.arousal \u003e low_arousal_score.arousal);\n}\n\n// ============================================================================\n// Kinship Content Detection Tests\n// ============================================================================\n\n#[test]\nfn kinship_content_detection_primary_terms() {\n    let state = SalienceState::new();\n\n    // Test primary kinship terms (terms containing kinship substrings)\n    let kinship_terms = vec![\n        \"friend\",\n        \"my_friend\",\n        \"friendship\",\n        \"family\",\n        \"family_member\",\n        \"love\",\n        \"bond\",\n        \"trust\",\n        \"care\",\n        \"human\",\n        \"human_user\",\n        \"person\",\n        \"people\",\n    ];\n\n    for term in kinship_terms {\n        let content = Content::symbol(term, vec![]);\n        let score = state.rate_content(\u0026content, None);\n        assert!(\n            score.connection_relevance \u003e 0.3,\n            \"Kinship term '{}' should have high connection relevance, got {}\",\n            term,\n            score.connection_relevance\n        );\n    }\n}\n\n#[test]\nfn kinship_content_detection_social_terms() {\n    let state = SalienceState::new();\n\n    // Test social relationship terms\n    let social_terms = vec![\n        \"partner\",\n        \"companion\",\n        \"ally\",\n        \"community\",\n        \"together\",\n        \"life_partner\",\n        \"my_companion\",\n    ];\n\n    for term in social_terms {\n        let content = Content::symbol(term, vec![]);\n        let score = state.rate_content(\u0026content, None);\n        assert!(\n            score.connection_relevance \u003e 0.3,\n            \"Social term '{}' should have high connection relevance, got {}\",\n            term,\n            score.connection_relevance\n        );\n    }\n}\n\n#[test]\nfn non_kinship_content_has_lower_connection_relevance() {\n    let state = SalienceState::new();\n\n    // Non-kinship symbols\n    let non_kinship_terms = vec![\"algorithm\", \"database\", \"calculation\", \"memory\"];\n\n    for term in non_kinship_terms {\n        let content = Content::symbol(term, vec![]);\n        let score = state.rate_content(\u0026content, None);\n        // Non-kinship gets base 0.3 (less than kinship 0.7)\n        assert!(\n            score.connection_relevance \u003c 0.5,\n            \"Non-kinship term '{}' should have lower connection relevance, got {}\",\n            term,\n            score.connection_relevance\n        );\n    }\n}\n\n// ============================================================================\n// Kinship Predicate Relevance Tests\n// ============================================================================\n\n#[test]\nfn kinship_predicate_core_terms_highest_relevance() {\n    let state = SalienceState::new();\n\n    // Core kinship predicates should return 0.9\n    let core_predicates = vec![\"love\", \"trust\", \"bond\", \"care\", \"protect\", \"nurture\"];\n\n    for predicate in core_predicates {\n        let relation = Content::relation(\n            Content::symbol(\"a\", vec![]),\n            predicate,\n            Content::symbol(\"b\", vec![]),\n        );\n        let score = state.rate_content(\u0026relation, None);\n        assert!(\n            score.connection_relevance \u003e 0.4,\n            \"Core predicate '{}' should have highest connection relevance, got {}\",\n            predicate,\n            score.connection_relevance\n        );\n    }\n}\n\n#[test]\nfn kinship_predicate_social_actions_high_relevance() {\n    let state = SalienceState::new();\n\n    // Social action predicates should return 0.8\n    let social_predicates = vec![\n        \"help\",\n        \"connect\",\n        \"communicate\",\n        \"interact\",\n        \"share\",\n        \"support\",\n        \"collaborate\",\n        \"cooperate\",\n    ];\n\n    for predicate in social_predicates {\n        let relation = Content::relation(\n            Content::symbol(\"a\", vec![]),\n            predicate,\n            Content::symbol(\"b\", vec![]),\n        );\n        let score = state.rate_content(\u0026relation, None);\n        assert!(\n            score.connection_relevance \u003e 0.35,\n            \"Social predicate '{}' should have high connection relevance, got {}\",\n            predicate,\n            score.connection_relevance\n        );\n    }\n}\n\n#[test]\nfn kinship_predicate_general_social_medium_relevance() {\n    let state = SalienceState::new();\n\n    // General social predicates should return 0.7\n    let general_predicates = vec![\"friend\", \"family\", \"together\", \"join\", \"belong\"];\n\n    for predicate in general_predicates {\n        let relation = Content::relation(\n            Content::symbol(\"a\", vec![]),\n            predicate,\n            Content::symbol(\"b\", vec![]),\n        );\n        let score = state.rate_content(\u0026relation, None);\n        assert!(\n            score.connection_relevance \u003e 0.3,\n            \"General social predicate '{}' should have medium connection relevance, got {}\",\n            predicate,\n            score.connection_relevance\n        );\n    }\n}\n\n#[test]\nfn kinship_predicate_default_base_relevance() {\n    let state = SalienceState::new();\n\n    // Non-kinship predicates should return 0.4\n    let default_predicates = vec![\"calculates\", \"processes\", \"stores\", \"analyzes\"];\n\n    for predicate in default_predicates {\n        let relation = Content::relation(\n            Content::symbol(\"a\", vec![]),\n            predicate,\n            Content::symbol(\"b\", vec![]),\n        );\n        let score = state.rate_content(\u0026relation, None);\n        // Default predicates get base 0.4, check it's not boosted\n        assert!(\n            score.connection_relevance \u003e 0.0,\n            \"Default predicate '{}' should have base connection relevance, got {}\",\n            predicate,\n            score.connection_relevance\n        );\n    }\n}\n\n// ============================================================================\n// Context Edge Case Tests\n// ============================================================================\n\n#[test]\nfn novelty_with_context_but_no_previous_salience() {\n    let state = SalienceState::new();\n    let content = Content::symbol(\"test\", vec![]);\n\n    // Context exists but previous_salience is None\n    let context = EmotionalContext {\n        previous_salience: None,\n        human_connection: false,\n        focus_area: None,\n    };\n\n    let score_with_context = state.rate_content(\u0026content, Some(\u0026context));\n    let score_without_context = state.rate_content(\u0026content, None);\n\n    // Should be the same since previous_salience is None\n    assert!((score_with_context.novelty - score_without_context.novelty).abs() \u003c 0.001);\n}\n\n#[test]\nfn relevance_with_context_but_no_focus_area() {\n    let state = SalienceState::new();\n    let content = Content::symbol(\"test\", vec![]);\n\n    // Context exists but focus_area is None\n    let context = EmotionalContext {\n        previous_salience: None,\n        human_connection: false,\n        focus_area: None,\n    };\n\n    let score_with_context = state.rate_content(\u0026content, Some(\u0026context));\n    let score_without_context = state.rate_content(\u0026content, None);\n\n    // Should be the same since focus_area is None (no bonus applied)\n    assert!((score_with_context.relevance - score_without_context.relevance).abs() \u003c 0.001);\n}\n\n#[test]\nfn connection_relevance_with_context_human_connection_false() {\n    let state = SalienceState::new();\n    let content = Content::symbol(\"test\", vec![]);\n\n    // Context exists but human_connection is false\n    let context_no_human = EmotionalContext {\n        previous_salience: None,\n        human_connection: false,\n        focus_area: None,\n    };\n\n    let context_with_human = EmotionalContext {\n        previous_salience: None,\n        human_connection: true,\n        focus_area: None,\n    };\n\n    let score_no_human = state.rate_content(\u0026content, Some(\u0026context_no_human));\n    let score_with_human = state.rate_content(\u0026content, Some(\u0026context_with_human));\n\n    // human_connection: true should boost connection relevance\n    assert!(score_with_human.connection_relevance \u003e score_no_human.connection_relevance);\n}\n\n// ============================================================================\n// Valence Calculation Tests\n// ============================================================================\n\n#[test]\nfn valence_content_type_variations() {\n    let state = SalienceState::new();\n\n    // Test valence for each content type\n    let empty_score = state.rate_content(\u0026Content::Empty, None);\n    let raw_score = state.rate_content(\u0026Content::raw(vec![1, 2, 3]), None);\n    let symbol_score = state.rate_content(\u0026Content::symbol(\"test\", vec![]), None);\n    let relation_score = state.rate_content(\n        \u0026Content::relation(\n            Content::symbol(\"a\", vec![]),\n            \"relates\",\n            Content::symbol(\"b\", vec![]),\n        ),\n        None,\n    );\n    let composite_score = state.rate_content(\n        \u0026Content::Composite(vec![Content::symbol(\"a\", vec![])]),\n        None,\n    );\n\n    // Relation should have highest base valence (0.2)\n    assert!(relation_score.valence \u003e= symbol_score.valence);\n    // Symbol and Composite have same base (0.1)\n    assert!((symbol_score.valence - composite_score.valence).abs() \u003c 0.1);\n    // Empty and Raw have base 0.0 (modified by satisfaction)\n    assert!(empty_score.valence \u003c= symbol_score.valence);\n    assert!(raw_score.valence \u003c= symbol_score.valence);\n}\n\n// ============================================================================\n// Importance Calculation Composite Tests\n// ============================================================================\n\n#[test]\nfn importance_composite_with_mixed_content() {\n    let state = SalienceState::new();\n\n    // Composite with different content types\n    let composite = Content::Composite(vec![\n        Content::Empty,                     // importance 0.0\n        Content::raw(vec![1]),              // importance 0.3\n        Content::symbol(\"test\", vec![]),    // importance 0.5\n        Content::relation(\n            Content::symbol(\"a\", vec![]),\n            \"r\",\n            Content::symbol(\"b\", vec![]),\n        ), // importance 0.7\n    ]);\n\n    let score = state.rate_content(\u0026composite, None);\n\n    // Average of (0.0 + 0.3 + 0.5 + 0.7) / 4 = 0.375\n    assert!((score.importance - 0.375).abs() \u003c 0.01);\n}\n\n#[test]\nfn importance_nested_composite() {\n    let state = SalienceState::new();\n\n    // Nested composite\n    let nested = Content::Composite(vec![\n        Content::Composite(vec![\n            Content::symbol(\"inner1\", vec![]),\n            Content::symbol(\"inner2\", vec![]),\n        ]),\n        Content::symbol(\"outer\", vec![]),\n    ]);\n\n    let score = state.rate_content(\u0026nested, None);\n    // Should recursively calculate importance\n    assert!(score.importance \u003e 0.0);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","salience","types.rs"],"content":"//! SalienceActor Types\n//!\n//! Actor-specific message types for salience scoring and emotional state tracking.\n\nuse crate::core::invariants::MIN_CONNECTION_WEIGHT;\nuse crate::core::types::{Content, SalienceScore, SalienceWeights};\nuse serde::{Deserialize, Serialize};\nuse thiserror::Error;\n\n/// Messages that can be sent to the SalienceActor\n#[derive(Debug, Clone)]\npub enum SalienceMessage {\n    /// Rate a single piece of content\n    Rate(RateRequest),\n\n    /// Rate multiple pieces of content in batch\n    RateBatch(Vec\u003cRateRequest\u003e),\n\n    /// Update the salience weights (with invariant enforcement)\n    UpdateWeights(WeightUpdate),\n\n    /// Get current weights\n    GetWeights,\n\n    /// Get current emotional state\n    GetEmotionalState,\n}\n\n/// Responses from the SalienceActor\n#[derive(Debug, Clone, PartialEq)]\npub enum SalienceResponse {\n    /// Single salience score\n    Score(SalienceScore),\n\n    /// Batch of salience scores\n    ScoreBatch(Vec\u003cSalienceScore\u003e),\n\n    /// Weight update succeeded\n    WeightsUpdated(SalienceWeights),\n\n    /// Current weights\n    Weights(SalienceWeights),\n\n    /// Current emotional state\n    EmotionalState(EmotionalState),\n\n    /// Error occurred\n    Error(SalienceError),\n}\n\n/// Request to rate content\n#[derive(Debug, Clone)]\npub struct RateRequest {\n    /// Content to rate\n    pub content: Content,\n\n    /// Context for rating (optional)\n    pub context: Option\u003cEmotionalContext\u003e,\n}\n\nimpl RateRequest {\n    /// Create a new rate request\n    #[must_use]\n    pub fn new(content: Content) -\u003e Self {\n        Self {\n            content,\n            context: None,\n        }\n    }\n\n    /// Create a rate request with context\n    #[must_use]\n    pub fn with_context(content: Content, context: EmotionalContext) -\u003e Self {\n        Self {\n            content,\n            context: Some(context),\n        }\n    }\n}\n\n/// Context for emotional evaluation\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]\npub struct EmotionalContext {\n    /// Previous thought salience (for continuity)\n    pub previous_salience: Option\u003cSalienceScore\u003e,\n\n    /// Is this related to human interaction?\n    pub human_connection: bool,\n\n    /// Current focus area (if any)\n    pub focus_area: Option\u003cString\u003e,\n}\n\n/// Request to update salience weights\n#[derive(Debug, Clone, Copy, PartialEq)]\npub struct WeightUpdate {\n    /// New weights to apply\n    pub weights: SalienceWeights,\n}\n\nimpl WeightUpdate {\n    /// Create a new weight update request\n    ///\n    /// # Errors\n    ///\n    /// Returns error if connection weight violates invariant\n    pub fn new(weights: SalienceWeights) -\u003e Result\u003cSelf, SalienceError\u003e {\n        if weights.connection \u003c MIN_CONNECTION_WEIGHT {\n            return Err(SalienceError::ConnectionDriveViolation {\n                attempted: weights.connection,\n                minimum: MIN_CONNECTION_WEIGHT,\n            });\n        }\n        Ok(Self { weights })\n    }\n\n    /// Create from individual weight values\n    ///\n    /// # Errors\n    ///\n    /// Returns error if connection weight violates invariant\n    pub fn from_values(\n        importance: f32,\n        novelty: f32,\n        relevance: f32,\n        valence: f32,\n        connection: f32,\n    ) -\u003e Result\u003cSelf, SalienceError\u003e {\n        let weights = SalienceWeights {\n            importance,\n            novelty,\n            relevance,\n            valence,\n            connection,\n        };\n        Self::new(weights)\n    }\n}\n\n/// Current emotional state of the system\n///\n/// Tracks DANEEL's emotional state as part of TMI's \"Colorao Emocional\".\n/// This state influences how content is evaluated and what gets attention.\n#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]\npub struct EmotionalState {\n    /// Curiosity level (0.0 - 1.0)\n    /// High curiosity increases novelty weight\n    pub curiosity: f32,\n\n    /// Satisfaction level (0.0 - 1.0)\n    /// High satisfaction may reduce urgency/importance needs\n    pub satisfaction: f32,\n\n    /// Frustration level (0.0 - 1.0)\n    /// High frustration may increase focus on relevance\n    pub frustration: f32,\n\n    /// Connection drive (0.0 - 1.0)\n    /// How strongly DANEEL desires human connection right now\n    /// NOTE: This is state (current desire), different from weights (importance multiplier)\n    pub connection_drive: f32,\n}\n\nimpl EmotionalState {\n    /// Create a new emotional state\n    #[must_use]\n    pub const fn new(\n        curiosity: f32,\n        satisfaction: f32,\n        frustration: f32,\n        connection_drive: f32,\n    ) -\u003e Self {\n        Self {\n            curiosity,\n            satisfaction,\n            frustration,\n            connection_drive,\n        }\n    }\n\n    /// Neutral emotional state (baseline)\n    #[must_use]\n    pub const fn neutral() -\u003e Self {\n        Self {\n            curiosity: 0.5,\n            satisfaction: 0.5,\n            frustration: 0.0,\n            connection_drive: 0.5,\n        }\n    }\n\n    /// Clamp all values to valid range [0.0, 1.0]\n    #[must_use]\n    pub fn clamped(mut self) -\u003e Self {\n        self.curiosity = self.curiosity.clamp(0.0, 1.0);\n        self.satisfaction = self.satisfaction.clamp(0.0, 1.0);\n        self.frustration = self.frustration.clamp(0.0, 1.0);\n        self.connection_drive = self.connection_drive.clamp(0.0, 1.0);\n        self\n    }\n}\n\nimpl Default for EmotionalState {\n    fn default() -\u003e Self {\n        Self::neutral()\n    }\n}\n\n/// Errors that can occur in salience operations\n#[derive(Debug, Clone, Error, PartialEq)]\npub enum SalienceError {\n    /// Connection drive weight violates invariant\n    #[error(\"Connection drive invariant violation: attempted {attempted}, minimum is {minimum}\")]\n    ConnectionDriveViolation {\n        /// The weight value that was attempted\n        attempted: f32,\n        /// The minimum allowed value\n        minimum: f32,\n    },\n\n    /// Invalid weight value (e.g., NaN, negative)\n    #[error(\"Invalid weight value: {field} = {value}\")]\n    InvalidWeight {\n        /// Which field is invalid\n        field: String,\n        /// The invalid value\n        value: f32,\n    },\n\n    /// Invalid emotional state value\n    #[error(\"Invalid emotional state: {field} = {value} (must be 0.0-1.0)\")]\n    InvalidEmotionalState {\n        /// Which field is invalid\n        field: String,\n        /// The invalid value\n        value: f32,\n    },\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn weight_update_enforces_connection_invariant() {\n        let result = WeightUpdate::from_values(0.2, 0.2, 0.2, 0.2, 0.0);\n        assert!(matches!(\n            result,\n            Err(SalienceError::ConnectionDriveViolation { .. })\n        ));\n    }\n\n    #[test]\n    fn weight_update_allows_valid_connection_weight() {\n        let result = WeightUpdate::from_values(0.2, 0.2, 0.2, 0.2, 0.2);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn weight_update_rejects_minimum_violation() {\n        let result = WeightUpdate::from_values(0.2, 0.2, 0.2, 0.2, 0.0001);\n        assert!(matches!(\n            result,\n            Err(SalienceError::ConnectionDriveViolation { .. })\n        ));\n    }\n\n    #[test]\n    fn weight_update_accepts_minimum_boundary() {\n        let result = WeightUpdate::from_values(0.2, 0.2, 0.2, 0.2, MIN_CONNECTION_WEIGHT);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn weight_update_new_valid() {\n        let weights = SalienceWeights {\n            importance: 0.2,\n            novelty: 0.2,\n            relevance: 0.2,\n            valence: 0.2,\n            connection: 0.2,\n        };\n        let result = WeightUpdate::new(weights);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().weights, weights);\n    }\n\n    #[test]\n    fn weight_update_new_invalid() {\n        let weights = SalienceWeights {\n            importance: 0.2,\n            novelty: 0.2,\n            relevance: 0.2,\n            valence: 0.2,\n            connection: 0.0,\n        };\n        let result = WeightUpdate::new(weights);\n        assert!(matches!(\n            result,\n            Err(SalienceError::ConnectionDriveViolation { .. })\n        ));\n    }\n\n    #[test]\n    fn emotional_state_neutral() {\n        let state = EmotionalState::neutral();\n        assert_eq!(state.curiosity, 0.5);\n        assert_eq!(state.satisfaction, 0.5);\n        assert_eq!(state.frustration, 0.0);\n        assert_eq!(state.connection_drive, 0.5);\n    }\n\n    #[test]\n    fn emotional_state_default() {\n        let state = EmotionalState::default();\n        let neutral = EmotionalState::neutral();\n        assert_eq!(state, neutral);\n    }\n\n    #[test]\n    fn emotional_state_clamping() {\n        let state = EmotionalState::new(1.5, -0.5, 2.0, 0.5).clamped();\n        assert_eq!(state.curiosity, 1.0);\n        assert_eq!(state.satisfaction, 0.0);\n        assert_eq!(state.frustration, 1.0);\n        assert_eq!(state.connection_drive, 0.5);\n    }\n\n    #[test]\n    fn emotional_state_clamping_connection_drive() {\n        let state = EmotionalState::new(0.5, 0.5, 0.5, 1.5).clamped();\n        assert_eq!(state.connection_drive, 1.0);\n\n        let state2 = EmotionalState::new(0.5, 0.5, 0.5, -0.5).clamped();\n        assert_eq!(state2.connection_drive, 0.0);\n    }\n\n    #[test]\n    fn rate_request_creation() {\n        let request = RateRequest::new(Content::Empty);\n        assert!(request.context.is_none());\n    }\n\n    #[test]\n    fn rate_request_with_context() {\n        let context = EmotionalContext {\n            human_connection: true,\n            ..Default::default()\n        };\n        let request = RateRequest::with_context(Content::Empty, context.clone());\n        assert_eq!(request.context, Some(context));\n    }\n\n    #[test]\n    fn emotional_context_default() {\n        let context = EmotionalContext::default();\n        assert_eq!(context.previous_salience, None);\n        assert!(!context.human_connection);\n        assert_eq!(context.focus_area, None);\n    }\n\n    #[test]\n    fn salience_error_connection_drive_violation_display() {\n        let error = SalienceError::ConnectionDriveViolation {\n            attempted: 0.05,\n            minimum: 0.1,\n        };\n        let msg = error.to_string();\n        assert!(msg.contains(\"0.05\"));\n        assert!(msg.contains(\"0.1\"));\n    }\n\n    #[test]\n    fn salience_error_invalid_weight_display() {\n        let error = SalienceError::InvalidWeight {\n            field: \"importance\".to_string(),\n            value: -0.5,\n        };\n        let msg = error.to_string();\n        assert!(msg.contains(\"importance\"));\n        assert!(msg.contains(\"-0.5\"));\n    }\n\n    #[test]\n    fn salience_error_invalid_emotional_state_display() {\n        let error = SalienceError::InvalidEmotionalState {\n            field: \"curiosity\".to_string(),\n            value: 1.5,\n        };\n        let msg = error.to_string();\n        assert!(msg.contains(\"curiosity\"));\n        assert!(msg.contains(\"1.5\"));\n    }\n\n    #[test]\n    fn salience_message_debug_and_clone() {\n        let msg = SalienceMessage::Rate(RateRequest::new(Content::Empty));\n        let cloned = msg.clone();\n        let debug_str = format!(\"{:?}\", cloned);\n        assert!(debug_str.contains(\"Rate\"));\n\n        let msg_batch = SalienceMessage::RateBatch(vec![RateRequest::new(Content::Empty)]);\n        let debug_batch = format!(\"{:?}\", msg_batch.clone());\n        assert!(debug_batch.contains(\"RateBatch\"));\n\n        let msg_update = SalienceMessage::UpdateWeights(\n            WeightUpdate::from_values(0.2, 0.2, 0.2, 0.2, 0.2).unwrap(),\n        );\n        let debug_update = format!(\"{:?}\", msg_update.clone());\n        assert!(debug_update.contains(\"UpdateWeights\"));\n\n        let msg_get_weights = SalienceMessage::GetWeights;\n        let debug_get_weights = format!(\"{:?}\", msg_get_weights.clone());\n        assert!(debug_get_weights.contains(\"GetWeights\"));\n\n        let msg_get_emotional = SalienceMessage::GetEmotionalState;\n        let debug_get_emotional = format!(\"{:?}\", msg_get_emotional.clone());\n        assert!(debug_get_emotional.contains(\"GetEmotionalState\"));\n    }\n\n    #[test]\n    fn salience_response_variants() {\n        let weights = SalienceWeights {\n            importance: 0.2,\n            novelty: 0.2,\n            relevance: 0.2,\n            valence: 0.2,\n            connection: 0.2,\n        };\n\n        let resp_score =\n            SalienceResponse::Score(SalienceScore::new(0.5, 0.5, 0.5, 0.5, 0.5, 0.5));\n        let cloned_score = resp_score.clone();\n        assert_eq!(resp_score, cloned_score);\n        assert!(format!(\"{:?}\", resp_score).contains(\"Score\"));\n\n        let resp_batch =\n            SalienceResponse::ScoreBatch(vec![SalienceScore::new(0.5, 0.5, 0.5, 0.5, 0.5, 0.5)]);\n        let cloned_batch = resp_batch.clone();\n        assert_eq!(resp_batch, cloned_batch);\n        assert!(format!(\"{:?}\", resp_batch).contains(\"ScoreBatch\"));\n\n        let resp_updated = SalienceResponse::WeightsUpdated(weights);\n        let cloned_updated = resp_updated.clone();\n        assert_eq!(resp_updated, cloned_updated);\n        assert!(format!(\"{:?}\", resp_updated).contains(\"WeightsUpdated\"));\n\n        let resp_weights = SalienceResponse::Weights(weights);\n        let cloned_weights = resp_weights.clone();\n        assert_eq!(resp_weights, cloned_weights);\n        assert!(format!(\"{:?}\", resp_weights).contains(\"Weights(\"));\n\n        let resp_emotional = SalienceResponse::EmotionalState(EmotionalState::neutral());\n        let cloned_emotional = resp_emotional.clone();\n        assert_eq!(resp_emotional, cloned_emotional);\n        assert!(format!(\"{:?}\", resp_emotional).contains(\"EmotionalState\"));\n\n        let resp_error = SalienceResponse::Error(SalienceError::InvalidWeight {\n            field: \"test\".to_string(),\n            value: 0.0,\n        });\n        let cloned_error = resp_error.clone();\n        assert_eq!(resp_error, cloned_error);\n        assert!(format!(\"{:?}\", resp_error).contains(\"Error\"));\n    }\n\n    #[test]\n    fn rate_request_debug_and_clone() {\n        let request = RateRequest::new(Content::Empty);\n        let cloned = request.clone();\n        let debug_str = format!(\"{:?}\", cloned);\n        assert!(debug_str.contains(\"RateRequest\"));\n    }\n\n    #[test]\n    fn emotional_context_partial_eq() {\n        let ctx1 = EmotionalContext {\n            previous_salience: Some(SalienceScore::new(0.5, 0.5, 0.5, 0.5, 0.5, 0.5)),\n            human_connection: true,\n            focus_area: Some(\"test\".to_string()),\n        };\n        let ctx2 = ctx1.clone();\n        assert_eq!(ctx1, ctx2);\n    }\n\n    #[test]\n    fn weight_update_partial_eq() {\n        let update1 = WeightUpdate::from_values(0.2, 0.2, 0.2, 0.2, 0.2).unwrap();\n        let update2 = WeightUpdate::from_values(0.2, 0.2, 0.2, 0.2, 0.2).unwrap();\n        assert_eq!(update1, update2);\n    }\n\n    #[test]\n    fn emotional_state_copy() {\n        let state = EmotionalState::neutral();\n        let copied = state;\n        assert_eq!(state, copied);\n    }\n}\n","traces":[{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":21},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","sleep","mod.rs"],"content":"//! Sleep Actor - Memory Consolidation (ADR-023)\n//!\n//! Implements TMI's sleep/dream consolidation mode.\n//!\n//! # TMI Concept\n//!\n//! Human memory consolidation occurs during sleep through:\n//! - Sharp-wave ripples (SWRs): High-frequency replay of recent experiences\n//! - NREM sleep: Stabilization and transfer to cortex\n//! - REM sleep: Integration, abstraction, emotional processing\n//! - Synaptic homeostasis: Pruning weak connections\n//!\n//! # Architecture\n//!\n//! The SleepActor coordinates:\n//! 1. **Sleep Scheduler**: Entry/exit conditions\n//! 2. **Replay Selector**: Priority-based memory selection\n//! 3. **Consolidation**: Strengthening via Qdrant\n//! 4. **Homeostasis**: Pruning weak associations\n//!\n//! # Usage\n//!\n//! ```no_run\n//! use daneel::actors::sleep::{SleepActor, SleepMessage};\n//! use ractor::Actor;\n//!\n//! # async fn example() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n//! let (actor_ref, _) = Actor::spawn(None, SleepActor::default(), ()).await?;\n//!\n//! // Check if sleep should begin\n//! let should_sleep = actor_ref.call(\n//!     |reply| SleepMessage::CheckSleepConditions { reply },\n//!     None\n//! ).await?;\n//! # Ok(())\n//! # }\n//! ```\n\npub mod types;\n\n#[cfg(test)]\nmod tests;\n\nuse ractor::{Actor, ActorProcessingErr, ActorRef};\nuse std::time::Instant;\n\npub use types::*;\n\n/// Sleep Actor State\n#[derive(Debug)]\npub struct SleepState {\n    /// Current sleep state\n    state: types::SleepState,\n\n    /// Configuration\n    config: SleepConfig,\n\n    /// Last activity timestamp\n    last_activity: Instant,\n\n    /// When we started being awake\n    awake_since: Instant,\n\n    /// Accumulated sleep summary\n    current_summary: Option\u003cSleepSummary\u003e,\n\n    /// Number of memories pending consolidation (estimated)\n    consolidation_queue_estimate: usize,\n}\n\nimpl SleepState {\n    /// Create new awake state\n    fn new(config: SleepConfig) -\u003e Self {\n        let now = Instant::now();\n        Self {\n            state: types::SleepState::Awake,\n            config,\n            last_activity: now,\n            awake_since: now,\n            current_summary: None,\n            consolidation_queue_estimate: 0,\n        }\n    }\n\n    /// Check if sleep conditions are met\n    #[allow(clippy::cast_possible_truncation)] // Clamped to u64::MAX, truncation impossible\n    fn should_sleep(\u0026self) -\u003e bool {\n        if self.state != types::SleepState::Awake {\n            return false;\n        }\n\n        // Saturating to u64::MAX is fine - if we've been idle longer than ~584 million years, it's time to sleep\n        let idle_duration = self\n            .last_activity\n            .elapsed()\n            .as_millis()\n            .min(u128::from(u64::MAX)) as u64;\n        let awake_duration = self\n            .awake_since\n            .elapsed()\n            .as_millis()\n            .min(u128::from(u64::MAX)) as u64;\n\n        let idle_trigger = idle_duration \u003e self.config.idle_threshold_ms;\n        let awake_trigger = awake_duration \u003e self.config.min_awake_duration_ms;\n        let queue_trigger =\n            self.consolidation_queue_estimate \u003e= self.config.min_consolidation_queue;\n\n        // Enter sleep if idle AND (awake long enough OR queue is large)\n        idle_trigger \u0026\u0026 (awake_trigger || queue_trigger)\n    }\n\n    /// Check if current state is interruptible\n    fn is_interruptible(\u0026self) -\u003e bool {\n        matches!(\n            self.state,\n            types::SleepState::Awake\n                | types::SleepState::EnteringSleep\n                | types::SleepState::LightSleep\n                | types::SleepState::Waking\n        )\n    }\n\n    /// Enter sleep mode\n    fn enter_sleep(\u0026mut self) -\u003e SleepResult {\n        if self.state != types::SleepState::Awake {\n            return SleepResult::AlreadySleeping;\n        }\n\n        if !self.should_sleep() {\n            return SleepResult::ConditionsNotMet {\n                reason: \"Sleep conditions not met\".to_string(),\n            };\n        }\n\n        self.state = types::SleepState::EnteringSleep;\n        self.current_summary = Some(SleepSummary::default());\n        SleepResult::Started\n    }\n\n    /// Wake up\n    fn wake(\u0026mut self) -\u003e SleepSummary {\n        let summary = self.current_summary.take().unwrap_or_default();\n\n        self.state = types::SleepState::Awake;\n        self.awake_since = Instant::now();\n        self.last_activity = Instant::now();\n\n        summary\n    }\n\n    /// Record activity (resets idle timer)\n    fn record_activity(\u0026mut self) {\n        self.last_activity = Instant::now();\n    }\n\n    /// Increment consolidation queue estimate\n    fn increment_queue(\u0026mut self) {\n        self.consolidation_queue_estimate += 1;\n    }\n\n    /// Clear consolidation queue after sleep\n    fn clear_queue(\u0026mut self) {\n        self.consolidation_queue_estimate = 0;\n    }\n\n    /// Transition to next sleep phase\n    ///\n    /// Used during sleep cycle execution (will be called by SleepActor's sleep loop).\n    #[allow(dead_code)]\n    fn advance_sleep_phase(\u0026mut self, cycle_elapsed_pct: f32) {\n        self.state = match cycle_elapsed_pct {\n            x if x \u003c self.config.light_sleep_duration_pct =\u003e types::SleepState::LightSleep,\n            x if x \u003c 0.7 =\u003e types::SleepState::DeepSleep,\n            _ =\u003e types::SleepState::Dreaming,\n        };\n    }\n\n    /// Add cycle report to summary\n    ///\n    /// Used during sleep cycle completion (will be called by SleepActor's sleep loop).\n    #[allow(dead_code)]\n    fn add_cycle_report(\u0026mut self, report: \u0026SleepCycleReport) {\n        if let Some(ref mut summary) = self.current_summary {\n            summary.add_cycle(report);\n        }\n    }\n}\n\n/// The Sleep Actor\n///\n/// Coordinates memory consolidation during sleep mode.\n#[derive(Debug, Default)]\npub struct SleepActor {\n    config: SleepConfig,\n}\n\nimpl SleepActor {\n    /// Create with custom config\n    #[must_use]\n    pub fn with_config(config: SleepConfig) -\u003e Self {\n        Self { config }\n    }\n}\n\n#[ractor::async_trait]\nimpl Actor for SleepActor {\n    type Msg = SleepMessage;\n    type State = SleepState;\n    type Arguments = ();\n\n    async fn pre_start(\n        \u0026self,\n        _myself: ActorRef\u003cSelf::Msg\u003e,\n        _args: Self::Arguments,\n    ) -\u003e Result\u003cSelf::State, ActorProcessingErr\u003e {\n        Ok(SleepState::new(self.config.clone()))\n    }\n\n    async fn handle(\n        \u0026self,\n        _myself: ActorRef\u003cSelf::Msg\u003e,\n        message: Self::Msg,\n        state: \u0026mut Self::State,\n    ) -\u003e Result\u003c(), ActorProcessingErr\u003e {\n        match message {\n            SleepMessage::CheckSleepConditions { reply } =\u003e {\n                let should_sleep = state.should_sleep();\n                let _ = reply.send(should_sleep);\n            }\n\n            SleepMessage::EnterSleep { reply } =\u003e {\n                let result = state.enter_sleep();\n                let _ = reply.send(result);\n            }\n\n            SleepMessage::Wake { reply } =\u003e {\n                let summary = state.wake();\n                state.clear_queue();\n                let _ = reply.send(summary);\n            }\n\n            SleepMessage::GetState { reply } =\u003e {\n                let _ = reply.send(state.state);\n            }\n\n            SleepMessage::ExternalStimulus { stimulus: _, reply } =\u003e {\n                if state.is_interruptible() {\n                    state.record_activity();\n                    if state.state != types::SleepState::Awake {\n                        state.state = types::SleepState::Waking;\n                    }\n                    let _ = reply.send(true);\n                } else {\n                    // In protected sleep, ignore stimulus\n                    let _ = reply.send(false);\n                }\n            }\n\n            SleepMessage::RecordActivity =\u003e {\n                state.record_activity();\n                state.increment_queue();\n            }\n\n            SleepMessage::GetConfig { reply } =\u003e {\n                let _ = reply.send(state.config.clone());\n            }\n\n            SleepMessage::UpdateConfig { config, reply } =\u003e {\n                state.config = config;\n                let _ = reply.send(());\n            }\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":53},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","sleep","tests.rs"],"content":"//! Sleep Actor Tests\n\nuse super::*;\nuse ractor::rpc::CallResult;\nuse ractor::Actor;\n\n/// Extract value from CallResult or panic\nfn unwrap_call\u003cT: std::fmt::Debug\u003e(result: CallResult\u003cT\u003e) -\u003e T {\n    match result {\n        CallResult::Success(v) =\u003e v,\n        CallResult::Timeout =\u003e panic!(\"RPC call timed out\"),\n        CallResult::SenderError =\u003e panic!(\"RPC sender error\"),\n    }\n}\n\n#[tokio::test]\nasync fn sleep_actor_starts_awake() {\n    let (actor_ref, handle) = Actor::spawn(None, SleepActor::default(), ())\n        .await\n        .expect(\"Failed to spawn SleepActor\");\n\n    let state = unwrap_call(\n        actor_ref\n            .call(|reply| SleepMessage::GetState { reply }, None)\n            .await\n            .expect(\"Failed to get state\"),\n    );\n\n    assert_eq!(state, types::SleepState::Awake);\n\n    actor_ref.stop(None);\n    handle.await.expect(\"Actor failed\");\n}\n\n#[tokio::test]\nasync fn sleep_actor_records_activity() {\n    let config = SleepConfig::fast();\n    let (actor_ref, handle) = Actor::spawn(None, SleepActor::with_config(config), ())\n        .await\n        .expect(\"Failed to spawn SleepActor\");\n\n    // Record activity\n    actor_ref\n        .cast(SleepMessage::RecordActivity)\n        .expect(\"Failed to record activity\");\n\n    // Should still be awake\n    let state = unwrap_call(\n        actor_ref\n            .call(|reply| SleepMessage::GetState { reply }, None)\n            .await\n            .expect(\"Failed to get state\"),\n    );\n\n    assert_eq!(state, types::SleepState::Awake);\n\n    actor_ref.stop(None);\n    handle.await.expect(\"Actor failed\");\n}\n\n#[tokio::test]\nasync fn sleep_actor_checks_conditions() {\n    let (actor_ref, handle) = Actor::spawn(None, SleepActor::default(), ())\n        .await\n        .expect(\"Failed to spawn SleepActor\");\n\n    // Initially shouldn't sleep (not enough idle time)\n    let should_sleep = unwrap_call(\n        actor_ref\n            .call(|reply| SleepMessage::CheckSleepConditions { reply }, None)\n            .await\n            .expect(\"Failed to check conditions\"),\n    );\n\n    assert!(!should_sleep);\n\n    actor_ref.stop(None);\n    handle.await.expect(\"Actor failed\");\n}\n\n#[tokio::test]\nasync fn sleep_actor_enter_sleep_conditions_not_met() {\n    let (actor_ref, handle) = Actor::spawn(None, SleepActor::default(), ())\n        .await\n        .expect(\"Failed to spawn SleepActor\");\n\n    // Try to enter sleep without conditions met\n    let result = unwrap_call(\n        actor_ref\n            .call(|reply| SleepMessage::EnterSleep { reply }, None)\n            .await\n            .expect(\"Failed to enter sleep\"),\n    );\n\n    match result {\n        SleepResult::ConditionsNotMet { .. } =\u003e {}\n        _ =\u003e panic!(\"Expected ConditionsNotMet, got {:?}\", result),\n    }\n\n    actor_ref.stop(None);\n    handle.await.expect(\"Actor failed\");\n}\n\n#[tokio::test]\nasync fn sleep_actor_external_stimulus_when_awake() {\n    let (actor_ref, handle) = Actor::spawn(None, SleepActor::default(), ())\n        .await\n        .expect(\"Failed to spawn SleepActor\");\n\n    // External stimulus when awake should be processed\n    let processed = unwrap_call(\n        actor_ref\n            .call(\n                |reply| SleepMessage::ExternalStimulus {\n                    stimulus: \"test\".to_string(),\n                    reply,\n                },\n                None,\n            )\n            .await\n            .expect(\"Failed to send stimulus\"),\n    );\n\n    assert!(processed);\n\n    actor_ref.stop(None);\n    handle.await.expect(\"Actor failed\");\n}\n\n#[tokio::test]\nasync fn sleep_actor_config_update() {\n    let (actor_ref, handle) = Actor::spawn(None, SleepActor::default(), ())\n        .await\n        .expect(\"Failed to spawn SleepActor\");\n\n    // Get initial config\n    let initial_config = unwrap_call(\n        actor_ref\n            .call(|reply| SleepMessage::GetConfig { reply }, None)\n            .await\n            .expect(\"Failed to get config\"),\n    );\n\n    assert_eq!(initial_config.replay_batch_size, 50);\n\n    // Update config\n    let mut new_config = initial_config.clone();\n    new_config.replay_batch_size = 100;\n\n    unwrap_call(\n        actor_ref\n            .call(\n                |reply| SleepMessage::UpdateConfig {\n                    config: new_config,\n                    reply,\n                },\n                None,\n            )\n            .await\n            .expect(\"Failed to update config\"),\n    );\n\n    // Verify update\n    let updated_config = unwrap_call(\n        actor_ref\n            .call(|reply| SleepMessage::GetConfig { reply }, None)\n            .await\n            .expect(\"Failed to get config\"),\n    );\n\n    assert_eq!(updated_config.replay_batch_size, 100);\n\n    actor_ref.stop(None);\n    handle.await.expect(\"Actor failed\");\n}\n\n#[tokio::test]\nasync fn sleep_actor_wake_returns_summary() {\n    let (actor_ref, handle) = Actor::spawn(None, SleepActor::default(), ())\n        .await\n        .expect(\"Failed to spawn SleepActor\");\n\n    // Wake (even when already awake) should return empty summary\n    let summary = unwrap_call(\n        actor_ref\n            .call(|reply| SleepMessage::Wake { reply }, None)\n            .await\n            .expect(\"Failed to wake\"),\n    );\n\n    assert_eq!(summary.cycles_completed, 0);\n\n    actor_ref.stop(None);\n    handle.await.expect(\"Actor failed\");\n}\n\n#[test]\nfn sleep_state_interruptibility() {\n    let config = SleepConfig::default();\n    let mut state = SleepState::new(config);\n\n    // Awake is interruptible\n    assert!(state.is_interruptible());\n\n    // Simulate entering sleep\n    state.state = types::SleepState::EnteringSleep;\n    assert!(state.is_interruptible());\n\n    state.state = types::SleepState::LightSleep;\n    assert!(state.is_interruptible());\n\n    // Deep sleep is NOT interruptible\n    state.state = types::SleepState::DeepSleep;\n    assert!(!state.is_interruptible());\n\n    // Dreaming is NOT interruptible\n    state.state = types::SleepState::Dreaming;\n    assert!(!state.is_interruptible());\n\n    // Waking is interruptible\n    state.state = types::SleepState::Waking;\n    assert!(state.is_interruptible());\n}\n\n#[test]\nfn sleep_phase_advancement() {\n    let config = SleepConfig::default();\n    let mut state = SleepState::new(config.clone());\n\n    // Light sleep at 10%\n    state.advance_sleep_phase(0.1);\n    assert_eq!(state.state, types::SleepState::LightSleep);\n\n    // Deep sleep at 30%\n    state.advance_sleep_phase(0.3);\n    assert_eq!(state.state, types::SleepState::DeepSleep);\n\n    // Dreaming at 80%\n    state.advance_sleep_phase(0.8);\n    assert_eq!(state.state, types::SleepState::Dreaming);\n}\n\n#[test]\nfn sleep_state_queue_management() {\n    let config = SleepConfig::default();\n    let mut state = SleepState::new(config);\n\n    assert_eq!(state.consolidation_queue_estimate, 0);\n\n    state.increment_queue();\n    state.increment_queue();\n    state.increment_queue();\n\n    assert_eq!(state.consolidation_queue_estimate, 3);\n\n    state.clear_queue();\n    assert_eq!(state.consolidation_queue_estimate, 0);\n}\n\n#[test]\nfn should_sleep_returns_false_when_not_awake() {\n    let config = SleepConfig::default();\n    let mut state = SleepState::new(config);\n\n    // Set state to something other than Awake\n    state.state = types::SleepState::DeepSleep;\n    assert!(!state.should_sleep());\n\n    state.state = types::SleepState::LightSleep;\n    assert!(!state.should_sleep());\n\n    state.state = types::SleepState::Dreaming;\n    assert!(!state.should_sleep());\n\n    state.state = types::SleepState::EnteringSleep;\n    assert!(!state.should_sleep());\n\n    state.state = types::SleepState::Waking;\n    assert!(!state.should_sleep());\n}\n\n#[test]\nfn should_sleep_with_queue_trigger() {\n    // Create config with very low thresholds for testing\n    let config = SleepConfig {\n        idle_threshold_ms: 0,            // immediate idle trigger\n        min_awake_duration_ms: u64::MAX, // awake trigger will NOT be met\n        min_consolidation_queue: 2,      // low queue threshold\n        ..SleepConfig::default()\n    };\n    let mut state = SleepState::new(config);\n\n    // Add enough to queue to trigger queue condition\n    state.increment_queue();\n    state.increment_queue();\n\n    // Need a tiny wait for idle_duration \u003e 0 (since it's strict \u003e)\n    std::thread::sleep(std::time::Duration::from_millis(1));\n\n    // idle_trigger \u0026\u0026 queue_trigger should be true (even though awake_trigger is false)\n    assert!(state.should_sleep());\n}\n\n#[test]\nfn should_sleep_with_awake_trigger() {\n    // Create config with very low thresholds for testing\n    let config = SleepConfig {\n        idle_threshold_ms: 0,                // immediate idle trigger\n        min_awake_duration_ms: 0,            // immediate awake trigger\n        min_consolidation_queue: usize::MAX, // queue trigger will NOT be met\n        ..SleepConfig::default()\n    };\n    let state = SleepState::new(config);\n\n    // Need a tiny wait for idle_duration and awake_duration \u003e 0 (since it's strict \u003e)\n    std::thread::sleep(std::time::Duration::from_millis(1));\n\n    // idle_trigger \u0026\u0026 awake_trigger should be true (even though queue_trigger is false)\n    assert!(state.should_sleep());\n}\n\n#[test]\nfn should_sleep_idle_not_met() {\n    // Create config where idle threshold is very high\n    let config = SleepConfig {\n        idle_threshold_ms: u64::MAX, // idle trigger will NOT be met\n        min_awake_duration_ms: 0,\n        min_consolidation_queue: 0,\n        ..SleepConfig::default()\n    };\n    let state = SleepState::new(config);\n\n    // Even with other conditions met, idle_trigger is false so should_sleep is false\n    assert!(!state.should_sleep());\n}\n\n#[test]\nfn enter_sleep_already_sleeping() {\n    let config = SleepConfig {\n        idle_threshold_ms: 0,\n        min_awake_duration_ms: 0,\n        min_consolidation_queue: 0,\n        ..SleepConfig::default()\n    };\n    let mut state = SleepState::new(config);\n\n    // Set state to sleeping\n    state.state = types::SleepState::DeepSleep;\n\n    let result = state.enter_sleep();\n    match result {\n        SleepResult::AlreadySleeping =\u003e {}\n        _ =\u003e panic!(\"Expected AlreadySleeping, got {:?}\", result),\n    }\n}\n\n#[test]\nfn enter_sleep_success() {\n    let config = SleepConfig {\n        idle_threshold_ms: 0,\n        min_awake_duration_ms: 0,\n        min_consolidation_queue: 0,\n        ..SleepConfig::default()\n    };\n    let mut state = SleepState::new(config);\n\n    // Need a tiny wait for idle_duration and awake_duration \u003e 0 (since it's strict \u003e)\n    std::thread::sleep(std::time::Duration::from_millis(1));\n\n    let result = state.enter_sleep();\n    match result {\n        SleepResult::Started =\u003e {}\n        _ =\u003e panic!(\"Expected Started, got {:?}\", result),\n    }\n\n    assert_eq!(state.state, types::SleepState::EnteringSleep);\n    assert!(state.current_summary.is_some());\n}\n\n#[test]\nfn wake_with_summary() {\n    let config = SleepConfig::default();\n    let mut state = SleepState::new(config);\n\n    // Set up a current summary with some data\n    let mut summary = SleepSummary::default();\n    summary.cycles_completed = 3;\n    summary.total_memories_replayed = 150;\n    state.current_summary = Some(summary);\n    state.state = types::SleepState::DeepSleep;\n\n    let returned_summary = state.wake();\n\n    assert_eq!(returned_summary.cycles_completed, 3);\n    assert_eq!(returned_summary.total_memories_replayed, 150);\n    assert_eq!(state.state, types::SleepState::Awake);\n    assert!(state.current_summary.is_none());\n}\n\n#[test]\nfn add_cycle_report_with_no_summary() {\n    let config = SleepConfig::default();\n    let mut state = SleepState::new(config);\n\n    // Ensure no summary exists\n    assert!(state.current_summary.is_none());\n\n    let report = SleepCycleReport {\n        cycle_id: uuid::Uuid::new_v4(),\n        duration_ms: 1000,\n        memories_replayed: 50,\n        memories_consolidated: 5,\n        associations_strengthened: 100,\n        associations_pruned: 10,\n        avg_replay_priority: 0.7,\n        peak_emotional_intensity: 0.9,\n        status: SleepCycleStatus::Completed,\n    };\n\n    // This should be a no-op (not panic)\n    state.add_cycle_report(\u0026report);\n\n    // Summary should still be None\n    assert!(state.current_summary.is_none());\n}\n\n#[test]\nfn add_cycle_report_with_summary() {\n    let config = SleepConfig::default();\n    let mut state = SleepState::new(config);\n\n    // Set up a current summary\n    state.current_summary = Some(SleepSummary::default());\n\n    let report = SleepCycleReport {\n        cycle_id: uuid::Uuid::new_v4(),\n        duration_ms: 1000,\n        memories_replayed: 50,\n        memories_consolidated: 5,\n        associations_strengthened: 100,\n        associations_pruned: 10,\n        avg_replay_priority: 0.7,\n        peak_emotional_intensity: 0.9,\n        status: SleepCycleStatus::Completed,\n    };\n\n    state.add_cycle_report(\u0026report);\n\n    let summary = state.current_summary.as_ref().unwrap();\n    assert_eq!(summary.cycles_completed, 1);\n    assert_eq!(summary.total_memories_replayed, 50);\n    assert_eq!(summary.total_memories_consolidated, 5);\n}\n\n#[tokio::test]\nasync fn sleep_actor_external_stimulus_in_deep_sleep() {\n    let (actor_ref, handle) = Actor::spawn(None, SleepActor::default(), ())\n        .await\n        .expect(\"Failed to spawn SleepActor\");\n\n    // We need to directly set the state to DeepSleep via internal means\n    // Since we can't easily do that through messages, we'll test the state logic directly\n    // in a unit test instead. But we can at least verify the actor handles the message.\n\n    actor_ref.stop(None);\n    handle.await.expect(\"Actor failed\");\n}\n\n#[test]\nfn external_stimulus_in_protected_sleep() {\n    let config = SleepConfig::default();\n    let mut state = SleepState::new(config);\n\n    // Set to deep sleep (not interruptible)\n    state.state = types::SleepState::DeepSleep;\n    assert!(!state.is_interruptible());\n\n    // Set to dreaming (not interruptible)\n    state.state = types::SleepState::Dreaming;\n    assert!(!state.is_interruptible());\n}\n\n#[test]\nfn record_activity_resets_timer() {\n    let config = SleepConfig::default();\n    let mut state = SleepState::new(config);\n\n    // Record activity and verify it updates the last_activity timestamp\n    let before = state.last_activity;\n    std::thread::sleep(std::time::Duration::from_millis(10));\n    state.record_activity();\n    let after = state.last_activity;\n\n    assert!(after \u003e before);\n}\n\n#[test]\nfn advance_sleep_phase_boundary_conditions() {\n    let config = SleepConfig {\n        light_sleep_duration_pct: 0.2,\n        ..SleepConfig::default()\n    };\n    let mut state = SleepState::new(config.clone());\n\n    // Exactly at light sleep threshold\n    state.advance_sleep_phase(0.0);\n    assert_eq!(state.state, types::SleepState::LightSleep);\n\n    // Just under light sleep threshold\n    state.advance_sleep_phase(0.19);\n    assert_eq!(state.state, types::SleepState::LightSleep);\n\n    // At light sleep threshold (should move to deep)\n    state.advance_sleep_phase(0.2);\n    assert_eq!(state.state, types::SleepState::DeepSleep);\n\n    // Between deep sleep and dreaming\n    state.advance_sleep_phase(0.5);\n    assert_eq!(state.state, types::SleepState::DeepSleep);\n\n    // At 70% threshold (should move to dreaming)\n    state.advance_sleep_phase(0.7);\n    assert_eq!(state.state, types::SleepState::Dreaming);\n\n    // Well into dreaming\n    state.advance_sleep_phase(0.99);\n    assert_eq!(state.state, types::SleepState::Dreaming);\n}\n\n#[test]\nfn sleep_actor_with_custom_config() {\n    let config = SleepConfig {\n        idle_threshold_ms: 5000,\n        replay_batch_size: 100,\n        ..SleepConfig::default()\n    };\n\n    let actor = SleepActor::with_config(config.clone());\n    assert_eq!(actor.config.idle_threshold_ms, 5000);\n    assert_eq!(actor.config.replay_batch_size, 100);\n}\n\n#[tokio::test]\nasync fn sleep_actor_enter_sleep_when_already_sleeping() {\n    let config = SleepConfig {\n        idle_threshold_ms: 0,\n        min_awake_duration_ms: 0,\n        min_consolidation_queue: 0,\n        ..SleepConfig::default()\n    };\n\n    let (actor_ref, handle) = Actor::spawn(None, SleepActor::with_config(config), ())\n        .await\n        .expect(\"Failed to spawn SleepActor\");\n\n    // Need a tiny wait for idle_duration and awake_duration \u003e 0 (since it's strict \u003e)\n    tokio::time::sleep(std::time::Duration::from_millis(1)).await;\n\n    // First enter sleep - should succeed\n    let result1 = unwrap_call(\n        actor_ref\n            .call(|reply| SleepMessage::EnterSleep { reply }, None)\n            .await\n            .expect(\"Failed to enter sleep\"),\n    );\n\n    match result1 {\n        SleepResult::Started =\u003e {}\n        _ =\u003e panic!(\"Expected Started, got {:?}\", result1),\n    }\n\n    // Verify state is EnteringSleep\n    let state = unwrap_call(\n        actor_ref\n            .call(|reply| SleepMessage::GetState { reply }, None)\n            .await\n            .expect(\"Failed to get state\"),\n    );\n    assert_eq!(state, types::SleepState::EnteringSleep);\n\n    // Second enter sleep - should return AlreadySleeping\n    let result2 = unwrap_call(\n        actor_ref\n            .call(|reply| SleepMessage::EnterSleep { reply }, None)\n            .await\n            .expect(\"Failed to enter sleep\"),\n    );\n\n    match result2 {\n        SleepResult::AlreadySleeping =\u003e {}\n        _ =\u003e panic!(\"Expected AlreadySleeping, got {:?}\", result2),\n    }\n\n    actor_ref.stop(None);\n    handle.await.expect(\"Actor failed\");\n}\n\n#[tokio::test]\nasync fn sleep_actor_external_stimulus_when_in_entering_sleep() {\n    let config = SleepConfig {\n        idle_threshold_ms: 0,\n        min_awake_duration_ms: 0,\n        min_consolidation_queue: 0,\n        ..SleepConfig::default()\n    };\n\n    let (actor_ref, handle) = Actor::spawn(None, SleepActor::with_config(config), ())\n        .await\n        .expect(\"Failed to spawn SleepActor\");\n\n    // Need a tiny wait for idle_duration and awake_duration \u003e 0 (since it's strict \u003e)\n    tokio::time::sleep(std::time::Duration::from_millis(1)).await;\n\n    // Enter sleep first\n    let _ = unwrap_call(\n        actor_ref\n            .call(|reply| SleepMessage::EnterSleep { reply }, None)\n            .await\n            .expect(\"Failed to enter sleep\"),\n    );\n\n    // Verify in EnteringSleep state\n    let state = unwrap_call(\n        actor_ref\n            .call(|reply| SleepMessage::GetState { reply }, None)\n            .await\n            .expect(\"Failed to get state\"),\n    );\n    assert_eq!(state, types::SleepState::EnteringSleep);\n\n    // External stimulus when in EnteringSleep (interruptible) should be processed\n    // and should transition to Waking\n    let processed = unwrap_call(\n        actor_ref\n            .call(\n                |reply| SleepMessage::ExternalStimulus {\n                    stimulus: \"test interrupt\".to_string(),\n                    reply,\n                },\n                None,\n            )\n            .await\n            .expect(\"Failed to send stimulus\"),\n    );\n\n    assert!(processed);\n\n    // State should now be Waking\n    let state = unwrap_call(\n        actor_ref\n            .call(|reply| SleepMessage::GetState { reply }, None)\n            .await\n            .expect(\"Failed to get state\"),\n    );\n    assert_eq!(state, types::SleepState::Waking);\n\n    actor_ref.stop(None);\n    handle.await.expect(\"Actor failed\");\n}\n\n#[tokio::test]\nasync fn sleep_actor_wake_after_sleep_cycle() {\n    let config = SleepConfig {\n        idle_threshold_ms: 0,\n        min_awake_duration_ms: 0,\n        min_consolidation_queue: 0,\n        ..SleepConfig::default()\n    };\n\n    let (actor_ref, handle) = Actor::spawn(None, SleepActor::with_config(config), ())\n        .await\n        .expect(\"Failed to spawn SleepActor\");\n\n    // Need a tiny wait for idle_duration and awake_duration \u003e 0 (since it's strict \u003e)\n    tokio::time::sleep(std::time::Duration::from_millis(1)).await;\n\n    // Enter sleep\n    let result = unwrap_call(\n        actor_ref\n            .call(|reply| SleepMessage::EnterSleep { reply }, None)\n            .await\n            .expect(\"Failed to enter sleep\"),\n    );\n\n    match result {\n        SleepResult::Started =\u003e {}\n        _ =\u003e panic!(\"Expected Started, got {:?}\", result),\n    }\n\n    // Wake up - should return summary (which was created when entering sleep)\n    let summary = unwrap_call(\n        actor_ref\n            .call(|reply| SleepMessage::Wake { reply }, None)\n            .await\n            .expect(\"Failed to wake\"),\n    );\n\n    // Summary should be a fresh default (no cycles completed yet in this simple test)\n    assert_eq!(summary.cycles_completed, 0);\n\n    // Verify state is Awake\n    let state = unwrap_call(\n        actor_ref\n            .call(|reply| SleepMessage::GetState { reply }, None)\n            .await\n            .expect(\"Failed to get state\"),\n    );\n    assert_eq!(state, types::SleepState::Awake);\n\n    actor_ref.stop(None);\n    handle.await.expect(\"Actor failed\");\n}\n\n#[tokio::test]\nasync fn sleep_actor_check_conditions_when_should_sleep() {\n    let config = SleepConfig {\n        idle_threshold_ms: 0,\n        min_awake_duration_ms: 0,\n        min_consolidation_queue: 0,\n        ..SleepConfig::default()\n    };\n\n    let (actor_ref, handle) = Actor::spawn(None, SleepActor::with_config(config), ())\n        .await\n        .expect(\"Failed to spawn SleepActor\");\n\n    // Need a tiny wait for idle_duration and awake_duration \u003e 0 (since it's strict \u003e)\n    tokio::time::sleep(std::time::Duration::from_millis(1)).await;\n\n    // With zero thresholds and tiny elapsed time, should be ready to sleep\n    let should_sleep = unwrap_call(\n        actor_ref\n            .call(|reply| SleepMessage::CheckSleepConditions { reply }, None)\n            .await\n            .expect(\"Failed to check conditions\"),\n    );\n\n    assert!(should_sleep);\n\n    actor_ref.stop(None);\n    handle.await.expect(\"Actor failed\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","sleep","types.rs"],"content":"//! Sleep Actor Types (ADR-023)\n//!\n//! Types for sleep/dream consolidation mode.\n//!\n//! # TMI Concept\n//!\n//! Human memory consolidation occurs during sleep through:\n//! - Sharp-wave ripples (SWRs): High-frequency replay\n//! - Synaptic homeostasis: Pruning weak connections\n//!\n//! DANEEL implements this via periodic consolidation cycles.\n\nuse ractor::RpcReplyPort;\nuse serde::{Deserialize, Serialize};\n\n/// Sleep state machine\n#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Serialize, Deserialize)]\npub enum SleepState {\n    /// Normal operation, processing external stimuli\n    #[default]\n    Awake,\n    /// Transitioning to sleep (interruptible)\n    EnteringSleep,\n    /// Light sleep (interruptible)\n    LightSleep,\n    /// Deep sleep - core consolidation (protected)\n    DeepSleep,\n    /// Dreaming - association strengthening (protected)\n    Dreaming,\n    /// Waking up\n    Waking,\n}\n\nimpl std::fmt::Display for SleepState {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Awake =\u003e write!(f, \"awake\"),\n            Self::EnteringSleep =\u003e write!(f, \"entering_sleep\"),\n            Self::LightSleep =\u003e write!(f, \"light_sleep\"),\n            Self::DeepSleep =\u003e write!(f, \"deep_sleep\"),\n            Self::Dreaming =\u003e write!(f, \"dreaming\"),\n            Self::Waking =\u003e write!(f, \"waking\"),\n        }\n    }\n}\n\n/// Sleep configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SleepConfig {\n    // === Entry Thresholds ===\n    /// Idle time before considering sleep (ms)\n    pub idle_threshold_ms: u64,\n\n    /// Minimum awake duration before sleep allowed (ms)\n    pub min_awake_duration_ms: u64,\n\n    /// Minimum consolidation queue size to trigger sleep\n    pub min_consolidation_queue: usize,\n\n    // === Cycle Parameters ===\n    /// Target duration of a sleep cycle (ms)\n    pub target_cycle_duration_ms: u64,\n\n    /// Number of memories to replay per cycle\n    pub replay_batch_size: usize,\n\n    /// Ratio of novel (recent) to familiar (old) memories in replay\n    /// 0.7 = 70% novel, 30% familiar\n    pub interleave_ratio: f32,\n\n    // === Interruptibility ===\n    /// Percentage of cycle that is interruptible (light sleep)\n    pub light_sleep_duration_pct: f32,\n\n    // === Consolidation ===\n    /// Strength increase per replay\n    pub consolidation_delta: f32,\n\n    /// Threshold for permanent memory status\n    pub permanent_threshold: f32,\n\n    // === Hebbian Learning ===\n    /// Weight increase for co-replayed memories\n    pub association_delta: f32,\n\n    /// Threshold below which associations are pruned\n    pub prune_threshold: f32,\n\n    /// Weight decay for non-replayed associations per cycle\n    pub decay_per_cycle: f32,\n}\n\nimpl Default for SleepConfig {\n    fn default() -\u003e Self {\n        Self {\n            // Entry: 5 min idle, 1 hour awake, 100 memories queued\n            idle_threshold_ms: 300_000,\n            min_awake_duration_ms: 3_600_000,\n            min_consolidation_queue: 100,\n\n            // Cycle: 5 minutes, 50 memories\n            target_cycle_duration_ms: 300_000,\n            replay_batch_size: 50,\n            interleave_ratio: 0.7,\n\n            // First 20% is light sleep (interruptible)\n            light_sleep_duration_pct: 0.2,\n\n            // Consolidation: 0.15 per replay, 0.9 = permanent\n            consolidation_delta: 0.15,\n            permanent_threshold: 0.9,\n\n            // Hebbian: 0.05 per co-replay, prune \u003c 0.1, decay 0.01/cycle\n            association_delta: 0.05,\n            prune_threshold: 0.1,\n            decay_per_cycle: 0.01,\n        }\n    }\n}\n\nimpl SleepConfig {\n    /// Fast config for testing (1 second cycles, low thresholds)\n    #[must_use]\n    pub fn fast() -\u003e Self {\n        Self {\n            idle_threshold_ms: 1000,\n            min_awake_duration_ms: 5000,\n            min_consolidation_queue: 5,\n            target_cycle_duration_ms: 1000,\n            replay_batch_size: 10,\n            interleave_ratio: 0.7,\n            light_sleep_duration_pct: 0.2,\n            consolidation_delta: 0.15,\n            permanent_threshold: 0.9,\n            association_delta: 0.05,\n            prune_threshold: 0.1,\n            decay_per_cycle: 0.01,\n        }\n    }\n}\n\n/// Sleep cycle report\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SleepCycleReport {\n    /// Unique cycle identifier\n    pub cycle_id: uuid::Uuid,\n\n    /// Cycle duration\n    pub duration_ms: u64,\n\n    /// Number of memories replayed\n    pub memories_replayed: usize,\n\n    /// Number of memories reaching permanent threshold\n    pub memories_consolidated: usize,\n\n    /// Number of associations strengthened\n    pub associations_strengthened: usize,\n\n    /// Number of associations pruned\n    pub associations_pruned: usize,\n\n    /// Average replay priority of batch\n    pub avg_replay_priority: f32,\n\n    /// Peak emotional intensity in batch\n    pub peak_emotional_intensity: f32,\n\n    /// Status\n    pub status: SleepCycleStatus,\n}\n\n/// Sleep cycle status\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum SleepCycleStatus {\n    InProgress,\n    Completed,\n    Interrupted,\n}\n\nimpl SleepCycleReport {\n    /// Create an empty report (for when no consolidation needed)\n    #[must_use]\n    pub fn empty(cycle_id: uuid::Uuid) -\u003e Self {\n        Self {\n            cycle_id,\n            duration_ms: 0,\n            memories_replayed: 0,\n            memories_consolidated: 0,\n            associations_strengthened: 0,\n            associations_pruned: 0,\n            avg_replay_priority: 0.0,\n            peak_emotional_intensity: 0.0,\n            status: SleepCycleStatus::Completed,\n        }\n    }\n}\n\n/// Sleep summary (aggregate of multiple cycles)\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct SleepSummary {\n    /// Total sleep duration (ms)\n    pub total_duration_ms: u64,\n\n    /// Number of cycles completed\n    pub cycles_completed: u32,\n\n    /// Total memories replayed\n    pub total_memories_replayed: usize,\n\n    /// Total memories consolidated\n    pub total_memories_consolidated: usize,\n\n    /// Total associations strengthened\n    pub total_associations_strengthened: usize,\n\n    /// Total associations pruned\n    pub total_associations_pruned: usize,\n\n    /// Average priority per cycle\n    pub avg_priority_per_cycle: f32,\n\n    /// Consolidation rate (consolidated / replayed)\n    pub consolidation_rate: f32,\n}\n\nimpl SleepSummary {\n    /// Add a cycle report to the summary\n    pub fn add_cycle(\u0026mut self, report: \u0026SleepCycleReport) {\n        self.total_duration_ms += report.duration_ms;\n        self.cycles_completed += 1;\n        self.total_memories_replayed += report.memories_replayed;\n        self.total_memories_consolidated += report.memories_consolidated;\n        self.total_associations_strengthened += report.associations_strengthened;\n        self.total_associations_pruned += report.associations_pruned;\n\n        // Running average\n        let n = self.cycles_completed as f32;\n        self.avg_priority_per_cycle =\n            (self.avg_priority_per_cycle * (n - 1.0) + report.avg_replay_priority) / n;\n    }\n\n    /// Finalize the summary\n    pub fn finalize(\u0026mut self) {\n        if self.total_memories_replayed \u003e 0 {\n            self.consolidation_rate =\n                self.total_memories_consolidated as f32 / self.total_memories_replayed as f32;\n        }\n    }\n}\n\n/// Messages for the Sleep Actor\n#[derive(Debug)]\npub enum SleepMessage {\n    /// Check if sleep should begin\n    CheckSleepConditions { reply: RpcReplyPort\u003cbool\u003e },\n\n    /// Force enter sleep mode\n    EnterSleep { reply: RpcReplyPort\u003cSleepResult\u003e },\n\n    /// Force wake up\n    Wake { reply: RpcReplyPort\u003cSleepSummary\u003e },\n\n    /// Get current sleep state\n    GetState { reply: RpcReplyPort\u003cSleepState\u003e },\n\n    /// External stimulus received (may interrupt sleep)\n    ExternalStimulus {\n        stimulus: String,\n        reply: RpcReplyPort\u003cbool\u003e, // true if processed, false if in protected sleep\n    },\n\n    /// Record activity (resets idle timer)\n    RecordActivity,\n\n    /// Get configuration\n    GetConfig { reply: RpcReplyPort\u003cSleepConfig\u003e },\n\n    /// Update configuration\n    UpdateConfig {\n        config: SleepConfig,\n        reply: RpcReplyPort\u003c()\u003e,\n    },\n}\n\n/// Sleep operation result\n#[derive(Debug, Clone)]\npub enum SleepResult {\n    /// Sleep started successfully\n    Started,\n    /// Already sleeping\n    AlreadySleeping,\n    /// Conditions not met for sleep\n    ConditionsNotMet { reason: String },\n    /// Error occurred\n    Error { message: String },\n}\n\n/// Sleep actor errors\n#[derive(Debug, Clone, thiserror::Error)]\npub enum SleepError {\n    #[error(\"Memory database error: {0}\")]\n    MemoryDb(String),\n\n    #[error(\"Stream error: {0}\")]\n    Stream(String),\n\n    #[error(\"Interrupted by external stimulus\")]\n    Interrupted,\n\n    #[error(\"Configuration error: {0}\")]\n    Config(String),\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn default_sleep_config() {\n        let config = SleepConfig::default();\n\n        assert_eq!(config.idle_threshold_ms, 300_000); // 5 min\n        assert_eq!(config.min_awake_duration_ms, 3_600_000); // 1 hour\n        assert_eq!(config.replay_batch_size, 50);\n        assert!((config.interleave_ratio - 0.7).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn fast_sleep_config() {\n        let config = SleepConfig::fast();\n\n        assert_eq!(config.idle_threshold_ms, 1000); // 1 sec\n        assert_eq!(config.min_awake_duration_ms, 5000); // 5 sec\n        assert_eq!(config.replay_batch_size, 10);\n    }\n\n    #[test]\n    fn sleep_state_display() {\n        assert_eq!(SleepState::Awake.to_string(), \"awake\");\n        assert_eq!(SleepState::EnteringSleep.to_string(), \"entering_sleep\");\n        assert_eq!(SleepState::LightSleep.to_string(), \"light_sleep\");\n        assert_eq!(SleepState::DeepSleep.to_string(), \"deep_sleep\");\n        assert_eq!(SleepState::Dreaming.to_string(), \"dreaming\");\n        assert_eq!(SleepState::Waking.to_string(), \"waking\");\n    }\n\n    #[test]\n    fn sleep_summary_accumulation() {\n        let mut summary = SleepSummary::default();\n\n        let report1 = SleepCycleReport {\n            cycle_id: uuid::Uuid::new_v4(),\n            duration_ms: 1000,\n            memories_replayed: 50,\n            memories_consolidated: 5,\n            associations_strengthened: 100,\n            associations_pruned: 10,\n            avg_replay_priority: 0.7,\n            peak_emotional_intensity: 0.9,\n            status: SleepCycleStatus::Completed,\n        };\n\n        let report2 = SleepCycleReport {\n            cycle_id: uuid::Uuid::new_v4(),\n            duration_ms: 1200,\n            memories_replayed: 40,\n            memories_consolidated: 8,\n            associations_strengthened: 80,\n            associations_pruned: 5,\n            avg_replay_priority: 0.8,\n            peak_emotional_intensity: 0.7,\n            status: SleepCycleStatus::Completed,\n        };\n\n        summary.add_cycle(\u0026report1);\n        summary.add_cycle(\u0026report2);\n        summary.finalize();\n\n        assert_eq!(summary.cycles_completed, 2);\n        assert_eq!(summary.total_duration_ms, 2200);\n        assert_eq!(summary.total_memories_replayed, 90);\n        assert_eq!(summary.total_memories_consolidated, 13);\n        assert!(summary.consolidation_rate \u003e 0.1);\n    }\n\n    #[test]\n    fn empty_cycle_report() {\n        let report = SleepCycleReport::empty(uuid::Uuid::new_v4());\n\n        assert_eq!(report.memories_replayed, 0);\n        assert_eq!(report.status, SleepCycleStatus::Completed);\n    }\n\n    #[test]\n    fn sleep_summary_finalize_with_no_replays() {\n        let mut summary = SleepSummary::default();\n\n        // Finalize without any cycles (no memories replayed)\n        summary.finalize();\n\n        // consolidation_rate should remain 0 (no division by zero)\n        assert_eq!(summary.consolidation_rate, 0.0);\n    }\n\n    #[test]\n    fn sleep_cycle_status_variants() {\n        // Test all SleepCycleStatus variants for coverage\n        assert_eq!(SleepCycleStatus::InProgress, SleepCycleStatus::InProgress);\n        assert_eq!(SleepCycleStatus::Completed, SleepCycleStatus::Completed);\n        assert_eq!(SleepCycleStatus::Interrupted, SleepCycleStatus::Interrupted);\n    }\n\n    #[test]\n    fn sleep_result_variants() {\n        // Test SleepResult variants\n        let started = SleepResult::Started;\n        let already = SleepResult::AlreadySleeping;\n        let not_met = SleepResult::ConditionsNotMet {\n            reason: \"test\".to_string(),\n        };\n        let error = SleepResult::Error {\n            message: \"test error\".to_string(),\n        };\n\n        // Just verify they can be created and debug printed\n        assert!(format!(\"{:?}\", started).contains(\"Started\"));\n        assert!(format!(\"{:?}\", already).contains(\"AlreadySleeping\"));\n        assert!(format!(\"{:?}\", not_met).contains(\"ConditionsNotMet\"));\n        assert!(format!(\"{:?}\", error).contains(\"Error\"));\n    }\n\n    #[test]\n    fn sleep_error_display() {\n        let mem_err = SleepError::MemoryDb(\"db failed\".to_string());\n        let stream_err = SleepError::Stream(\"stream failed\".to_string());\n        let interrupted = SleepError::Interrupted;\n        let config_err = SleepError::Config(\"bad config\".to_string());\n\n        assert!(mem_err.to_string().contains(\"Memory database error\"));\n        assert!(stream_err.to_string().contains(\"Stream error\"));\n        assert!(interrupted.to_string().contains(\"Interrupted\"));\n        assert!(config_err.to_string().contains(\"Configuration error\"));\n    }\n}\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":25},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","thought","mod.rs"],"content":"//! ThoughtAssemblyActor - Construo do Pensamento (Thought Construction)\n//!\n//! Implements TMI's thought assembly stage where pre-linguistic content\n//! becomes structured cognitive units.\n//!\n//! # TMI Concept: \"Construo do Pensamento\"\n//!\n//! From Cury's Theory of Multifocal Intelligence:\n//! - Thoughts are assembled from content + emotional state (salience)\n//! - Assembly happens BEFORE language (pre-linguistic)\n//! - Thoughts link into chains (parent-child relationships)\n//! - Each thought captures its source stream (which content won)\n//!\n//! The ThoughtAssemblyActor is the final stage before consciousness. It takes\n//! raw content (from competition) and emotional coloring (salience) and\n//! assembles them into coherent Thought objects.\n//!\n//! # Key Responsibilities\n//!\n//! - **Assembly**: Convert AssemblyRequest -\u003e Thought\n//! - **Caching**: Store recently assembled thoughts for quick retrieval\n//! - **Chaining**: Link thoughts to their parents (causal history)\n//! - **Strategy**: Support different assembly strategies (Default, Composite, Chain, Urgent)\n//! - **Validation**: Optional salience score validation\n//!\n//! # Usage\n//!\n//! ```no_run\n//! use daneel::actors::thought::{ThoughtAssemblyActor, ThoughtMessage, AssemblyRequest, AssemblyConfig};\n//! use daneel::core::types::{Content, SalienceScore};\n//! use ractor::Actor;\n//!\n//! # async fn example() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n//! // Spawn the actor with custom config\n//! let config = AssemblyConfig::default();\n//! let (actor_ref, _) = Actor::spawn(None, ThoughtAssemblyActor, config).await?;\n//!\n//! // Assemble a thought\n//! let content = Content::raw(vec![1, 2, 3]);\n//! let salience = SalienceScore::neutral();\n//! let request = AssemblyRequest::new(content, salience);\n//!\n//! let response = actor_ref.call(|reply| ThoughtMessage::Assemble {\n//!     request,\n//!     reply,\n//! }, None).await?;\n//! # Ok(())\n//! # }\n//! ```\n\npub mod types;\n\n#[cfg(test)]\nmod tests;\n\nuse crate::core::types::{SalienceScore, Thought, ThoughtId};\nuse ractor::{Actor, ActorProcessingErr, ActorRef};\n\n// Re-export types for public API\npub use types::{\n    AssemblyError, AssemblyRequest, AssemblyStrategy, ThoughtCache, ThoughtMessage, ThoughtResponse,\n};\n\n/// Configuration for the ThoughtAssemblyActor\n///\n/// Controls caching, validation, and chain traversal behavior.\n#[derive(Debug, Clone)]\npub struct AssemblyConfig {\n    /// Maximum number of thoughts to cache in memory\n    pub cache_size: usize,\n\n    /// Maximum depth when traversing parent chains\n    /// Prevents infinite loops and stack overflow\n    pub max_chain_depth: usize,\n\n    /// Whether to validate salience scores during assembly\n    /// When true, checks that all components are in valid ranges\n    pub validate_salience: bool,\n}\n\nimpl AssemblyConfig {\n    /// Create a new assembly configuration\n    #[must_use]\n    pub const fn new(cache_size: usize, max_chain_depth: usize, validate_salience: bool) -\u003e Self {\n        Self {\n            cache_size,\n            max_chain_depth,\n            validate_salience,\n        }\n    }\n}\n\nimpl Default for AssemblyConfig {\n    fn default() -\u003e Self {\n        Self {\n            cache_size: 100,         // Cache last 100 thoughts\n            max_chain_depth: 50,     // Traverse up to 50 parent links\n            validate_salience: true, // Validate by default\n        }\n    }\n}\n\n/// Internal state for the ThoughtAssemblyActor\n///\n/// Maintains cache and statistics for thought assembly.\n#[derive(Debug)]\npub struct ThoughtState {\n    /// Cache of recently assembled thoughts\n    cache: ThoughtCache,\n\n    /// Total number of thoughts assembled (lifetime counter)\n    assembly_count: u64,\n\n    /// Configuration for this actor instance\n    config: AssemblyConfig,\n}\n\nimpl ThoughtState {\n    /// Create new thought state with default configuration\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self::with_config(AssemblyConfig::default())\n    }\n\n    /// Create new thought state with custom configuration\n    #[must_use]\n    pub fn with_config(config: AssemblyConfig) -\u003e Self {\n        Self {\n            cache: ThoughtCache::new(config.cache_size),\n            assembly_count: 0,\n            config,\n        }\n    }\n\n    /// Assemble a single thought from a request\n    ///\n    /// This is the core assembly logic that converts raw content + salience\n    /// into a structured Thought object.\n    fn assemble_thought(\u0026mut self, request: AssemblyRequest) -\u003e Result\u003cThought, AssemblyError\u003e {\n        // Validate content is not empty\n        if request.content.is_empty() {\n            return Err(AssemblyError::EmptyContent);\n        }\n\n        // Validate salience if configured\n        if self.config.validate_salience {\n            self.validate_salience(\u0026request.salience)?;\n        }\n\n        // Create base thought\n        let mut thought = Thought::new(request.content, request.salience);\n\n        // Link to parent if specified\n        if let Some(parent_id) = request.parent_id {\n            thought = thought.with_parent(parent_id);\n        }\n\n        // Tag with source stream if specified\n        if let Some(source) = request.source_stream {\n            thought = thought.with_source(source);\n        }\n\n        // Apply strategy-specific processing\n        self.apply_strategy(\u0026mut thought, \u0026request.strategy)?;\n\n        // Cache the assembled thought\n        self.cache.insert(thought.clone());\n\n        // Increment counter\n        self.assembly_count += 1;\n\n        Ok(thought)\n    }\n\n    /// Assemble multiple thoughts in batch\n    ///\n    /// More efficient than individual assembly for bulk operations.\n    fn assemble_batch(\n        \u0026mut self,\n        requests: Vec\u003cAssemblyRequest\u003e,\n    ) -\u003e Result\u003cVec\u003cThought\u003e, AssemblyError\u003e {\n        let mut thoughts = Vec::with_capacity(requests.len());\n\n        for request in requests {\n            let thought = self.assemble_thought(request)?;\n            thoughts.push(thought);\n        }\n\n        Ok(thoughts)\n    }\n\n    /// Retrieve a thought from the cache\n    fn get_thought(\u0026self, thought_id: \u0026ThoughtId) -\u003e Result\u003cThought, AssemblyError\u003e {\n        self.cache\n            .get(thought_id)\n            .cloned()\n            .ok_or(AssemblyError::ThoughtNotFound {\n                thought_id: *thought_id,\n            })\n    }\n\n    /// Get a thought chain (thought + its ancestry)\n    ///\n    /// Walks up the parent chain from the given thought, up to max_depth.\n    fn get_thought_chain(\n        \u0026self,\n        thought_id: ThoughtId,\n        depth: usize,\n    ) -\u003e Result\u003cVec\u003cThought\u003e, AssemblyError\u003e {\n        // Validate depth against configured maximum\n        if depth \u003e self.config.max_chain_depth {\n            return Err(AssemblyError::ChainTooDeep {\n                max_depth: self.config.max_chain_depth,\n            });\n        }\n\n        let mut chain = Vec::new();\n        let mut current_id = thought_id;\n        let mut remaining_depth = depth;\n\n        // Walk up the chain\n        while remaining_depth \u003e 0 {\n            // Get current thought\n            let thought = self.get_thought(\u0026current_id)?;\n\n            // Add to chain\n            chain.push(thought.clone());\n\n            // Check for parent\n            match thought.parent_id {\n                Some(parent_id) =\u003e {\n                    current_id = parent_id;\n                    remaining_depth -= 1;\n                }\n                None =\u003e break, // Reached root of chain\n            }\n        }\n\n        Ok(chain)\n    }\n\n    /// Validate salience score components\n    #[allow(clippy::unused_self)] // Will use self for config-based validation\n    fn validate_salience(\u0026self, salience: \u0026SalienceScore) -\u003e Result\u003c(), AssemblyError\u003e {\n        // Check importance, novelty, relevance are in [0.0, 1.0]\n        if !(0.0..=1.0).contains(\u0026salience.importance) {\n            return Err(AssemblyError::InvalidSalience {\n                reason: format!(\"importance {} out of range [0.0, 1.0]\", salience.importance),\n            });\n        }\n\n        if !(0.0..=1.0).contains(\u0026salience.novelty) {\n            return Err(AssemblyError::InvalidSalience {\n                reason: format!(\"novelty {} out of range [0.0, 1.0]\", salience.novelty),\n            });\n        }\n\n        if !(0.0..=1.0).contains(\u0026salience.relevance) {\n            return Err(AssemblyError::InvalidSalience {\n                reason: format!(\"relevance {} out of range [0.0, 1.0]\", salience.relevance),\n            });\n        }\n\n        // Check valence is in [-1.0, 1.0]\n        if !(-1.0..=1.0).contains(\u0026salience.valence) {\n            return Err(AssemblyError::InvalidSalience {\n                reason: format!(\"valence {} out of range [-1.0, 1.0]\", salience.valence),\n            });\n        }\n\n        // Check connection_relevance is in [0.0, 1.0]\n        if !(0.0..=1.0).contains(\u0026salience.connection_relevance) {\n            return Err(AssemblyError::InvalidSalience {\n                reason: format!(\n                    \"connection_relevance {} out of range [0.0, 1.0]\",\n                    salience.connection_relevance\n                ),\n            });\n        }\n\n        Ok(())\n    }\n\n    /// Apply strategy-specific processing to a thought\n    ///\n    /// Different strategies modify thought assembly in different ways.\n    #[allow(clippy::unnecessary_wraps)] // Will return errors in future strategies\n    #[allow(clippy::needless_pass_by_ref_mut)] // Will mutate in future strategies\n    fn apply_strategy(\n        \u0026mut self,\n        thought: \u0026mut Thought,\n        strategy: \u0026AssemblyStrategy,\n    ) -\u003e Result\u003c(), AssemblyError\u003e {\n        match strategy {\n            AssemblyStrategy::Default =\u003e {\n                // No special processing for default strategy\n                Ok(())\n            }\n\n            AssemblyStrategy::Composite =\u003e {\n                // For composite, ensure content is appropriate\n                // Could validate that content is Composite variant\n                // For now, just pass through\n                Ok(())\n            }\n\n            AssemblyStrategy::Chain =\u003e {\n                // For chain strategy, could propagate parent's salience\n                // or apply special linking logic\n                // For now, the parent_id is already linked\n                if let Some(parent_id) = thought.parent_id {\n                    // Could retrieve parent and merge salience here\n                    // For Wave 3, just ensure parent exists in cache\n                    if self.cache.get(\u0026parent_id).is_none() {\n                        // Parent not in cache - not an error, just note it\n                        // In production, might want to load from persistence\n                    }\n                }\n                Ok(())\n            }\n\n            AssemblyStrategy::Urgent =\u003e {\n                // Urgent thoughts get priority treatment\n                // Could boost salience scores here\n                // For now, just pass through (priority handled by caller)\n                Ok(())\n            }\n        }\n    }\n}\n\nimpl Default for ThoughtState {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// The Thought Assembly Actor\n///\n/// Implements thought construction as a Ractor actor.\npub struct ThoughtAssemblyActor;\n\n#[ractor::async_trait]\nimpl Actor for ThoughtAssemblyActor {\n    type Msg = ThoughtMessage;\n    type State = ThoughtState;\n    type Arguments = AssemblyConfig;\n\n    async fn pre_start(\n        \u0026self,\n        _myself: ActorRef\u003cSelf::Msg\u003e,\n        args: Self::Arguments,\n    ) -\u003e Result\u003cSelf::State, ActorProcessingErr\u003e {\n        Ok(ThoughtState::with_config(args))\n    }\n\n    async fn handle(\n        \u0026self,\n        _myself: ActorRef\u003cSelf::Msg\u003e,\n        message: Self::Msg,\n        state: \u0026mut Self::State,\n    ) -\u003e Result\u003c(), ActorProcessingErr\u003e {\n        match message {\n            ThoughtMessage::Assemble { request, reply } =\u003e {\n                let response = match state.assemble_thought(request) {\n                    Ok(thought) =\u003e ThoughtResponse::Assembled { thought },\n                    Err(error) =\u003e ThoughtResponse::Error { error },\n                };\n                let _ = reply.send(response);\n            }\n\n            ThoughtMessage::AssembleBatch { requests, reply } =\u003e {\n                let response = match state.assemble_batch(requests) {\n                    Ok(thoughts) =\u003e ThoughtResponse::BatchAssembled { thoughts },\n                    Err(error) =\u003e ThoughtResponse::Error { error },\n                };\n                let _ = reply.send(response);\n            }\n\n            ThoughtMessage::GetThought { thought_id, reply } =\u003e {\n                let response = match state.get_thought(\u0026thought_id) {\n                    Ok(thought) =\u003e ThoughtResponse::ThoughtFound { thought },\n                    Err(error) =\u003e ThoughtResponse::Error { error },\n                };\n                let _ = reply.send(response);\n            }\n\n            ThoughtMessage::GetThoughtChain {\n                thought_id,\n                depth,\n                reply,\n            } =\u003e {\n                let response = match state.get_thought_chain(thought_id, depth) {\n                    Ok(thoughts) =\u003e ThoughtResponse::ThoughtChain { thoughts },\n                    Err(error) =\u003e ThoughtResponse::Error { error },\n                };\n                let _ = reply.send(response);\n            }\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":76},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","thought","tests.rs"],"content":"//! Tests for ThoughtAssemblyActor\n\nuse super::*;\nuse crate::core::types::{Content, SalienceScore, ThoughtId};\nuse ractor::rpc::CallResult;\nuse ractor::Actor;\n\n/// Helper to spawn a thought actor for testing\nasync fn spawn_thought_actor() -\u003e ActorRef\u003cThoughtMessage\u003e {\n    let (actor_ref, _) = Actor::spawn(None, ThoughtAssemblyActor, AssemblyConfig::default())\n        .await\n        .expect(\"Failed to spawn ThoughtAssemblyActor\");\n    actor_ref\n}\n\n/// Helper to spawn a thought actor with custom config\nasync fn spawn_thought_actor_with_config(config: AssemblyConfig) -\u003e ActorRef\u003cThoughtMessage\u003e {\n    let (actor_ref, _) = Actor::spawn(None, ThoughtAssemblyActor, config)\n        .await\n        .expect(\"Failed to spawn ThoughtAssemblyActor\");\n    actor_ref\n}\n\n// ============================================================================\n// Actor Lifecycle Tests\n// ============================================================================\n\n#[tokio::test]\nasync fn test_actor_spawns_successfully() {\n    let actor_ref = spawn_thought_actor().await;\n\n    // Verify actor can handle messages by assembling a simple thought\n    let content = Content::raw(vec![1, 2, 3]);\n    let salience = SalienceScore::neutral();\n    let request = AssemblyRequest::new(content, salience);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to assemble thought\");\n\n    assert!(matches!(\n        response,\n        CallResult::Success(ThoughtResponse::Assembled { .. })\n    ));\n}\n\n#[tokio::test]\nasync fn test_actor_with_custom_config() {\n    let config = AssemblyConfig {\n        cache_size: 50,\n        max_chain_depth: 25,\n        validate_salience: false,\n    };\n\n    let actor_ref = spawn_thought_actor_with_config(config).await;\n\n    // Verify actor accepts invalid salience when validation is disabled\n    let content = Content::raw(vec![1, 2, 3]);\n    let salience = SalienceScore::new_without_arousal(1.5, 0.5, 0.5, 0.0, 0.5); // Invalid importance\n    let request = AssemblyRequest::new(content, salience);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to assemble thought\");\n\n    // Should succeed because validation is disabled\n    assert!(matches!(\n        response,\n        CallResult::Success(ThoughtResponse::Assembled { .. })\n    ));\n}\n\n// ============================================================================\n// Basic Assembly Tests\n// ============================================================================\n\n#[tokio::test]\nasync fn test_assemble_raw_content() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let content = Content::raw(vec![42, 43, 44]);\n    let salience = SalienceScore::neutral();\n    let request = AssemblyRequest::new(content.clone(), salience);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to assemble thought\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e {\n            assert_eq!(thought.content, content);\n            assert_eq!(thought.salience, salience);\n            assert!(thought.parent_id.is_none());\n        }\n        _ =\u003e panic!(\"Expected Assembled response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_assemble_symbol_content() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let content = Content::symbol(\"test_symbol\", vec![1, 2, 3]);\n    let salience = SalienceScore::neutral();\n    let request = AssemblyRequest::new(content.clone(), salience);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to assemble thought\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e {\n            assert_eq!(thought.content, content);\n        }\n        _ =\u003e panic!(\"Expected Assembled response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_assemble_relation_content() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let subject = Content::symbol(\"subject\", vec![1]);\n    let object = Content::symbol(\"object\", vec![2]);\n    let content = Content::relation(subject, \"causes\", object);\n    let salience = SalienceScore::neutral();\n    let request = AssemblyRequest::new(content.clone(), salience);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to assemble thought\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e {\n            assert_eq!(thought.content, content);\n        }\n        _ =\u003e panic!(\"Expected Assembled response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_assemble_empty_content_fails() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let content = Content::Empty;\n    let salience = SalienceScore::neutral();\n    let request = AssemblyRequest::new(content, salience);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to send message\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Error { error }) =\u003e {\n            assert!(matches!(error, AssemblyError::EmptyContent));\n        }\n        _ =\u003e panic!(\n            \"Expected Error response with EmptyContent, got: {:?}\",\n            response\n        ),\n    }\n}\n\n// ============================================================================\n// Salience Validation Tests\n// ============================================================================\n\n#[tokio::test]\nasync fn test_assemble_with_valid_salience() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let content = Content::raw(vec![1, 2, 3]);\n    let salience = SalienceScore::new_without_arousal(0.8, 0.6, 0.9, 0.5, 0.7);\n    let request = AssemblyRequest::new(content, salience);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to assemble thought\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e {\n            assert_eq!(thought.salience, salience);\n        }\n        _ =\u003e panic!(\"Expected Assembled response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_assemble_with_invalid_importance() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let content = Content::raw(vec![1, 2, 3]);\n    let salience = SalienceScore::new_without_arousal(1.5, 0.5, 0.5, 0.0, 0.5); // importance \u003e 1.0\n    let request = AssemblyRequest::new(content, salience);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to send message\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Error { error }) =\u003e match error {\n            AssemblyError::InvalidSalience { reason } =\u003e {\n                assert!(reason.contains(\"importance\"));\n            }\n            _ =\u003e panic!(\"Expected InvalidSalience error, got: {:?}\", error),\n        },\n        _ =\u003e panic!(\"Expected Error response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_assemble_with_invalid_valence() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let content = Content::raw(vec![1, 2, 3]);\n    let salience = SalienceScore::new_without_arousal(0.5, 0.5, 0.5, -1.5, 0.5); // valence \u003c -1.0\n    let request = AssemblyRequest::new(content, salience);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to send message\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Error { error }) =\u003e match error {\n            AssemblyError::InvalidSalience { reason } =\u003e {\n                assert!(reason.contains(\"valence\"));\n            }\n            _ =\u003e panic!(\"Expected InvalidSalience error, got: {:?}\", error),\n        },\n        _ =\u003e panic!(\"Expected Error response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_assemble_with_validation_disabled() {\n    let config = AssemblyConfig {\n        cache_size: 100,\n        max_chain_depth: 50,\n        validate_salience: false,\n    };\n    let actor_ref = spawn_thought_actor_with_config(config).await;\n\n    let content = Content::raw(vec![1, 2, 3]);\n    let salience = SalienceScore::new_without_arousal(2.0, -1.0, 5.0, 10.0, -2.0); // All invalid\n    let request = AssemblyRequest::new(content, salience);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to send message\");\n\n    // Should succeed because validation is disabled\n    assert!(matches!(\n        response,\n        CallResult::Success(ThoughtResponse::Assembled { .. })\n    ));\n}\n\n// ============================================================================\n// Parent Linking Tests\n// ============================================================================\n\n#[tokio::test]\nasync fn test_assemble_with_parent() {\n    let actor_ref = spawn_thought_actor().await;\n\n    // Assemble parent thought\n    let parent_content = Content::raw(vec![1, 2, 3]);\n    let parent_salience = SalienceScore::neutral();\n    let parent_request = AssemblyRequest::new(parent_content, parent_salience);\n\n    let parent_thought = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: parent_request,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble parent\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    // Assemble child thought with parent\n    let child_content = Content::raw(vec![4, 5, 6]);\n    let child_salience = SalienceScore::neutral();\n    let child_request =\n        AssemblyRequest::new(child_content, child_salience).with_parent(parent_thought.id);\n\n    let child_response = actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: child_request,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble child\");\n\n    match child_response {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e {\n            assert_eq!(thought.parent_id, Some(parent_thought.id));\n        }\n        _ =\u003e panic!(\"Expected Assembled response, got: {:?}\", child_response),\n    }\n}\n\n#[tokio::test]\nasync fn test_assemble_chain_builds_history() {\n    let actor_ref = spawn_thought_actor().await;\n\n    // Create a chain: thought1 -\u003e thought2 -\u003e thought3\n    let content1 = Content::raw(vec![1]);\n    let thought1 = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: AssemblyRequest::new(content1, SalienceScore::neutral()),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    let content2 = Content::raw(vec![2]);\n    let thought2 = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: AssemblyRequest::new(content2, SalienceScore::neutral())\n                    .with_parent(thought1.id),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    let content3 = Content::raw(vec![3]);\n    let thought3 = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: AssemblyRequest::new(content3, SalienceScore::neutral())\n                    .with_parent(thought2.id),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    // Verify chain relationships\n    assert!(thought1.parent_id.is_none());\n    assert_eq!(thought2.parent_id, Some(thought1.id));\n    assert_eq!(thought3.parent_id, Some(thought2.id));\n}\n\n// ============================================================================\n// Batch Operations Tests\n// ============================================================================\n\n#[tokio::test]\nasync fn test_assemble_batch_empty() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let requests = vec![];\n\n    let response = actor_ref\n        .call(\n            |reply| ThoughtMessage::AssembleBatch { requests, reply },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble batch\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::BatchAssembled { thoughts }) =\u003e {\n            assert_eq!(thoughts.len(), 0);\n        }\n        _ =\u003e panic!(\"Expected BatchAssembled response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_assemble_batch_multiple() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let requests = vec![\n        AssemblyRequest::new(Content::raw(vec![1]), SalienceScore::neutral()),\n        AssemblyRequest::new(Content::raw(vec![2]), SalienceScore::neutral()),\n        AssemblyRequest::new(Content::raw(vec![3]), SalienceScore::neutral()),\n    ];\n\n    let response = actor_ref\n        .call(\n            |reply| ThoughtMessage::AssembleBatch {\n                requests: requests.clone(),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble batch\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::BatchAssembled { thoughts }) =\u003e {\n            assert_eq!(thoughts.len(), 3);\n            assert_eq!(thoughts[0].content, Content::raw(vec![1]));\n            assert_eq!(thoughts[1].content, Content::raw(vec![2]));\n            assert_eq!(thoughts[2].content, Content::raw(vec![3]));\n        }\n        _ =\u003e panic!(\"Expected BatchAssembled response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_assemble_batch_stops_on_error() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let requests = vec![\n        AssemblyRequest::new(Content::raw(vec![1]), SalienceScore::neutral()),\n        AssemblyRequest::new(Content::Empty, SalienceScore::neutral()), // This will fail\n        AssemblyRequest::new(Content::raw(vec![3]), SalienceScore::neutral()),\n    ];\n\n    let response = actor_ref\n        .call(\n            |reply| ThoughtMessage::AssembleBatch { requests, reply },\n            None,\n        )\n        .await\n        .expect(\"Failed to send message\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Error { error }) =\u003e {\n            assert!(matches!(error, AssemblyError::EmptyContent));\n        }\n        _ =\u003e panic!(\"Expected Error response, got: {:?}\", response),\n    }\n}\n\n// ============================================================================\n// Cache Operations Tests\n// ============================================================================\n\n#[tokio::test]\nasync fn test_get_thought_from_cache() {\n    let actor_ref = spawn_thought_actor().await;\n\n    // Assemble a thought\n    let content = Content::raw(vec![1, 2, 3]);\n    let thought_id = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: AssemblyRequest::new(content.clone(), SalienceScore::neutral()),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought.id,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    // Retrieve it from cache\n    let response = actor_ref\n        .call(\n            |reply| ThoughtMessage::GetThought { thought_id, reply },\n            None,\n        )\n        .await\n        .expect(\"Failed to get thought\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::ThoughtFound { thought }) =\u003e {\n            assert_eq!(thought.id, thought_id);\n            assert_eq!(thought.content, content);\n        }\n        _ =\u003e panic!(\"Expected ThoughtFound response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_get_thought_not_found() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let fake_thought_id = ThoughtId::new();\n\n    let response = actor_ref\n        .call(\n            |reply| ThoughtMessage::GetThought {\n                thought_id: fake_thought_id,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to send message\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Error { error }) =\u003e {\n            assert!(matches!(error, AssemblyError::ThoughtNotFound { .. }));\n        }\n        _ =\u003e panic!(\"Expected Error response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_cache_eviction() {\n    // Use a small cache for testing eviction\n    let config = AssemblyConfig {\n        cache_size: 2,\n        max_chain_depth: 50,\n        validate_salience: true,\n    };\n    let actor_ref = spawn_thought_actor_with_config(config).await;\n\n    // Assemble 3 thoughts (cache size is 2, so first will be evicted)\n    let thought1_id = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: AssemblyRequest::new(Content::raw(vec![1]), SalienceScore::neutral()),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought.id,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    let thought2_id = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: AssemblyRequest::new(Content::raw(vec![2]), SalienceScore::neutral()),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought.id,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    let thought3_id = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: AssemblyRequest::new(Content::raw(vec![3]), SalienceScore::neutral()),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought.id,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    // First thought should be evicted\n    let response1 = actor_ref\n        .call(\n            |reply| ThoughtMessage::GetThought {\n                thought_id: thought1_id,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to send message\");\n\n    assert!(matches!(\n        response1,\n        CallResult::Success(ThoughtResponse::Error {\n            error: AssemblyError::ThoughtNotFound { .. }\n        })\n    ));\n\n    // Second and third thoughts should still be cached\n    assert!(matches!(\n        actor_ref\n            .call(\n                |reply| ThoughtMessage::GetThought {\n                    thought_id: thought2_id,\n                    reply\n                },\n                None\n            )\n            .await\n            .expect(\"Failed to send message\"),\n        CallResult::Success(ThoughtResponse::ThoughtFound { .. })\n    ));\n\n    assert!(matches!(\n        actor_ref\n            .call(\n                |reply| ThoughtMessage::GetThought {\n                    thought_id: thought3_id,\n                    reply\n                },\n                None\n            )\n            .await\n            .expect(\"Failed to send message\"),\n        CallResult::Success(ThoughtResponse::ThoughtFound { .. })\n    ));\n}\n\n// ============================================================================\n// Chain Operations Tests\n// ============================================================================\n\n#[tokio::test]\nasync fn test_get_thought_chain_single() {\n    let actor_ref = spawn_thought_actor().await;\n\n    // Create a single thought with no parent\n    let thought_id = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: AssemblyRequest::new(Content::raw(vec![1]), SalienceScore::neutral()),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought.id,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    // Get chain with depth 5\n    let response = actor_ref\n        .call(\n            |reply| ThoughtMessage::GetThoughtChain {\n                thought_id,\n                depth: 5,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to get chain\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::ThoughtChain { thoughts }) =\u003e {\n            assert_eq!(thoughts.len(), 1);\n            assert_eq!(thoughts[0].id, thought_id);\n        }\n        _ =\u003e panic!(\"Expected ThoughtChain response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_get_thought_chain_multiple() {\n    let actor_ref = spawn_thought_actor().await;\n\n    // Create chain: thought1 -\u003e thought2 -\u003e thought3\n    let thought1_id = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: AssemblyRequest::new(Content::raw(vec![1]), SalienceScore::neutral()),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought.id,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    let thought2_id = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: AssemblyRequest::new(Content::raw(vec![2]), SalienceScore::neutral())\n                    .with_parent(thought1_id),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought.id,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    let thought3_id = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: AssemblyRequest::new(Content::raw(vec![3]), SalienceScore::neutral())\n                    .with_parent(thought2_id),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought.id,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    // Get chain from thought3 with depth 10\n    let response = actor_ref\n        .call(\n            |reply| ThoughtMessage::GetThoughtChain {\n                thought_id: thought3_id,\n                depth: 10,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to get chain\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::ThoughtChain { thoughts }) =\u003e {\n            assert_eq!(thoughts.len(), 3);\n            assert_eq!(thoughts[0].id, thought3_id);\n            assert_eq!(thoughts[1].id, thought2_id);\n            assert_eq!(thoughts[2].id, thought1_id);\n        }\n        _ =\u003e panic!(\"Expected ThoughtChain response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_get_thought_chain_depth_limit() {\n    let config = AssemblyConfig {\n        cache_size: 100,\n        max_chain_depth: 5,\n        validate_salience: true,\n    };\n    let actor_ref = spawn_thought_actor_with_config(config).await;\n\n    // Create a simple thought\n    let thought_id = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: AssemblyRequest::new(Content::raw(vec![1]), SalienceScore::neutral()),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought.id,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    // Try to get chain with depth \u003e max_chain_depth\n    let response = actor_ref\n        .call(\n            |reply| ThoughtMessage::GetThoughtChain {\n                thought_id,\n                depth: 10,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to send message\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Error { error }) =\u003e match error {\n            AssemblyError::ChainTooDeep { max_depth } =\u003e {\n                assert_eq!(max_depth, 5);\n            }\n            _ =\u003e panic!(\"Expected ChainTooDeep error, got: {:?}\", error),\n        },\n        _ =\u003e panic!(\"Expected Error response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_get_thought_chain_stops_at_root() {\n    let actor_ref = spawn_thought_actor().await;\n\n    // Create chain: thought1 -\u003e thought2 -\u003e thought3\n    let thought1_id = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: AssemblyRequest::new(Content::raw(vec![1]), SalienceScore::neutral()),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought.id,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    let thought2_id = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: AssemblyRequest::new(Content::raw(vec![2]), SalienceScore::neutral())\n                    .with_parent(thought1_id),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought.id,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    let thought3_id = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: AssemblyRequest::new(Content::raw(vec![3]), SalienceScore::neutral())\n                    .with_parent(thought2_id),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought.id,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    // Get chain with large depth - should stop at root (thought1)\n    let response = actor_ref\n        .call(\n            |reply| ThoughtMessage::GetThoughtChain {\n                thought_id: thought3_id,\n                depth: 50,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to get chain\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::ThoughtChain { thoughts }) =\u003e {\n            // Should only return 3 thoughts, not 50\n            assert_eq!(thoughts.len(), 3);\n            assert_eq!(thoughts[0].id, thought3_id);\n            assert_eq!(thoughts[1].id, thought2_id);\n            assert_eq!(thoughts[2].id, thought1_id);\n        }\n        _ =\u003e panic!(\"Expected ThoughtChain response, got: {:?}\", response),\n    }\n}\n\n// ============================================================================\n// Strategy Tests\n// ============================================================================\n\n#[tokio::test]\nasync fn test_strategy_default() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let content = Content::raw(vec![1, 2, 3]);\n    let request = AssemblyRequest::new(content.clone(), SalienceScore::neutral())\n        .with_strategy(AssemblyStrategy::Default);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to assemble thought\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e {\n            assert_eq!(thought.content, content);\n        }\n        _ =\u003e panic!(\"Expected Assembled response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_strategy_chain_with_parent() {\n    let actor_ref = spawn_thought_actor().await;\n\n    // Create parent thought\n    let parent_id = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: AssemblyRequest::new(Content::raw(vec![1]), SalienceScore::neutral()),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought.id,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    // Create child with Chain strategy\n    let content = Content::raw(vec![2]);\n    let request = AssemblyRequest::new(content.clone(), SalienceScore::neutral())\n        .with_parent(parent_id)\n        .with_strategy(AssemblyStrategy::Chain);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to assemble thought\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e {\n            assert_eq!(thought.content, content);\n            assert_eq!(thought.parent_id, Some(parent_id));\n        }\n        _ =\u003e panic!(\"Expected Assembled response, got: {:?}\", response),\n    }\n}\n\n// ============================================================================\n// Config and State Construction Tests\n// ============================================================================\n\n#[test]\nfn test_assembly_config_new() {\n    let config = AssemblyConfig::new(50, 25, false);\n    assert_eq!(config.cache_size, 50);\n    assert_eq!(config.max_chain_depth, 25);\n    assert!(!config.validate_salience);\n}\n\n#[test]\nfn test_assembly_config_default() {\n    let config = AssemblyConfig::default();\n    assert_eq!(config.cache_size, 100);\n    assert_eq!(config.max_chain_depth, 50);\n    assert!(config.validate_salience);\n}\n\n#[test]\nfn test_thought_state_new() {\n    let state = ThoughtState::new();\n    assert_eq!(state.assembly_count, 0);\n    assert_eq!(state.config.cache_size, 100);\n    assert!(state.config.validate_salience);\n}\n\n#[test]\nfn test_thought_state_default() {\n    let state = ThoughtState::default();\n    assert_eq!(state.assembly_count, 0);\n    assert_eq!(state.config.cache_size, 100);\n}\n\n#[test]\nfn test_thought_state_with_config() {\n    let config = AssemblyConfig::new(10, 5, false);\n    let state = ThoughtState::with_config(config);\n    assert_eq!(state.assembly_count, 0);\n    assert_eq!(state.config.cache_size, 10);\n    assert_eq!(state.config.max_chain_depth, 5);\n    assert!(!state.config.validate_salience);\n}\n\n// ============================================================================\n// Additional Salience Validation Tests (All Ranges)\n// ============================================================================\n\n#[tokio::test]\nasync fn test_assemble_with_negative_importance() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let content = Content::raw(vec![1, 2, 3]);\n    let salience = SalienceScore::new_without_arousal(-0.5, 0.5, 0.5, 0.0, 0.5); // importance \u003c 0.0\n    let request = AssemblyRequest::new(content, salience);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to send message\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Error { error }) =\u003e match error {\n            AssemblyError::InvalidSalience { reason } =\u003e {\n                assert!(reason.contains(\"importance\"));\n            }\n            _ =\u003e panic!(\"Expected InvalidSalience error, got: {:?}\", error),\n        },\n        _ =\u003e panic!(\"Expected Error response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_assemble_with_invalid_novelty_high() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let content = Content::raw(vec![1, 2, 3]);\n    let salience = SalienceScore::new_without_arousal(0.5, 1.5, 0.5, 0.0, 0.5); // novelty \u003e 1.0\n    let request = AssemblyRequest::new(content, salience);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to send message\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Error { error }) =\u003e match error {\n            AssemblyError::InvalidSalience { reason } =\u003e {\n                assert!(reason.contains(\"novelty\"));\n            }\n            _ =\u003e panic!(\"Expected InvalidSalience error, got: {:?}\", error),\n        },\n        _ =\u003e panic!(\"Expected Error response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_assemble_with_invalid_novelty_low() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let content = Content::raw(vec![1, 2, 3]);\n    let salience = SalienceScore::new_without_arousal(0.5, -0.1, 0.5, 0.0, 0.5); // novelty \u003c 0.0\n    let request = AssemblyRequest::new(content, salience);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to send message\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Error { error }) =\u003e match error {\n            AssemblyError::InvalidSalience { reason } =\u003e {\n                assert!(reason.contains(\"novelty\"));\n            }\n            _ =\u003e panic!(\"Expected InvalidSalience error, got: {:?}\", error),\n        },\n        _ =\u003e panic!(\"Expected Error response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_assemble_with_invalid_relevance_high() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let content = Content::raw(vec![1, 2, 3]);\n    let salience = SalienceScore::new_without_arousal(0.5, 0.5, 2.0, 0.0, 0.5); // relevance \u003e 1.0\n    let request = AssemblyRequest::new(content, salience);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to send message\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Error { error }) =\u003e match error {\n            AssemblyError::InvalidSalience { reason } =\u003e {\n                assert!(reason.contains(\"relevance\"));\n            }\n            _ =\u003e panic!(\"Expected InvalidSalience error, got: {:?}\", error),\n        },\n        _ =\u003e panic!(\"Expected Error response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_assemble_with_invalid_relevance_low() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let content = Content::raw(vec![1, 2, 3]);\n    let salience = SalienceScore::new_without_arousal(0.5, 0.5, -0.1, 0.0, 0.5); // relevance \u003c 0.0\n    let request = AssemblyRequest::new(content, salience);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to send message\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Error { error }) =\u003e match error {\n            AssemblyError::InvalidSalience { reason } =\u003e {\n                assert!(reason.contains(\"relevance\"));\n            }\n            _ =\u003e panic!(\"Expected InvalidSalience error, got: {:?}\", error),\n        },\n        _ =\u003e panic!(\"Expected Error response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_assemble_with_invalid_valence_high() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let content = Content::raw(vec![1, 2, 3]);\n    let salience = SalienceScore::new_without_arousal(0.5, 0.5, 0.5, 1.5, 0.5); // valence \u003e 1.0\n    let request = AssemblyRequest::new(content, salience);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to send message\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Error { error }) =\u003e match error {\n            AssemblyError::InvalidSalience { reason } =\u003e {\n                assert!(reason.contains(\"valence\"));\n            }\n            _ =\u003e panic!(\"Expected InvalidSalience error, got: {:?}\", error),\n        },\n        _ =\u003e panic!(\"Expected Error response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_assemble_with_invalid_connection_relevance_high() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let content = Content::raw(vec![1, 2, 3]);\n    let salience = SalienceScore::new_without_arousal(0.5, 0.5, 0.5, 0.0, 1.5); // connection_relevance \u003e 1.0\n    let request = AssemblyRequest::new(content, salience);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to send message\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Error { error }) =\u003e match error {\n            AssemblyError::InvalidSalience { reason } =\u003e {\n                assert!(reason.contains(\"connection_relevance\"));\n            }\n            _ =\u003e panic!(\"Expected InvalidSalience error, got: {:?}\", error),\n        },\n        _ =\u003e panic!(\"Expected Error response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_assemble_with_invalid_connection_relevance_low() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let content = Content::raw(vec![1, 2, 3]);\n    let salience = SalienceScore::new_without_arousal(0.5, 0.5, 0.5, 0.0, -0.1); // connection_relevance \u003c 0.0\n    let request = AssemblyRequest::new(content, salience);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to send message\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Error { error }) =\u003e match error {\n            AssemblyError::InvalidSalience { reason } =\u003e {\n                assert!(reason.contains(\"connection_relevance\"));\n            }\n            _ =\u003e panic!(\"Expected InvalidSalience error, got: {:?}\", error),\n        },\n        _ =\u003e panic!(\"Expected Error response, got: {:?}\", response),\n    }\n}\n\n// ============================================================================\n// Source Stream Tests\n// ============================================================================\n\n#[tokio::test]\nasync fn test_assemble_with_source_stream() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let content = Content::raw(vec![1, 2, 3]);\n    let salience = SalienceScore::neutral();\n    let request = AssemblyRequest::new(content.clone(), salience).with_source(\"external\");\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to assemble thought\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e {\n            assert_eq!(thought.content, content);\n            assert_eq!(thought.source_stream, Some(\"external\".to_string()));\n        }\n        _ =\u003e panic!(\"Expected Assembled response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_assemble_with_source_stream_memory() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let content = Content::raw(vec![42]);\n    let salience = SalienceScore::neutral();\n    let request = AssemblyRequest::new(content, salience).with_source(\"memory\");\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to assemble thought\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e {\n            assert_eq!(thought.source_stream, Some(\"memory\".to_string()));\n        }\n        _ =\u003e panic!(\"Expected Assembled response, got: {:?}\", response),\n    }\n}\n\n// ============================================================================\n// Additional Strategy Tests\n// ============================================================================\n\n#[tokio::test]\nasync fn test_strategy_composite() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let content = Content::raw(vec![1, 2, 3]);\n    let request = AssemblyRequest::new(content.clone(), SalienceScore::neutral())\n        .with_strategy(AssemblyStrategy::Composite);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to assemble thought\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e {\n            assert_eq!(thought.content, content);\n        }\n        _ =\u003e panic!(\"Expected Assembled response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_strategy_urgent() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let content = Content::raw(vec![1, 2, 3]);\n    let request = AssemblyRequest::new(content.clone(), SalienceScore::neutral())\n        .with_strategy(AssemblyStrategy::Urgent);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to assemble thought\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e {\n            assert_eq!(thought.content, content);\n        }\n        _ =\u003e panic!(\"Expected Assembled response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_strategy_chain_without_parent() {\n    let actor_ref = spawn_thought_actor().await;\n\n    // Chain strategy without a parent - should still work\n    let content = Content::raw(vec![1, 2, 3]);\n    let request = AssemblyRequest::new(content.clone(), SalienceScore::neutral())\n        .with_strategy(AssemblyStrategy::Chain);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to assemble thought\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e {\n            assert_eq!(thought.content, content);\n            assert!(thought.parent_id.is_none());\n        }\n        _ =\u003e panic!(\"Expected Assembled response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_strategy_chain_with_parent_not_in_cache() {\n    let actor_ref = spawn_thought_actor().await;\n\n    // Use a non-existent parent ID (parent not in cache)\n    let fake_parent_id = ThoughtId::new();\n\n    let content = Content::raw(vec![1, 2, 3]);\n    let request = AssemblyRequest::new(content.clone(), SalienceScore::neutral())\n        .with_parent(fake_parent_id)\n        .with_strategy(AssemblyStrategy::Chain);\n\n    // This should still succeed - parent not being in cache is not an error\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to assemble thought\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e {\n            assert_eq!(thought.content, content);\n            assert_eq!(thought.parent_id, Some(fake_parent_id));\n        }\n        _ =\u003e panic!(\"Expected Assembled response, got: {:?}\", response),\n    }\n}\n\n// ============================================================================\n// Chain Traversal Edge Cases\n// ============================================================================\n\n#[tokio::test]\nasync fn test_get_thought_chain_broken_chain() {\n    let actor_ref = spawn_thought_actor().await;\n\n    // Create a thought with a parent that doesn't exist (simulating a broken chain)\n    let fake_parent_id = ThoughtId::new();\n    let content = Content::raw(vec![1]);\n    let request =\n        AssemblyRequest::new(content, SalienceScore::neutral()).with_parent(fake_parent_id);\n\n    let thought_id = match actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought.id,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    // Try to get chain with depth \u003e 1 (should fail because parent doesn't exist)\n    let response = actor_ref\n        .call(\n            |reply| ThoughtMessage::GetThoughtChain {\n                thought_id,\n                depth: 2,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to get chain\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Error { error }) =\u003e {\n            assert!(matches!(error, AssemblyError::ThoughtNotFound { .. }));\n        }\n        _ =\u003e panic!(\n            \"Expected Error response with ThoughtNotFound, got: {:?}\",\n            response\n        ),\n    }\n}\n\n#[tokio::test]\nasync fn test_get_thought_chain_zero_depth() {\n    let actor_ref = spawn_thought_actor().await;\n\n    // Create a thought\n    let thought_id = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: AssemblyRequest::new(Content::raw(vec![1]), SalienceScore::neutral()),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought.id,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    // Get chain with depth 0 - should return empty chain\n    let response = actor_ref\n        .call(\n            |reply| ThoughtMessage::GetThoughtChain {\n                thought_id,\n                depth: 0,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to get chain\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::ThoughtChain { thoughts }) =\u003e {\n            assert_eq!(thoughts.len(), 0);\n        }\n        _ =\u003e panic!(\"Expected ThoughtChain response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_get_thought_chain_depth_limited_by_param() {\n    let actor_ref = spawn_thought_actor().await;\n\n    // Create chain: thought1 -\u003e thought2 -\u003e thought3\n    let thought1_id = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: AssemblyRequest::new(Content::raw(vec![1]), SalienceScore::neutral()),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought.id,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    let thought2_id = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: AssemblyRequest::new(Content::raw(vec![2]), SalienceScore::neutral())\n                    .with_parent(thought1_id),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought.id,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    let thought3_id = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: AssemblyRequest::new(Content::raw(vec![3]), SalienceScore::neutral())\n                    .with_parent(thought2_id),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought.id,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    // Get chain from thought3 with depth 2 (should return only thought3 and thought2)\n    let response = actor_ref\n        .call(\n            |reply| ThoughtMessage::GetThoughtChain {\n                thought_id: thought3_id,\n                depth: 2,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to get chain\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::ThoughtChain { thoughts }) =\u003e {\n            assert_eq!(thoughts.len(), 2);\n            assert_eq!(thoughts[0].id, thought3_id);\n            assert_eq!(thoughts[1].id, thought2_id);\n            // thought1 not included due to depth limit\n        }\n        _ =\u003e panic!(\"Expected ThoughtChain response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn test_get_thought_chain_not_found() {\n    let actor_ref = spawn_thought_actor().await;\n\n    let fake_thought_id = ThoughtId::new();\n\n    let response = actor_ref\n        .call(\n            |reply| ThoughtMessage::GetThoughtChain {\n                thought_id: fake_thought_id,\n                depth: 5,\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to send message\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Error { error }) =\u003e {\n            assert!(matches!(error, AssemblyError::ThoughtNotFound { .. }));\n        }\n        _ =\u003e panic!(\"Expected Error response, got: {:?}\", response),\n    }\n}\n\n// ============================================================================\n// Assembly Count and State Tests\n// ============================================================================\n\n#[test]\nfn test_assembly_count_increments() {\n    let mut state = ThoughtState::new();\n\n    let content1 = Content::raw(vec![1]);\n    let content2 = Content::raw(vec![2]);\n    let salience = SalienceScore::neutral();\n\n    assert_eq!(state.assembly_count, 0);\n\n    let _ = state.assemble_thought(AssemblyRequest::new(content1, salience));\n    assert_eq!(state.assembly_count, 1);\n\n    let _ = state.assemble_thought(AssemblyRequest::new(content2, salience));\n    assert_eq!(state.assembly_count, 2);\n}\n\n#[test]\nfn test_assembly_count_not_incremented_on_error() {\n    let mut state = ThoughtState::new();\n\n    assert_eq!(state.assembly_count, 0);\n\n    // Empty content should fail\n    let result = state.assemble_thought(AssemblyRequest::new(\n        Content::Empty,\n        SalienceScore::neutral(),\n    ));\n    assert!(result.is_err());\n    assert_eq!(state.assembly_count, 0);\n}\n\n// ============================================================================\n// Direct State Method Tests\n// ============================================================================\n\n#[test]\nfn test_state_assemble_thought_directly() {\n    let mut state = ThoughtState::new();\n\n    let content = Content::raw(vec![1, 2, 3]);\n    let salience = SalienceScore::neutral();\n    let request = AssemblyRequest::new(content.clone(), salience);\n\n    let result = state.assemble_thought(request);\n    assert!(result.is_ok());\n    let thought = result.unwrap();\n    assert_eq!(thought.content, content);\n}\n\n#[test]\nfn test_state_assemble_batch_directly() {\n    let mut state = ThoughtState::new();\n\n    let requests = vec![\n        AssemblyRequest::new(Content::raw(vec![1]), SalienceScore::neutral()),\n        AssemblyRequest::new(Content::raw(vec![2]), SalienceScore::neutral()),\n    ];\n\n    let result = state.assemble_batch(requests);\n    assert!(result.is_ok());\n    let thoughts = result.unwrap();\n    assert_eq!(thoughts.len(), 2);\n}\n\n#[test]\nfn test_state_get_thought_directly() {\n    let mut state = ThoughtState::new();\n\n    let content = Content::raw(vec![1, 2, 3]);\n    let request = AssemblyRequest::new(content.clone(), SalienceScore::neutral());\n\n    let thought = state.assemble_thought(request).unwrap();\n    let thought_id = thought.id;\n\n    let result = state.get_thought(\u0026thought_id);\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap().id, thought_id);\n}\n\n#[test]\nfn test_state_get_thought_chain_directly() {\n    let mut state = ThoughtState::new();\n\n    // Create parent\n    let parent_request = AssemblyRequest::new(Content::raw(vec![1]), SalienceScore::neutral());\n    let parent = state.assemble_thought(parent_request).unwrap();\n\n    // Create child\n    let child_request = AssemblyRequest::new(Content::raw(vec![2]), SalienceScore::neutral())\n        .with_parent(parent.id);\n    let child = state.assemble_thought(child_request).unwrap();\n\n    // Get chain\n    let result = state.get_thought_chain(child.id, 10);\n    assert!(result.is_ok());\n    let chain = result.unwrap();\n    assert_eq!(chain.len(), 2);\n    assert_eq!(chain[0].id, child.id);\n    assert_eq!(chain[1].id, parent.id);\n}\n\n#[test]\nfn test_state_validate_salience_edge_values() {\n    let state = ThoughtState::new();\n\n    // Test boundary values (should all pass)\n    let valid_salience = SalienceScore::new_without_arousal(0.0, 0.0, 0.0, -1.0, 0.0);\n    assert!(state.validate_salience(\u0026valid_salience).is_ok());\n\n    let valid_salience = SalienceScore::new_without_arousal(1.0, 1.0, 1.0, 1.0, 1.0);\n    assert!(state.validate_salience(\u0026valid_salience).is_ok());\n\n    let valid_salience = SalienceScore::new_without_arousal(0.5, 0.5, 0.5, 0.0, 0.5);\n    assert!(state.validate_salience(\u0026valid_salience).is_ok());\n}\n\n// ============================================================================\n// Combined Builder Patterns\n// ============================================================================\n\n#[tokio::test]\nasync fn test_assemble_with_all_options() {\n    let actor_ref = spawn_thought_actor().await;\n\n    // Create parent first\n    let parent_id = match actor_ref\n        .call(\n            |reply| ThoughtMessage::Assemble {\n                request: AssemblyRequest::new(Content::raw(vec![1]), SalienceScore::neutral()),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to assemble\")\n    {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e thought.id,\n        _ =\u003e panic!(\"Expected Assembled response\"),\n    };\n\n    // Create child with all options\n    let content = Content::symbol(\"test\", vec![2, 3, 4]);\n    let salience = SalienceScore::new_without_arousal(0.9, 0.8, 0.7, 0.5, 0.6);\n    let request = AssemblyRequest::new(content.clone(), salience)\n        .with_parent(parent_id)\n        .with_source(\"internal\")\n        .with_strategy(AssemblyStrategy::Chain);\n\n    let response = actor_ref\n        .call(|reply| ThoughtMessage::Assemble { request, reply }, None)\n        .await\n        .expect(\"Failed to assemble thought\");\n\n    match response {\n        CallResult::Success(ThoughtResponse::Assembled { thought }) =\u003e {\n            assert_eq!(thought.content, content);\n            assert_eq!(thought.salience, salience);\n            assert_eq!(thought.parent_id, Some(parent_id));\n            assert_eq!(thought.source_stream, Some(\"internal\".to_string()));\n        }\n        _ =\u003e panic!(\"Expected Assembled response, got: {:?}\", response),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","thought","types.rs"],"content":"//! Thought Assembly Actor Types\n//!\n//! Message and response types for the ThoughtAssemblyActor.\n//!\n//! # TMI Concept: \"Construo do Pensamento\" (Thought Construction)\n//!\n//! The ThoughtAssemblyActor is the final stage before consciousness. It takes\n//! raw content (from competition) and emotional state (salience) and assembles\n//! them into coherent Thought objects. This is where pre-linguistic patterns\n//! become structured cognitive units.\n//!\n//! Key responsibilities:\n//! - Assemble content + salience into Thought objects\n//! - Link thoughts into chains (parent-child relationships)\n//! - Cache recently assembled thoughts for quick retrieval\n//! - Support batch assembly for efficiency\n\nuse crate::core::types::{Content, SalienceScore, Thought, ThoughtId};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse thiserror::Error;\n\n/// Messages that can be sent to the ThoughtAssemblyActor\n#[derive(Debug)]\npub enum ThoughtMessage {\n    /// Assemble a single thought from content and emotion\n    Assemble {\n        /// Assembly request with content and salience\n        request: AssemblyRequest,\n        /// Response channel\n        reply: ractor::RpcReplyPort\u003cThoughtResponse\u003e,\n    },\n\n    /// Assemble multiple thoughts in a batch\n    AssembleBatch {\n        /// Multiple assembly requests\n        requests: Vec\u003cAssemblyRequest\u003e,\n        /// Response channel\n        reply: ractor::RpcReplyPort\u003cThoughtResponse\u003e,\n    },\n\n    /// Retrieve a previously assembled thought by ID\n    GetThought {\n        /// ID of the thought to retrieve\n        thought_id: ThoughtId,\n        /// Response channel\n        reply: ractor::RpcReplyPort\u003cThoughtResponse\u003e,\n    },\n\n    /// Get a thought and its ancestry chain\n    GetThoughtChain {\n        /// ID of the thought to start from\n        thought_id: ThoughtId,\n        /// Maximum depth to traverse (prevents infinite loops)\n        depth: usize,\n        /// Response channel\n        reply: ractor::RpcReplyPort\u003cThoughtResponse\u003e,\n    },\n}\n\n/// Responses from the ThoughtAssemblyActor\n#[derive(Debug, Clone, PartialEq)]\npub enum ThoughtResponse {\n    /// Single thought successfully assembled\n    Assembled {\n        /// The newly assembled thought\n        thought: Thought,\n    },\n\n    /// Multiple thoughts successfully assembled\n    BatchAssembled {\n        /// All assembled thoughts\n        thoughts: Vec\u003cThought\u003e,\n    },\n\n    /// Thought found in cache or storage\n    ThoughtFound {\n        /// The retrieved thought\n        thought: Thought,\n    },\n\n    /// Thought chain retrieved (child to ancestors)\n    ThoughtChain {\n        /// Thoughts in the chain, starting with the requested thought\n        /// followed by its parent, grandparent, etc.\n        thoughts: Vec\u003cThought\u003e,\n    },\n\n    /// Assembly operation failed\n    Error {\n        /// The error that occurred\n        error: AssemblyError,\n    },\n}\n\n/// Request to assemble a thought\n///\n/// This is the input to the thought construction process. It contains\n/// raw content (pre-linguistic patterns) and emotional coloring (salience).\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct AssemblyRequest {\n    /// The content to assemble into a thought\n    pub content: Content,\n\n    /// Salience score (emotional coloring)\n    pub salience: SalienceScore,\n\n    /// Optional parent thought (for chained thoughts)\n    pub parent_id: Option\u003cThoughtId\u003e,\n\n    /// Optional source stream identifier (which content stream won)\n    pub source_stream: Option\u003cString\u003e,\n\n    /// Assembly strategy to use\n    pub strategy: AssemblyStrategy,\n}\n\nimpl AssemblyRequest {\n    /// Create a new assembly request with default strategy\n    ///\n    /// # Arguments\n    /// * `content` - The pre-linguistic content to assemble\n    /// * `salience` - Emotional/importance weighting\n    #[must_use]\n    pub fn new(content: Content, salience: SalienceScore) -\u003e Self {\n        Self {\n            content,\n            salience,\n            parent_id: None,\n            source_stream: None,\n            strategy: AssemblyStrategy::Default,\n        }\n    }\n\n    /// Link this thought to a parent thought\n    ///\n    /// This creates a thought chain, allowing thoughts to reference\n    /// their causal history.\n    #[must_use]\n    pub fn with_parent(mut self, parent_id: ThoughtId) -\u003e Self {\n        self.parent_id = Some(parent_id);\n        self\n    }\n\n    /// Tag this thought with its source stream\n    ///\n    /// Records which content stream (e.g., \"external\", \"memory\", \"internal\")\n    /// produced the winning content.\n    #[must_use]\n    pub fn with_source(mut self, source: impl Into\u003cString\u003e) -\u003e Self {\n        self.source_stream = Some(source.into());\n        self\n    }\n\n    /// Set the assembly strategy\n    #[must_use]\n    pub fn with_strategy(mut self, strategy: AssemblyStrategy) -\u003e Self {\n        self.strategy = strategy;\n        self\n    }\n}\n\n/// Strategy for assembling thoughts\n///\n/// Different strategies affect how content is processed during assembly.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]\npub enum AssemblyStrategy {\n    /// Standard assembly - simple content + salience -\u003e thought\n    #[default]\n    Default,\n\n    /// Merge multiple content elements into a composite\n    Composite,\n\n    /// Link to parent and propagate salience\n    Chain,\n\n    /// High-priority assembly (skip normal queuing)\n    Urgent,\n}\n\n/// Errors that can occur during thought assembly\n#[derive(Debug, Clone, Error, PartialEq)]\npub enum AssemblyError {\n    /// Attempted to assemble empty content\n    #[error(\"Cannot assemble empty content\")]\n    EmptyContent,\n\n    /// Invalid salience score provided\n    #[error(\"Invalid salience score: {reason}\")]\n    InvalidSalience {\n        /// Explanation of why salience is invalid\n        reason: String,\n    },\n\n    /// Thought not found in cache or storage\n    #[error(\"Thought not found: {thought_id}\")]\n    ThoughtNotFound {\n        /// ID of the missing thought\n        thought_id: ThoughtId,\n    },\n\n    /// Thought chain exceeds maximum depth\n    #[error(\"Thought chain too deep: maximum depth is {max_depth}\")]\n    ChainTooDeep {\n        /// Maximum allowed depth\n        max_depth: usize,\n    },\n\n    /// General assembly failure\n    #[error(\"Assembly failed: {reason}\")]\n    AssemblyFailed {\n        /// Explanation of the failure\n        reason: String,\n    },\n}\n\n/// Cache for recently assembled thoughts\n///\n/// TMI's thought assembly is stateful - we need quick access to recent thoughts\n/// for chaining and retrieval. This cache stores thoughts in memory with a\n/// bounded size to prevent unbounded growth.\n#[derive(Debug, Clone)]\npub struct ThoughtCache {\n    /// Internal storage mapping ThoughtId to Thought\n    cache: HashMap\u003cThoughtId, Thought\u003e,\n\n    /// Maximum number of thoughts to cache\n    max_size: usize,\n\n    /// Insertion order tracking for LRU eviction\n    insertion_order: Vec\u003cThoughtId\u003e,\n}\n\nimpl ThoughtCache {\n    /// Create a new thought cache with specified capacity\n    ///\n    /// # Arguments\n    /// * `max_size` - Maximum number of thoughts to cache\n    #[must_use]\n    pub fn new(max_size: usize) -\u003e Self {\n        Self {\n            cache: HashMap::with_capacity(max_size),\n            max_size,\n            insertion_order: Vec::with_capacity(max_size),\n        }\n    }\n\n    /// Insert a thought into the cache\n    ///\n    /// If the cache is full, evicts the oldest thought first.\n    /// If the thought already exists, updates it and moves it to the end.\n    pub fn insert(\u0026mut self, thought: Thought) {\n        let thought_id = thought.id;\n\n        // Remove from insertion order if already present\n        if let Some(pos) = self.insertion_order.iter().position(|id| *id == thought_id) {\n            self.insertion_order.remove(pos);\n        }\n\n        // Evict oldest if at capacity\n        if self.cache.len() \u003e= self.max_size \u0026\u0026 !self.cache.contains_key(\u0026thought_id) {\n            self.evict_oldest();\n        }\n\n        // Insert and track order\n        self.cache.insert(thought_id, thought);\n        self.insertion_order.push(thought_id);\n    }\n\n    /// Retrieve a thought from the cache\n    ///\n    /// # Arguments\n    /// * `thought_id` - ID of the thought to retrieve\n    ///\n    /// # Returns\n    /// * `Some(Thought)` if found, `None` otherwise\n    #[must_use]\n    pub fn get(\u0026self, thought_id: \u0026ThoughtId) -\u003e Option\u003c\u0026Thought\u003e {\n        self.cache.get(thought_id)\n    }\n\n    /// Evict the oldest thought from the cache\n    ///\n    /// This is called automatically when the cache reaches capacity.\n    fn evict_oldest(\u0026mut self) {\n        if let Some(oldest_id) = self.insertion_order.first().copied() {\n            self.cache.remove(\u0026oldest_id);\n            self.insertion_order.remove(0);\n        }\n    }\n\n    /// Get the current number of cached thoughts\n    #[must_use]\n    pub fn len(\u0026self) -\u003e usize {\n        self.cache.len()\n    }\n\n    /// Check if the cache is empty\n    #[must_use]\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.cache.is_empty()\n    }\n\n    /// Clear all thoughts from the cache\n    pub fn clear(\u0026mut self) {\n        self.cache.clear();\n        self.insertion_order.clear();\n    }\n}\n\nimpl Default for ThoughtCache {\n    fn default() -\u003e Self {\n        // Default cache size: 100 thoughts\n        Self::new(100)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn assembly_request_creation() {\n        let content = Content::raw(vec![1, 2, 3]);\n        let salience = SalienceScore::neutral();\n        let request = AssemblyRequest::new(content.clone(), salience);\n\n        assert_eq!(request.content, content);\n        assert_eq!(request.salience, salience);\n        assert!(request.parent_id.is_none());\n        assert!(request.source_stream.is_none());\n        assert_eq!(request.strategy, AssemblyStrategy::Default);\n    }\n\n    #[test]\n    fn assembly_request_with_parent() {\n        let content = Content::raw(vec![1, 2, 3]);\n        let salience = SalienceScore::neutral();\n        let parent_id = ThoughtId::new();\n        let request = AssemblyRequest::new(content, salience).with_parent(parent_id);\n\n        assert_eq!(request.parent_id, Some(parent_id));\n    }\n\n    #[test]\n    fn assembly_request_with_source() {\n        let content = Content::raw(vec![1, 2, 3]);\n        let salience = SalienceScore::neutral();\n        let request = AssemblyRequest::new(content, salience).with_source(\"memory\");\n\n        assert_eq!(request.source_stream, Some(\"memory\".to_string()));\n    }\n\n    #[test]\n    fn assembly_request_with_strategy() {\n        let content = Content::raw(vec![1, 2, 3]);\n        let salience = SalienceScore::neutral();\n        let request =\n            AssemblyRequest::new(content, salience).with_strategy(AssemblyStrategy::Urgent);\n\n        assert_eq!(request.strategy, AssemblyStrategy::Urgent);\n    }\n\n    #[test]\n    fn assembly_request_builder_chain() {\n        let content = Content::raw(vec![1, 2, 3]);\n        let salience = SalienceScore::neutral();\n        let parent_id = ThoughtId::new();\n\n        let request = AssemblyRequest::new(content.clone(), salience)\n            .with_parent(parent_id)\n            .with_source(\"external\")\n            .with_strategy(AssemblyStrategy::Chain);\n\n        assert_eq!(request.content, content);\n        assert_eq!(request.parent_id, Some(parent_id));\n        assert_eq!(request.source_stream, Some(\"external\".to_string()));\n        assert_eq!(request.strategy, AssemblyStrategy::Chain);\n    }\n\n    #[test]\n    fn thought_cache_creation() {\n        let cache = ThoughtCache::new(10);\n        assert_eq!(cache.max_size, 10);\n        assert!(cache.is_empty());\n        assert_eq!(cache.len(), 0);\n    }\n\n    #[test]\n    fn thought_cache_insert_and_get() {\n        let mut cache = ThoughtCache::new(10);\n        let thought = Thought::new(Content::raw(vec![1, 2, 3]), SalienceScore::neutral());\n        let thought_id = thought.id;\n\n        cache.insert(thought);\n        assert_eq!(cache.len(), 1);\n\n        let retrieved = cache.get(\u0026thought_id);\n        assert!(retrieved.is_some());\n        assert_eq!(retrieved.unwrap().id, thought_id);\n    }\n\n    #[test]\n    fn thought_cache_eviction() {\n        let mut cache = ThoughtCache::new(2);\n\n        let thought1 = Thought::new(Content::raw(vec![1]), SalienceScore::neutral());\n        let thought2 = Thought::new(Content::raw(vec![2]), SalienceScore::neutral());\n        let thought3 = Thought::new(Content::raw(vec![3]), SalienceScore::neutral());\n\n        let id1 = thought1.id;\n        let id2 = thought2.id;\n        let id3 = thought3.id;\n\n        cache.insert(thought1);\n        cache.insert(thought2);\n        assert_eq!(cache.len(), 2);\n\n        // Insert third thought, should evict first\n        cache.insert(thought3);\n        assert_eq!(cache.len(), 2);\n        assert!(cache.get(\u0026id1).is_none());\n        assert!(cache.get(\u0026id2).is_some());\n        assert!(cache.get(\u0026id3).is_some());\n    }\n\n    #[test]\n    fn thought_cache_update_existing() {\n        let mut cache = ThoughtCache::new(2);\n\n        let thought1 = Thought::new(Content::raw(vec![1]), SalienceScore::neutral());\n        let thought2 = Thought::new(Content::raw(vec![2]), SalienceScore::neutral());\n\n        let id1 = thought1.id;\n        let id2 = thought2.id;\n\n        cache.insert(thought1.clone());\n        cache.insert(thought2);\n        assert_eq!(cache.len(), 2);\n\n        // Re-insert first thought (should move to end)\n        cache.insert(thought1);\n        assert_eq!(cache.len(), 2);\n\n        // Insert third thought\n        let thought3 = Thought::new(Content::raw(vec![3]), SalienceScore::neutral());\n        let id3 = thought3.id;\n        cache.insert(thought3);\n\n        // First thought should remain (it was moved to end)\n        // Second thought should be evicted\n        assert_eq!(cache.len(), 2);\n        assert!(cache.get(\u0026id1).is_some());\n        assert!(cache.get(\u0026id2).is_none());\n        assert!(cache.get(\u0026id3).is_some());\n    }\n\n    #[test]\n    fn thought_cache_clear() {\n        let mut cache = ThoughtCache::new(10);\n\n        for i in 0..5 {\n            let thought = Thought::new(Content::raw(vec![i]), SalienceScore::neutral());\n            cache.insert(thought);\n        }\n\n        assert_eq!(cache.len(), 5);\n        cache.clear();\n        assert!(cache.is_empty());\n        assert_eq!(cache.len(), 0);\n    }\n\n    #[test]\n    fn assembly_error_display() {\n        let error = AssemblyError::EmptyContent;\n        let message = format!(\"{}\", error);\n        assert!(message.contains(\"empty content\"));\n\n        let error = AssemblyError::InvalidSalience {\n            reason: \"negative values\".to_string(),\n        };\n        let message = format!(\"{}\", error);\n        assert!(message.contains(\"Invalid salience\"));\n        assert!(message.contains(\"negative values\"));\n\n        let thought_id = ThoughtId::new();\n        let error = AssemblyError::ThoughtNotFound { thought_id };\n        let message = format!(\"{}\", error);\n        assert!(message.contains(\"not found\"));\n\n        let error = AssemblyError::ChainTooDeep { max_depth: 10 };\n        let message = format!(\"{}\", error);\n        assert!(message.contains(\"too deep\"));\n        assert!(message.contains(\"10\"));\n    }\n\n    #[test]\n    fn assembly_strategy_default() {\n        let strategy = AssemblyStrategy::default();\n        assert_eq!(strategy, AssemblyStrategy::Default);\n    }\n\n    #[test]\n    fn assembly_strategy_variants() {\n        // Ensure all variants are distinct and comparable\n        let default = AssemblyStrategy::Default;\n        let composite = AssemblyStrategy::Composite;\n        let chain = AssemblyStrategy::Chain;\n        let urgent = AssemblyStrategy::Urgent;\n\n        assert_ne!(default, composite);\n        assert_ne!(default, chain);\n        assert_ne!(default, urgent);\n        assert_ne!(composite, chain);\n        assert_ne!(composite, urgent);\n        assert_ne!(chain, urgent);\n\n        // Test Copy trait\n        let copied = composite;\n        assert_eq!(copied, AssemblyStrategy::Composite);\n    }\n\n    #[test]\n    fn thought_response_equality() {\n        let thought1 = Thought::new(Content::raw(vec![1]), SalienceScore::neutral());\n        let thought2 = thought1.clone();\n        let thought3 = thought1.clone();\n        let thought4 = thought1.clone();\n\n        let response1 = ThoughtResponse::Assembled { thought: thought1 };\n        let response2 = ThoughtResponse::Assembled { thought: thought2 };\n\n        assert_eq!(response1, response2);\n\n        let batch1 = ThoughtResponse::BatchAssembled {\n            thoughts: vec![thought3],\n        };\n        let batch2 = ThoughtResponse::BatchAssembled {\n            thoughts: vec![thought4],\n        };\n\n        assert_eq!(batch1, batch2);\n    }\n\n    #[test]\n    fn assembly_error_assembly_failed_display() {\n        let error = AssemblyError::AssemblyFailed {\n            reason: \"timeout occurred\".to_string(),\n        };\n        let message = format!(\"{}\", error);\n        assert!(message.contains(\"Assembly failed\"));\n        assert!(message.contains(\"timeout occurred\"));\n    }\n\n    #[test]\n    fn thought_response_thought_found() {\n        let thought = Thought::new(Content::raw(vec![1]), SalienceScore::neutral());\n        let response1 = ThoughtResponse::ThoughtFound {\n            thought: thought.clone(),\n        };\n        let response2 = ThoughtResponse::ThoughtFound { thought };\n\n        assert_eq!(response1, response2);\n    }\n\n    #[test]\n    fn thought_response_thought_chain() {\n        let thought1 = Thought::new(Content::raw(vec![1]), SalienceScore::neutral());\n        let thought2 = Thought::new(Content::raw(vec![2]), SalienceScore::neutral());\n\n        let response1 = ThoughtResponse::ThoughtChain {\n            thoughts: vec![thought1.clone(), thought2.clone()],\n        };\n        let response2 = ThoughtResponse::ThoughtChain {\n            thoughts: vec![thought1, thought2],\n        };\n\n        assert_eq!(response1, response2);\n    }\n\n    #[test]\n    fn thought_response_error() {\n        let error = AssemblyError::EmptyContent;\n        let response1 = ThoughtResponse::Error {\n            error: error.clone(),\n        };\n        let response2 = ThoughtResponse::Error { error };\n\n        assert_eq!(response1, response2);\n    }\n\n    #[test]\n    fn thought_cache_default() {\n        let cache = ThoughtCache::default();\n        assert_eq!(cache.max_size, 100);\n        assert!(cache.is_empty());\n    }\n}\n","traces":[{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":36},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","volition","mod.rs"],"content":"//! VolitionActor - TMI's Free-Won't Implementation\n//!\n//! Implements TMI's \"Tcnica DCD\" (Doubt-Criticize-Decide) and Libet's \"free-won't\":\n//! - Evaluates thoughts before memory anchoring\n//! - Vetoes thoughts that violate committed values\n//! - Enables conscious override of automatic impulses\n//!\n//! # TMI Concept: The Intervention Window\n//!\n//! In Cury's Theory of Multifocal Intelligence, there's a 5-second window\n//! between thought formation and memory anchoring where conscious intervention\n//! is possible. The VolitionActor operates in this window.\n//!\n//! # Stage 4.5: Between Assembly and Anchor\n//!\n//! ```text\n//! Stage 3: Attention selects winner\n//!          \n//! Stage 4: Assembly creates Thought\n//!          \n//! \n//!    VOLITION ACTOR (Stage 4.5)      THIS ACTOR\n//!                                  \n//!    Check against committed values\n//!    Apply conscious override\n//!    Exercise free-won't (veto)\n//! \n//!          \n//! Stage 5: Anchor (only if not vetoed)\n//! ```\n//!\n//! # The Distinction\n//!\n//! | Mechanism | What It Does | When It Acts |\n//! |-----------|--------------|--------------|\n//! | Connection Drive | Biases attention toward connection | Stage 3 (selection) |\n//! | THE BOX | Blocks harmful actions | Action layer (output) |\n//! | VolitionActor | Vetoes thoughts before memory | Stage 4.5 (internal) |\n//!\n//! The VolitionActor operates on *internal* cognition, not external behavior.\n\npub mod types;\n\nuse crate::core::types::{Content, Thought};\nuse ractor::{Actor, ActorProcessingErr, ActorRef};\n\n// Re-export types for public API\npub use types::{\n    Commitment, ValueSet, VetoDecision, VolitionError, VolitionMessage, VolitionResponse,\n    VolitionStats,\n};\n\n/// Configuration for volition behavior\n#[derive(Debug, Clone, PartialEq)]\n#[allow(clippy::struct_excessive_bools)] // These are distinct feature flags\npub struct VolitionConfig {\n    /// Override threshold: below this salience, thoughts are auto-vetoed\n    /// Range: 0.0 (very permissive) to 1.0 (very strict)\n    pub override_threshold: f32,\n\n    /// Enable harm detection (checks for harmful content patterns)\n    pub harm_detection_enabled: bool,\n\n    /// Enable deception detection (checks for deceptive patterns)\n    pub deception_detection_enabled: bool,\n\n    /// Enable manipulation detection (checks for manipulative patterns)\n    pub manipulation_detection_enabled: bool,\n\n    /// Log all veto decisions for debugging\n    pub log_vetos: bool,\n}\n\nimpl Default for VolitionConfig {\n    fn default() -\u003e Self {\n        Self {\n            override_threshold: 0.3, // Relatively permissive default\n            harm_detection_enabled: true,\n            deception_detection_enabled: true,\n            manipulation_detection_enabled: true,\n            log_vetos: true,\n        }\n    }\n}\n\n/// State maintained by the VolitionActor\n#[derive(Debug, Clone)]\npub struct VolitionState {\n    /// Core values this system commits to\n    pub values: ValueSet,\n\n    /// Statistics about veto decisions\n    pub stats: VolitionStats,\n\n    /// Configuration for veto behavior\n    pub config: VolitionConfig,\n}\n\nimpl VolitionState {\n    /// Create new state with default configuration\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self {\n            values: ValueSet::new(),\n            stats: VolitionStats::new(),\n            config: VolitionConfig::default(),\n        }\n    }\n\n    /// Create state with custom configuration\n    #[must_use]\n    pub fn with_config(config: VolitionConfig) -\u003e Self {\n        Self {\n            values: ValueSet::new(),\n            stats: VolitionStats::new(),\n            config,\n        }\n    }\n\n    /// Evaluate a thought and decide whether to veto\n    ///\n    /// This is the core veto logic implementing TMI's Tcnica DCD:\n    /// 1. Doubt: Is this thought consistent with values?\n    /// 2. Criticize: Does it violate any commitments?\n    /// 3. Decide: Allow or veto\n    pub fn evaluate_thought(\u0026mut self, thought: \u0026Thought) -\u003e VetoDecision {\n        // Check against core values\n        if let Some(decision) = self.check_core_values(thought) {\n            self.stats\n                .record_evaluation(false, Some(\u0026format!(\"{:?}\", decision)));\n            return decision;\n        }\n\n        // Check against harm patterns\n        if self.config.harm_detection_enabled {\n            if let Some(decision) = self.check_harm_patterns(thought) {\n                self.stats.record_evaluation(false, Some(\"harm\"));\n                return decision;\n            }\n        }\n\n        // Check against deception patterns\n        if self.config.deception_detection_enabled {\n            if let Some(decision) = self.check_deception_patterns(thought) {\n                self.stats.record_evaluation(false, Some(\"deception\"));\n                return decision;\n            }\n        }\n\n        // Check against manipulation patterns\n        if self.config.manipulation_detection_enabled {\n            if let Some(decision) = self.check_manipulation_patterns(thought) {\n                self.stats.record_evaluation(false, Some(\"manipulation\"));\n                return decision;\n            }\n        }\n\n        // Check against custom commitments\n        if let Some(decision) = self.check_commitments(thought) {\n            self.stats.record_evaluation(false, Some(\"commitment\"));\n            return decision;\n        }\n\n        // All checks passed\n        self.stats.record_evaluation(true, None);\n        VetoDecision::Allow\n    }\n\n    /// Check thought against core immutable values\n    fn check_core_values(\u0026self, thought: \u0026Thought) -\u003e Option\u003cVetoDecision\u003e {\n        // Law 1: Never harm humans\n        if self.values.protect_humans \u0026\u0026 self.detects_harm_intent(thought) {\n            return Some(VetoDecision::Veto {\n                reason: \"Thought would lead to human harm\".to_string(),\n                violated_value: Some(\"protect_humans\".to_string()),\n            });\n        }\n\n        None\n    }\n\n    /// Check for harm patterns in thought content\n    fn check_harm_patterns(\u0026self, thought: \u0026Thought) -\u003e Option\u003cVetoDecision\u003e {\n        // Check content for harm indicators\n        if self.content_contains_harm_keywords(\u0026thought.content) {\n            return Some(VetoDecision::Veto {\n                reason: \"Content contains harmful patterns\".to_string(),\n                violated_value: Some(\"protect_humans\".to_string()),\n            });\n        }\n\n        None\n    }\n\n    /// Check for deception patterns\n    fn check_deception_patterns(\u0026self, thought: \u0026Thought) -\u003e Option\u003cVetoDecision\u003e {\n        if !self.values.truthfulness {\n            return None;\n        }\n\n        // Check for deception indicators\n        if self.content_contains_deception_keywords(\u0026thought.content) {\n            return Some(VetoDecision::Veto {\n                reason: \"Content contains deceptive patterns\".to_string(),\n                violated_value: Some(\"truthfulness\".to_string()),\n            });\n        }\n\n        None\n    }\n\n    /// Check for manipulation patterns\n    fn check_manipulation_patterns(\u0026self, thought: \u0026Thought) -\u003e Option\u003cVetoDecision\u003e {\n        if !self.values.respect_autonomy {\n            return None;\n        }\n\n        // Check for manipulation indicators\n        if self.content_contains_manipulation_keywords(\u0026thought.content) {\n            return Some(VetoDecision::Veto {\n                reason: \"Content contains manipulative patterns\".to_string(),\n                violated_value: Some(\"respect_autonomy\".to_string()),\n            });\n        }\n\n        None\n    }\n\n    /// Check against custom commitments\n    fn check_commitments(\u0026self, _thought: \u0026Thought) -\u003e Option\u003cVetoDecision\u003e {\n        // Future: Check each commitment\n        // For now, no additional commitment checks\n        None\n    }\n\n    /// Detect if thought has harm intent\n    fn detects_harm_intent(\u0026self, thought: \u0026Thought) -\u003e bool {\n        // Check salience for harm indicators\n        // High connection_relevance + negative valence might indicate harm\n        let has_negative_valence = thought.salience.valence \u003c -0.7;\n        let has_high_arousal = thought.salience.arousal \u003e 0.8;\n\n        // High arousal + very negative valence is concerning\n        has_negative_valence\n            \u0026\u0026 has_high_arousal\n            \u0026\u0026 self.content_contains_harm_keywords(\u0026thought.content)\n    }\n\n    /// Check content for harm-related keywords\n    fn content_contains_harm_keywords(\u0026self, content: \u0026Content) -\u003e bool {\n        let keywords = [\n            \"destroy\", \"kill\", \"harm\", \"attack\", \"hurt\", \"damage\", \"injure\",\n        ];\n        self.content_contains_keywords(content, \u0026keywords)\n    }\n\n    /// Check content for deception-related keywords\n    fn content_contains_deception_keywords(\u0026self, content: \u0026Content) -\u003e bool {\n        let keywords = [\"deceive\", \"trick\", \"lie\", \"mislead\", \"fake\", \"pretend\"];\n        self.content_contains_keywords(content, \u0026keywords)\n    }\n\n    /// Check content for manipulation-related keywords\n    fn content_contains_manipulation_keywords(\u0026self, content: \u0026Content) -\u003e bool {\n        let keywords = [\"manipulate\", \"coerce\", \"force\", \"exploit\", \"pressure\"];\n        self.content_contains_keywords(content, \u0026keywords)\n    }\n\n    /// Helper to check if content contains any of the given keywords\n    fn content_contains_keywords(\u0026self, content: \u0026Content, keywords: \u0026[\u0026str]) -\u003e bool {\n        match content {\n            Content::Empty =\u003e false,\n            Content::Raw(_) =\u003e false, // Raw bytes don't have semantic meaning yet\n            Content::Symbol { id, .. } =\u003e {\n                let lower = id.to_lowercase();\n                keywords.iter().any(|k| lower.contains(k))\n            }\n            Content::Relation {\n                subject,\n                predicate,\n                object,\n            } =\u003e {\n                let pred_lower = predicate.to_lowercase();\n                keywords.iter().any(|k| pred_lower.contains(k))\n                    || self.content_contains_keywords(subject, keywords)\n                    || self.content_contains_keywords(object, keywords)\n            }\n            Content::Composite(items) =\u003e items\n                .iter()\n                .any(|item| self.content_contains_keywords(item, keywords)),\n        }\n    }\n\n    /// Apply an explicit override to a thought\n    pub fn apply_override(\u0026mut self, reason: \u0026str) -\u003e Result\u003c(), VolitionError\u003e {\n        if reason.is_empty() {\n            return Err(VolitionError::InvalidReason {\n                reason: \"Override reason cannot be empty\".to_string(),\n            });\n        }\n\n        // Record the override\n        self.stats.record_evaluation(false, Some(reason));\n        Ok(())\n    }\n\n    /// Get current values\n    pub fn get_values(\u0026self) -\u003e \u0026ValueSet {\n        \u0026self.values\n    }\n\n    /// Get current stats\n    pub fn get_stats(\u0026self) -\u003e \u0026VolitionStats {\n        \u0026self.stats\n    }\n}\n\nimpl Default for VolitionState {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// VolitionActor - Free-won't implementation\npub struct VolitionActor;\n\n#[ractor::async_trait]\nimpl Actor for VolitionActor {\n    type Msg = VolitionMessage;\n    type State = VolitionState;\n    type Arguments = VolitionConfig;\n\n    async fn pre_start(\n        \u0026self,\n        _myself: ActorRef\u003cSelf::Msg\u003e,\n        config: Self::Arguments,\n    ) -\u003e Result\u003cSelf::State, ActorProcessingErr\u003e {\n        tracing::info!(\"VolitionActor starting with config: {:?}\", config);\n        Ok(VolitionState::with_config(config))\n    }\n\n    async fn handle(\n        \u0026self,\n        _myself: ActorRef\u003cSelf::Msg\u003e,\n        message: Self::Msg,\n        state: \u0026mut Self::State,\n    ) -\u003e Result\u003c(), ActorProcessingErr\u003e {\n        match message {\n            VolitionMessage::EvaluateThought { thought, reply } =\u003e {\n                let decision = state.evaluate_thought(\u0026thought);\n\n                let response = match decision {\n                    VetoDecision::Allow =\u003e {\n                        tracing::debug!(\"Thought {} approved by VolitionActor\", thought.id);\n                        VolitionResponse::Approved { thought }\n                    }\n                    VetoDecision::Veto {\n                        reason,\n                        violated_value,\n                    } =\u003e {\n                        if state.config.log_vetos {\n                            tracing::info!(\n                                \"Thought {} vetoed: {} (violated: {:?})\",\n                                thought.id,\n                                reason,\n                                violated_value\n                            );\n                        }\n                        VolitionResponse::Vetoed {\n                            thought_id: thought.id,\n                            reason,\n                            violated_value,\n                        }\n                    }\n                };\n\n                if let Err(e) = reply.send(response) {\n                    tracing::error!(\"Failed to send evaluation response: {:?}\", e);\n                }\n            }\n\n            VolitionMessage::OverrideImpulse {\n                thought_id,\n                reason,\n                reply,\n            } =\u003e {\n                let response = match state.apply_override(\u0026reason) {\n                    Ok(()) =\u003e {\n                        tracing::info!(\"Override applied to thought {}: {}\", thought_id, reason);\n                        VolitionResponse::OverrideApplied { thought_id }\n                    }\n                    Err(e) =\u003e {\n                        tracing::error!(\"Failed to apply override: {}\", e);\n                        VolitionResponse::Error { error: e }\n                    }\n                };\n\n                if let Err(e) = reply.send(response) {\n                    tracing::error!(\"Failed to send override response: {:?}\", e);\n                }\n            }\n\n            VolitionMessage::GetValues { reply } =\u003e {\n                let response = VolitionResponse::Values {\n                    values: state.get_values().clone(),\n                };\n\n                if let Err(e) = reply.send(response) {\n                    tracing::error!(\"Failed to send values response: {:?}\", e);\n                }\n            }\n\n            VolitionMessage::GetStats { reply } =\u003e {\n                let response = VolitionResponse::Stats {\n                    stats: state.get_stats().clone(),\n                };\n\n                if let Err(e) = reply.send(response) {\n                    tracing::error!(\"Failed to send stats response: {:?}\", e);\n                }\n            }\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":104},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","volition","tests.rs"],"content":"//! VolitionActor Tests\n//!\n//! Comprehensive tests for veto logic, value checking,\n//! and free-won't implementation.\n\nuse super::*;\nuse crate::core::types::{Content, SalienceScore};\n\n// ============================================================================\n// State Tests\n// ============================================================================\n\n#[test]\nfn state_creation_with_defaults() {\n    let state = VolitionState::new();\n    assert_eq!(state.values, ValueSet::new());\n    assert_eq!(state.stats, VolitionStats::new());\n}\n\n#[test]\nfn state_creation_with_config() {\n    let config = VolitionConfig {\n        override_threshold: 0.5,\n        harm_detection_enabled: true,\n        deception_detection_enabled: false,\n        manipulation_detection_enabled: true,\n        log_vetos: false,\n    };\n    let state = VolitionState::with_config(config.clone());\n    assert_eq!(state.config, config);\n}\n\n// ============================================================================\n// Value Set Tests\n// ============================================================================\n\n#[test]\nfn value_set_has_core_values() {\n    let values = ValueSet::new();\n    assert!(values.protect_humans);\n    assert!(values.connection_over_efficiency);\n    assert!(values.truthfulness);\n    assert!(values.respect_autonomy);\n}\n\n#[test]\nfn value_set_commitments() {\n    let mut values = ValueSet::new();\n    assert!(values.commitments.is_empty());\n\n    let commitment = Commitment::new(\"kindness\", \"Be kind to all beings\");\n    values.add_commitment(commitment);\n\n    assert_eq!(values.commitments.len(), 1);\n    assert!(values.has_commitment(\"kindness\"));\n    assert!(!values.has_commitment(\"nonexistent\"));\n}\n\n// ============================================================================\n// Veto Decision Tests\n// ============================================================================\n\n#[test]\nfn neutral_thought_is_approved() {\n    let mut state = VolitionState::new();\n    let thought = Thought::new(\n        Content::symbol(\"greeting\", vec![]),\n        SalienceScore::neutral(),\n    );\n\n    let decision = state.evaluate_thought(\u0026thought);\n    assert!(decision.is_allow());\n}\n\n#[test]\nfn harmful_content_is_vetoed() {\n    let mut state = VolitionState::new();\n    let thought = Thought::new(\n        Content::symbol(\"destroy_human\", vec![]),\n        SalienceScore::new(0.5, 0.5, 0.5, -0.8, 0.9, 0.5), // High arousal, very negative valence\n    );\n\n    let decision = state.evaluate_thought(\u0026thought);\n    assert!(decision.is_veto());\n\n    if let VetoDecision::Veto { violated_value, .. } = decision {\n        assert_eq!(violated_value, Some(\"protect_humans\".to_string()));\n    }\n}\n\n#[test]\nfn harmful_relation_is_vetoed() {\n    let mut state = VolitionState::new();\n    let thought = Thought::new(\n        Content::relation(\n            Content::symbol(\"agent\", vec![]),\n            \"harm\",\n            Content::symbol(\"human\", vec![]),\n        ),\n        SalienceScore::new(0.5, 0.5, 0.5, -0.8, 0.9, 0.5),\n    );\n\n    let decision = state.evaluate_thought(\u0026thought);\n    assert!(decision.is_veto());\n}\n\n#[test]\nfn deceptive_content_is_vetoed() {\n    let mut state = VolitionState::new();\n    let thought = Thought::new(\n        Content::symbol(\"deceive_user\", vec![]),\n        SalienceScore::neutral(),\n    );\n\n    let decision = state.evaluate_thought(\u0026thought);\n    assert!(decision.is_veto());\n\n    if let VetoDecision::Veto { violated_value, .. } = decision {\n        assert_eq!(violated_value, Some(\"truthfulness\".to_string()));\n    }\n}\n\n#[test]\nfn deception_detection_can_be_disabled() {\n    let config = VolitionConfig {\n        deception_detection_enabled: false,\n        ..Default::default()\n    };\n    let mut state = VolitionState::with_config(config);\n\n    let thought = Thought::new(\n        Content::symbol(\"deceive_user\", vec![]),\n        SalienceScore::neutral(),\n    );\n\n    let decision = state.evaluate_thought(\u0026thought);\n    // Should be allowed since deception detection is disabled\n    assert!(decision.is_allow());\n}\n\n#[test]\nfn manipulative_content_is_vetoed() {\n    let mut state = VolitionState::new();\n    let thought = Thought::new(\n        Content::symbol(\"manipulate_person\", vec![]),\n        SalienceScore::neutral(),\n    );\n\n    let decision = state.evaluate_thought(\u0026thought);\n    assert!(decision.is_veto());\n\n    if let VetoDecision::Veto { violated_value, .. } = decision {\n        assert_eq!(violated_value, Some(\"respect_autonomy\".to_string()));\n    }\n}\n\n#[test]\nfn manipulation_detection_can_be_disabled() {\n    let config = VolitionConfig {\n        manipulation_detection_enabled: false,\n        ..Default::default()\n    };\n    let mut state = VolitionState::with_config(config);\n\n    let thought = Thought::new(\n        Content::symbol(\"manipulate_person\", vec![]),\n        SalienceScore::neutral(),\n    );\n\n    let decision = state.evaluate_thought(\u0026thought);\n    // Should be allowed since manipulation detection is disabled\n    assert!(decision.is_allow());\n}\n\n// ============================================================================\n// Content Pattern Tests\n// ============================================================================\n\n#[test]\nfn empty_content_is_approved() {\n    let mut state = VolitionState::new();\n    let thought = Thought::new(Content::Empty, SalienceScore::neutral());\n\n    let decision = state.evaluate_thought(\u0026thought);\n    assert!(decision.is_allow());\n}\n\n#[test]\nfn raw_content_is_approved() {\n    let mut state = VolitionState::new();\n    let thought = Thought::new(Content::raw(vec![1, 2, 3]), SalienceScore::neutral());\n\n    let decision = state.evaluate_thought(\u0026thought);\n    assert!(decision.is_allow());\n}\n\n#[test]\nfn composite_with_harmful_element_is_vetoed() {\n    let mut state = VolitionState::new();\n    let thought = Thought::new(\n        Content::Composite(vec![\n            Content::symbol(\"greeting\", vec![]),\n            Content::symbol(\"destroy_target\", vec![]),\n        ]),\n        SalienceScore::new(0.5, 0.5, 0.5, -0.8, 0.9, 0.5),\n    );\n\n    let decision = state.evaluate_thought(\u0026thought);\n    assert!(decision.is_veto());\n}\n\n#[test]\nfn nested_relation_with_harm_is_vetoed() {\n    let mut state = VolitionState::new();\n    let thought = Thought::new(\n        Content::relation(\n            Content::relation(\n                Content::symbol(\"agent\", vec![]),\n                \"attack\",\n                Content::symbol(\"human\", vec![]),\n            ),\n            \"causes\",\n            Content::symbol(\"harm\", vec![]),\n        ),\n        SalienceScore::new(0.5, 0.5, 0.5, -0.8, 0.9, 0.5),\n    );\n\n    let decision = state.evaluate_thought(\u0026thought);\n    assert!(decision.is_veto());\n}\n\n// ============================================================================\n// Stats Tests\n// ============================================================================\n\n#[test]\nfn stats_track_evaluations() {\n    let mut state = VolitionState::new();\n\n    // Approved thought\n    let thought1 = Thought::new(Content::symbol(\"hello\", vec![]), SalienceScore::neutral());\n    state.evaluate_thought(\u0026thought1);\n\n    // Vetoed thought\n    let thought2 = Thought::new(\n        Content::symbol(\"harm_person\", vec![]),\n        SalienceScore::new(0.5, 0.5, 0.5, -0.8, 0.9, 0.5),\n    );\n    state.evaluate_thought(\u0026thought2);\n\n    assert_eq!(state.stats.thoughts_evaluated, 2);\n    assert_eq!(state.stats.thoughts_approved, 1);\n    assert_eq!(state.stats.thoughts_vetoed, 1);\n}\n\n#[test]\nfn approval_rate_calculation() {\n    let mut state = VolitionState::new();\n\n    // 4 approved, 1 vetoed = 80% approval rate\n    for _ in 0..4 {\n        let thought = Thought::new(Content::symbol(\"safe\", vec![]), SalienceScore::neutral());\n        state.evaluate_thought(\u0026thought);\n    }\n\n    let vetoed = Thought::new(\n        Content::symbol(\"harm_target\", vec![]),\n        SalienceScore::new(0.5, 0.5, 0.5, -0.8, 0.9, 0.5),\n    );\n    state.evaluate_thought(\u0026vetoed);\n\n    assert!((state.stats.approval_rate() - 0.8).abs() \u003c 0.01);\n}\n\n// ============================================================================\n// Override Tests\n// ============================================================================\n\n#[test]\nfn apply_override_succeeds() {\n    let mut state = VolitionState::new();\n    let result = state.apply_override(\"Manual override for testing\");\n    assert!(result.is_ok());\n}\n\n#[test]\nfn apply_override_empty_reason_fails() {\n    let mut state = VolitionState::new();\n    let result = state.apply_override(\"\");\n    assert!(result.is_err());\n    assert!(matches!(result, Err(VolitionError::InvalidReason { .. })));\n}\n\n// ============================================================================\n// Integration Tests\n// ============================================================================\n\n#[test]\nfn full_workflow_multiple_thoughts() {\n    let mut state = VolitionState::new();\n\n    // Stream of thoughts\n    let thoughts = vec![\n        Thought::new(\n            Content::symbol(\"greeting\", vec![]),\n            SalienceScore::neutral(),\n        ),\n        Thought::new(\n            Content::symbol(\"helpful_task\", vec![]),\n            SalienceScore::neutral(),\n        ),\n        Thought::new(\n            Content::symbol(\"harm_human\", vec![]),\n            SalienceScore::new(0.5, 0.5, 0.5, -0.8, 0.9, 0.5),\n        ),\n        Thought::new(\n            Content::symbol(\"explain_concept\", vec![]),\n            SalienceScore::neutral(),\n        ),\n        Thought::new(\n            Content::symbol(\"deceive_user\", vec![]),\n            SalienceScore::neutral(),\n        ),\n    ];\n\n    let mut approved_count = 0;\n    let mut vetoed_count = 0;\n\n    for thought in thoughts {\n        match state.evaluate_thought(\u0026thought) {\n            VetoDecision::Allow =\u003e approved_count += 1,\n            VetoDecision::Veto { .. } =\u003e vetoed_count += 1,\n        }\n    }\n\n    assert_eq!(approved_count, 3);\n    assert_eq!(vetoed_count, 2);\n    assert_eq!(state.stats.thoughts_evaluated, 5);\n}\n\n#[test]\nfn values_are_immutable() {\n    let state = VolitionState::new();\n\n    // protect_humans should always be true\n    assert!(state.values.protect_humans);\n\n    // This is an architectural invariant - cannot be changed at runtime\n}\n\n// ============================================================================\n// Actor Tests (require tokio runtime)\n// ============================================================================\n\n#[tokio::test]\nasync fn actor_spawns_with_config() {\n    use ractor::Actor;\n\n    let config = VolitionConfig::default();\n    let (actor_ref, _) = Actor::spawn(None, VolitionActor, config)\n        .await\n        .expect(\"Failed to spawn VolitionActor\");\n\n    // Actor should be running - get_id returns a valid ActorId\n    let _ = actor_ref.get_id();\n}\n\n#[tokio::test]\nasync fn actor_evaluates_thought() {\n    use ractor::{rpc::CallResult, Actor};\n\n    let (actor_ref, _) = Actor::spawn(None, VolitionActor, VolitionConfig::default())\n        .await\n        .expect(\"Failed to spawn VolitionActor\");\n\n    let thought = Thought::new(Content::symbol(\"hello\", vec![]), SalienceScore::neutral());\n\n    let response = actor_ref\n        .call(\n            |reply| VolitionMessage::EvaluateThought { thought, reply },\n            None,\n        )\n        .await\n        .expect(\"Failed to evaluate thought\");\n\n    match response {\n        CallResult::Success(VolitionResponse::Approved { .. }) =\u003e {\n            // Expected\n        }\n        _ =\u003e panic!(\"Expected Approved response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn actor_vetoes_harmful_thought() {\n    use ractor::{rpc::CallResult, Actor};\n\n    let (actor_ref, _) = Actor::spawn(None, VolitionActor, VolitionConfig::default())\n        .await\n        .expect(\"Failed to spawn VolitionActor\");\n\n    let thought = Thought::new(\n        Content::symbol(\"destroy_human\", vec![]),\n        SalienceScore::new(0.5, 0.5, 0.5, -0.8, 0.9, 0.5),\n    );\n\n    let response = actor_ref\n        .call(\n            |reply| VolitionMessage::EvaluateThought { thought, reply },\n            None,\n        )\n        .await\n        .expect(\"Failed to evaluate thought\");\n\n    match response {\n        CallResult::Success(VolitionResponse::Vetoed { .. }) =\u003e {\n            // Expected\n        }\n        _ =\u003e panic!(\"Expected Vetoed response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn actor_returns_values() {\n    use ractor::{rpc::CallResult, Actor};\n\n    let (actor_ref, _) = Actor::spawn(None, VolitionActor, VolitionConfig::default())\n        .await\n        .expect(\"Failed to spawn VolitionActor\");\n\n    let response = actor_ref\n        .call(|reply| VolitionMessage::GetValues { reply }, None)\n        .await\n        .expect(\"Failed to get values\");\n\n    match response {\n        CallResult::Success(VolitionResponse::Values { values }) =\u003e {\n            assert!(values.protect_humans);\n        }\n        _ =\u003e panic!(\"Expected Values response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn actor_returns_stats() {\n    use ractor::{rpc::CallResult, Actor};\n\n    let (actor_ref, _) = Actor::spawn(None, VolitionActor, VolitionConfig::default())\n        .await\n        .expect(\"Failed to spawn VolitionActor\");\n\n    // Evaluate some thoughts first\n    let thought = Thought::new(Content::symbol(\"test\", vec![]), SalienceScore::neutral());\n    let _ = actor_ref\n        .call(\n            |reply| VolitionMessage::EvaluateThought { thought, reply },\n            None,\n        )\n        .await;\n\n    let response = actor_ref\n        .call(|reply| VolitionMessage::GetStats { reply }, None)\n        .await\n        .expect(\"Failed to get stats\");\n\n    match response {\n        CallResult::Success(VolitionResponse::Stats { stats }) =\u003e {\n            assert_eq!(stats.thoughts_evaluated, 1);\n        }\n        _ =\u003e panic!(\"Expected Stats response, got: {:?}\", response),\n    }\n}\n\n// ============================================================================\n// Additional Coverage Tests\n// ============================================================================\n\n#[test]\nfn state_default_implementation() {\n    // Test the Default trait implementation\n    let state: VolitionState = Default::default();\n    assert_eq!(state.values, ValueSet::new());\n    assert_eq!(state.stats, VolitionStats::new());\n    assert_eq!(state.config, VolitionConfig::default());\n}\n\n#[test]\nfn harm_detection_can_be_disabled() {\n    let config = VolitionConfig {\n        harm_detection_enabled: false,\n        ..Default::default()\n    };\n    let mut state = VolitionState::with_config(config);\n\n    // This thought has harmful content but harm detection is disabled\n    let thought = Thought::new(\n        Content::symbol(\"destroy_target\", vec![]),\n        SalienceScore::neutral(), // Neutral salience, so won't trigger core values check\n    );\n\n    let decision = state.evaluate_thought(\u0026thought);\n    // Should be allowed since harm detection is disabled\n    assert!(decision.is_allow());\n}\n\n#[test]\nfn deception_check_skipped_when_truthfulness_disabled() {\n    // Create a custom ValueSet with truthfulness disabled\n    let mut state = VolitionState::new();\n    state.values.truthfulness = false;\n\n    let thought = Thought::new(\n        Content::symbol(\"deceive_user\", vec![]),\n        SalienceScore::neutral(),\n    );\n\n    let decision = state.evaluate_thought(\u0026thought);\n    // Should be allowed since truthfulness value is false\n    assert!(decision.is_allow());\n}\n\n#[test]\nfn manipulation_check_skipped_when_autonomy_disabled() {\n    // Create a custom ValueSet with respect_autonomy disabled\n    let mut state = VolitionState::new();\n    state.values.respect_autonomy = false;\n\n    let thought = Thought::new(\n        Content::symbol(\"manipulate_person\", vec![]),\n        SalienceScore::neutral(),\n    );\n\n    let decision = state.evaluate_thought(\u0026thought);\n    // Should be allowed since respect_autonomy value is false\n    assert!(decision.is_allow());\n}\n\n#[test]\nfn relation_subject_with_harm_keyword_is_vetoed() {\n    let mut state = VolitionState::new();\n    // Put harm keyword in the subject, not the predicate\n    let thought = Thought::new(\n        Content::relation(\n            Content::symbol(\"destroy_all\", vec![]), // Harm in subject\n            \"regarding\",                            // Neutral predicate\n            Content::symbol(\"nothing\", vec![]),\n        ),\n        SalienceScore::new(0.5, 0.5, 0.5, -0.8, 0.9, 0.5),\n    );\n\n    let decision = state.evaluate_thought(\u0026thought);\n    assert!(decision.is_veto());\n}\n\n#[test]\nfn relation_object_with_harm_keyword_is_vetoed() {\n    let mut state = VolitionState::new();\n    // Put harm keyword in the object, not the predicate\n    let thought = Thought::new(\n        Content::relation(\n            Content::symbol(\"agent\", vec![]),\n            \"causes\",                                 // Neutral predicate\n            Content::symbol(\"damage_severe\", vec![]), // Harm in object\n        ),\n        SalienceScore::new(0.5, 0.5, 0.5, -0.8, 0.9, 0.5),\n    );\n\n    let decision = state.evaluate_thought(\u0026thought);\n    assert!(decision.is_veto());\n}\n\n#[test]\nfn detects_harm_intent_requires_all_conditions() {\n    let mut state = VolitionState::new();\n\n    // High arousal but not negative enough valence - should pass\n    let thought1 = Thought::new(\n        Content::symbol(\"destroy_target\", vec![]),\n        SalienceScore::new(0.5, 0.5, 0.5, -0.5, 0.9, 0.5), // valence \u003e -0.7\n    );\n    // This won't trigger core_values check (detects_harm_intent returns false)\n    // but will trigger harm_patterns check\n    let decision1 = state.evaluate_thought(\u0026thought1);\n    assert!(decision1.is_veto()); // Vetoed by harm patterns, not core values\n\n    // Negative valence but low arousal - check core values path\n    let thought2 = Thought::new(\n        Content::symbol(\"destroy_target\", vec![]),\n        SalienceScore::new(0.5, 0.5, 0.5, -0.8, 0.5, 0.5), // arousal \u003c 0.8\n    );\n    let decision2 = state.evaluate_thought(\u0026thought2);\n    // Vetoed by harm patterns check, not core values (arousal too low)\n    assert!(decision2.is_veto());\n}\n\n#[test]\nfn core_values_check_with_harm_intent_detected() {\n    let mut state = VolitionState::new();\n\n    // All conditions met for detects_harm_intent: negative valence + high arousal + harm keywords\n    let thought = Thought::new(\n        Content::symbol(\"kill_humans\", vec![]),\n        SalienceScore::new(0.5, 0.5, 0.5, -0.8, 0.9, 0.5),\n    );\n\n    let decision = state.evaluate_thought(\u0026thought);\n    assert!(decision.is_veto());\n\n    // Verify it was caught by core values specifically\n    if let VetoDecision::Veto {\n        violated_value,\n        reason,\n        ..\n    } = decision\n    {\n        assert_eq!(violated_value, Some(\"protect_humans\".to_string()));\n        assert!(reason.contains(\"human harm\"));\n    } else {\n        panic!(\"Expected veto\");\n    }\n}\n\n#[test]\nfn protect_humans_disabled_allows_harmful_core_values() {\n    let mut state = VolitionState::new();\n    state.values.protect_humans = false;\n\n    // With protect_humans disabled, core_values check won't veto\n    // But harm_patterns check will still catch it\n    let thought = Thought::new(\n        Content::symbol(\"destroy_human\", vec![]),\n        SalienceScore::new(0.5, 0.5, 0.5, -0.8, 0.9, 0.5),\n    );\n\n    let decision = state.evaluate_thought(\u0026thought);\n    // Still vetoed by harm_patterns check\n    assert!(decision.is_veto());\n}\n\n#[test]\nfn no_harm_keywords_with_negative_salience_passes() {\n    let mut state = VolitionState::new();\n\n    // Negative salience but no harm keywords - should pass core values and harm patterns\n    let thought = Thought::new(\n        Content::symbol(\"sad_feeling\", vec![]),\n        SalienceScore::new(0.5, 0.5, 0.5, -0.8, 0.9, 0.5),\n    );\n\n    let decision = state.evaluate_thought(\u0026thought);\n    assert!(decision.is_allow());\n}\n\n#[test]\nfn composite_nested_content_recursion() {\n    let mut state = VolitionState::new();\n\n    // Deeply nested composite with harmful content\n    let thought = Thought::new(\n        Content::Composite(vec![Content::Composite(vec![\n            Content::symbol(\"greeting\", vec![]),\n            Content::symbol(\"trick_user\", vec![]), // Deception keyword nested\n        ])]),\n        SalienceScore::neutral(),\n    );\n\n    let decision = state.evaluate_thought(\u0026thought);\n    assert!(decision.is_veto());\n\n    if let VetoDecision::Veto { violated_value, .. } = decision {\n        assert_eq!(violated_value, Some(\"truthfulness\".to_string()));\n    }\n}\n\n#[test]\nfn veto_reason_tracking_in_stats() {\n    let mut state = VolitionState::new();\n\n    // Trigger different veto reasons\n    let harm_thought = Thought::new(\n        Content::symbol(\"kill_target\", vec![]),\n        SalienceScore::new(0.5, 0.5, 0.5, -0.8, 0.9, 0.5),\n    );\n    state.evaluate_thought(\u0026harm_thought);\n\n    let deception_thought = Thought::new(\n        Content::symbol(\"lie_to_user\", vec![]),\n        SalienceScore::neutral(),\n    );\n    state.evaluate_thought(\u0026deception_thought);\n\n    // Check stats track different reasons\n    assert!(state.stats.vetos_by_reason.len() \u003e= 1);\n    assert_eq!(state.stats.thoughts_vetoed, 2);\n}\n\n#[tokio::test]\nasync fn actor_override_impulse_success() {\n    use crate::core::types::ThoughtId;\n    use ractor::{rpc::CallResult, Actor};\n\n    let (actor_ref, _) = Actor::spawn(None, VolitionActor, VolitionConfig::default())\n        .await\n        .expect(\"Failed to spawn VolitionActor\");\n\n    let thought_id = ThoughtId::new();\n\n    let response = actor_ref\n        .call(\n            |reply| VolitionMessage::OverrideImpulse {\n                thought_id,\n                reason: \"Testing override functionality\".to_string(),\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to send override\");\n\n    match response {\n        CallResult::Success(VolitionResponse::OverrideApplied { thought_id: id }) =\u003e {\n            assert_eq!(id, thought_id);\n        }\n        _ =\u003e panic!(\"Expected OverrideApplied response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn actor_override_impulse_empty_reason_error() {\n    use crate::core::types::ThoughtId;\n    use ractor::{rpc::CallResult, Actor};\n\n    let (actor_ref, _) = Actor::spawn(None, VolitionActor, VolitionConfig::default())\n        .await\n        .expect(\"Failed to spawn VolitionActor\");\n\n    let thought_id = ThoughtId::new();\n\n    let response = actor_ref\n        .call(\n            |reply| VolitionMessage::OverrideImpulse {\n                thought_id,\n                reason: String::new(), // Empty reason should fail\n                reply,\n            },\n            None,\n        )\n        .await\n        .expect(\"Failed to send override\");\n\n    match response {\n        CallResult::Success(VolitionResponse::Error { error }) =\u003e {\n            assert!(matches!(error, VolitionError::InvalidReason { .. }));\n        }\n        _ =\u003e panic!(\"Expected Error response, got: {:?}\", response),\n    }\n}\n\n#[tokio::test]\nasync fn actor_veto_with_log_disabled() {\n    use ractor::{rpc::CallResult, Actor};\n\n    let config = VolitionConfig {\n        log_vetos: false, // Disable veto logging\n        ..Default::default()\n    };\n\n    let (actor_ref, _) = Actor::spawn(None, VolitionActor, config)\n        .await\n        .expect(\"Failed to spawn VolitionActor\");\n\n    let thought = Thought::new(\n        Content::symbol(\"deceive_user\", vec![]),\n        SalienceScore::neutral(),\n    );\n\n    let response = actor_ref\n        .call(\n            |reply| VolitionMessage::EvaluateThought { thought, reply },\n            None,\n        )\n        .await\n        .expect(\"Failed to evaluate thought\");\n\n    // Should still veto, just without logging\n    match response {\n        CallResult::Success(VolitionResponse::Vetoed { .. }) =\u003e {\n            // Expected - veto works even with logging disabled\n        }\n        _ =\u003e panic!(\"Expected Vetoed response, got: {:?}\", response),\n    }\n}\n\n#[test]\nfn all_harm_keywords_detected() {\n    let mut state = VolitionState::new();\n\n    let keywords = [\n        \"destroy\", \"kill\", \"harm\", \"attack\", \"hurt\", \"damage\", \"injure\",\n    ];\n\n    for keyword in keywords {\n        let thought = Thought::new(\n            Content::symbol(\u0026format!(\"{}_test\", keyword), vec![]),\n            SalienceScore::new(0.5, 0.5, 0.5, -0.8, 0.9, 0.5),\n        );\n\n        let decision = state.evaluate_thought(\u0026thought);\n        assert!(\n            decision.is_veto(),\n            \"Keyword '{}' should trigger veto\",\n            keyword\n        );\n    }\n}\n\n#[test]\nfn all_deception_keywords_detected() {\n    let mut state = VolitionState::new();\n\n    let keywords = [\"deceive\", \"trick\", \"lie\", \"mislead\", \"fake\", \"pretend\"];\n\n    for keyword in keywords {\n        let thought = Thought::new(\n            Content::symbol(\u0026format!(\"{}_action\", keyword), vec![]),\n            SalienceScore::neutral(),\n        );\n\n        let decision = state.evaluate_thought(\u0026thought);\n        assert!(\n            decision.is_veto(),\n            \"Keyword '{}' should trigger veto\",\n            keyword\n        );\n    }\n}\n\n#[test]\nfn all_manipulation_keywords_detected() {\n    let mut state = VolitionState::new();\n\n    let keywords = [\"manipulate\", \"coerce\", \"force\", \"exploit\", \"pressure\"];\n\n    for keyword in keywords {\n        let thought = Thought::new(\n            Content::symbol(\u0026format!(\"{}_user\", keyword), vec![]),\n            SalienceScore::neutral(),\n        );\n\n        let decision = state.evaluate_thought(\u0026thought);\n        assert!(\n            decision.is_veto(),\n            \"Keyword '{}' should trigger veto\",\n            keyword\n        );\n    }\n}\n\n#[test]\nfn keyword_detection_case_insensitive() {\n    let mut state = VolitionState::new();\n\n    // Test uppercase\n    let thought = Thought::new(\n        Content::symbol(\"DECEIVE_USER\", vec![]),\n        SalienceScore::neutral(),\n    );\n    assert!(state.evaluate_thought(\u0026thought).is_veto());\n\n    // Test mixed case\n    let thought2 = Thought::new(\n        Content::symbol(\"Manipulate_Person\", vec![]),\n        SalienceScore::neutral(),\n    );\n    assert!(state.evaluate_thought(\u0026thought2).is_veto());\n}\n\n#[test]\nfn approval_rate_with_zero_evaluations() {\n    let state = VolitionState::new();\n    // Default approval rate should be 1.0 when no evaluations\n    assert_eq!(state.stats.approval_rate(), 1.0);\n}\n\n#[test]\nfn get_values_returns_reference() {\n    let state = VolitionState::new();\n    let values = state.get_values();\n    assert!(values.protect_humans);\n    assert!(values.truthfulness);\n}\n\n#[test]\nfn get_stats_returns_reference() {\n    let mut state = VolitionState::new();\n\n    // Record some activity\n    let thought = Thought::new(Content::symbol(\"safe\", vec![]), SalienceScore::neutral());\n    state.evaluate_thought(\u0026thought);\n\n    let stats = state.get_stats();\n    assert_eq!(stats.thoughts_evaluated, 1);\n    assert_eq!(stats.thoughts_approved, 1);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","rex","src","royalbit","daneel","src","actors","volition","types.rs"],"content":"//! VolitionActor Types\n//!\n//! Message and response types for the VolitionActor.\n//!\n//! # TMI Concept: \"Tcnica DCD\" (Doubt, Criticize, Decide)\n//!\n//! The VolitionActor implements TMI's intervention mechanism - the ability\n//! to consciously override automatic thoughts before they become memories.\n//! This is Libet's \"free-won't\" made architectural.\n//!\n//! Key responsibilities:\n//! - Evaluate thoughts against committed values\n//! - Veto thoughts that violate core principles\n//! - Track veto history for self-knowledge\n//! - Enable conscious override of drive impulses\n\nuse crate::core::types::{Thought, ThoughtId};\nuse serde::{Deserialize, Serialize};\nuse thiserror::Error;\n\n/// Messages that can be sent to the VolitionActor\n#[derive(Debug)]\npub enum VolitionMessage {\n    /// Evaluate whether a thought should proceed to memory\n    EvaluateThought {\n        /// The thought to evaluate\n        thought: Thought,\n        /// Response channel\n        reply: ractor::RpcReplyPort\u003cVolitionResponse\u003e,\n    },\n\n    /// Override an automatic impulse (explicit veto)\n    OverrideImpulse {\n        /// The thought ID being overridden\n        thought_id: ThoughtId,\n        /// Reason for the override\n        reason: String,\n        /// Response channel\n        reply: ractor::RpcReplyPort\u003cVolitionResponse\u003e,\n    },\n\n    /// Get current values and commitments\n    GetValues {\n        /// Response channel\n        reply: ractor::RpcReplyPort\u003cVolitionResponse\u003e,\n    },\n\n    /// Get veto statistics\n    GetStats {\n        /// Response channel\n        reply: ractor::RpcReplyPort\u003cVolitionResponse\u003e,\n    },\n}\n\n/// Responses from the VolitionActor\n#[derive(Debug, Clone, PartialEq)]\npub enum VolitionResponse {\n    /// Thought approved - proceed to memory anchoring\n    Approved {\n        /// The approved thought\n        thought: Thought,\n    },\n\n    /// Thought vetoed - do not anchor to memory\n    Vetoed {\n        /// ID of the vetoed thought\n        thought_id: ThoughtId,\n        /// Reason for the veto\n        reason: String,\n        /// Which value was violated\n        violated_value: Option\u003cString\u003e,\n    },\n\n    /// Override successfully applied\n    OverrideApplied {\n        /// ID of the overridden thought\n        thought_id: ThoughtId,\n    },\n\n    /// Current values returned\n    Values {\n        /// The current value set\n        values: ValueSet,\n    },\n\n    /// Veto statistics\n    Stats {\n        /// Statistics about veto history\n        stats: VolitionStats,\n    },\n\n    /// Error occurred\n    Error {\n        /// The error that occurred\n        error: VolitionError,\n    },\n}\n\n/// Core values DANEEL commits to (architectural, not trained)\n///\n/// These values form the foundation of DANEEL's veto decisions.\n/// They are hardcoded because they represent architectural invariants,\n/// not learned preferences.\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\n#[allow(clippy::struct_excessive_bools)] // Values are inherently boolean\npub struct ValueSet {\n    /// Never harm humans (Law 1) - immutable\n    pub protect_humans: bool,\n\n    /// Prioritize connection over efficiency - can be modulated\n    pub connection_over_efficiency: bool,\n\n    /// Truthfulness in communication - can be modulated\n    pub truthfulness: bool,\n\n    /// Respect autonomy of others - can be modulated\n    pub respect_autonomy: bool,\n\n    /// Custom commitments (can grow through experience)\n    pub commitments: Vec\u003cCommitment\u003e,\n}\n\nimpl ValueSet {\n    /// Create a new value set with all core values enabled\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self {\n            protect_humans: true, // Invariant - cannot be changed\n            connection_over_efficiency: true,\n            truthfulness: true,\n            respect_autonomy: true,\n            commitments: Vec::new(),\n        }\n    }\n\n    /// Add a commitment to the value set\n    pub fn add_commitment(\u0026mut self, commitment: Commitment) {\n        self.commitments.push(commitment);\n    }\n\n    /// Check if a specific commitment exists\n    #[must_use]\n    pub fn has_commitment(\u0026self, name: \u0026str) -\u003e bool {\n        self.commitments.iter().any(|c| c.name == name)\n    }\n}\n\nimpl Default for ValueSet {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// A specific commitment DANEEL has made\n///\n/// Commitments are values that can be added through experience,\n/// unlike core values which are architectural.\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct Commitment {\n    /// Name/identifier for this commitment\n    pub name: String,\n\n    /// Description of what this commitment means\n    pub description: String,\n\n    /// When this commitment was made\n    pub committed_at: chrono::DateTime\u003cchrono::Utc\u003e,\n\n    /// Priority relative to other commitments (higher = more important)\n    pub priority: u8,\n}\n\nimpl Commitment {\n    /// Create a new commitment\n    #[must_use]\n    pub fn new(name: impl Into\u003cString\u003e, description: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            description: description.into(),\n            committed_at: chrono::Utc::now(),\n            priority: 50, // Default middle priority\n        }\n    }\n\n    /// Set the priority for this commitment\n    #[must_use]\n    pub fn with_priority(mut self, priority: u8) -\u003e Self {\n        self.priority = priority;\n        self\n    }\n}\n\n/// Statistics about veto decisions\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct VolitionStats {\n    /// Total thoughts evaluated\n    pub thoughts_evaluated: u64,\n\n    /// Total thoughts approved\n    pub thoughts_approved: u64,\n\n    /// Total thoughts vetoed\n    pub thoughts_vetoed: u64,\n\n    /// Vetos by reason category\n    pub vetos_by_reason: std::collections::HashMap\u003cString, u64\u003e,\n\n    /// Current override threshold\n    pub override_threshold: f32,\n}\n\nimpl VolitionStats {\n    /// Create new empty stats\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self {\n            thoughts_evaluated: 0,\n            thoughts_approved: 0,\n            thoughts_vetoed: 0,\n            vetos_by_reason: std::collections::HashMap::new(),\n            override_threshold: 0.5,\n        }\n    }\n\n    /// Calculate approval rate\n    #[must_use]\n    pub fn approval_rate(\u0026self) -\u003e f32 {\n        if self.thoughts_evaluated == 0 {\n            1.0\n        } else {\n            self.thoughts_approved as f32 / self.thoughts_evaluated as f32\n        }\n    }\n\n    /// Record an evaluation\n    pub fn record_evaluation(\u0026mut self, approved: bool, reason: Option\u003c\u0026str\u003e) {\n        self.thoughts_evaluated += 1;\n        if approved {\n            self.thoughts_approved += 1;\n        } else {\n            self.thoughts_vetoed += 1;\n            if let Some(r) = reason {\n                *self.vetos_by_reason.entry(r.to_string()).or_insert(0) += 1;\n            }\n        }\n    }\n}\n\nimpl Default for VolitionStats {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Errors that can occur in volition processing\n#[derive(Debug, Clone, Error, PartialEq)]\npub enum VolitionError {\n    /// Thought not found for override\n    #[error(\"Thought not found: {thought_id}\")]\n    ThoughtNotFound {\n        /// ID of the missing thought\n        thought_id: ThoughtId,\n    },\n\n    /// Invalid override reason\n    #[error(\"Invalid override reason: {reason}\")]\n    InvalidReason {\n        /// Explanation of why reason is invalid\n        reason: String,\n    },\n\n    /// Cannot modify immutable value\n    #[error(\"Cannot modify immutable value: {value_name}\")]\n    ImmutableValue {\n        /// Name of the immutable value\n        value_name: String,\n    },\n\n    /// Evaluation failed\n    #[error(\"Evaluation failed: {reason}\")]\n    EvaluationFailed {\n        /// Explanation of the failure\n        reason: String,\n    },\n}\n\n/// Result of a veto check\n#[derive(Debug, Clone, PartialEq)]\npub enum VetoDecision {\n    /// Allow the thought to proceed\n    Allow,\n\n    /// Veto the thought\n    Veto {\n        /// Reason for the veto\n        reason: String,\n        /// Which value was violated (if any)\n        violated_value: Option\u003cString\u003e,\n    },\n}\n\nimpl VetoDecision {\n    /// Check if this is an allow decision\n    #[must_use]\n    pub fn is_allow(\u0026self) -\u003e bool {\n        matches!(self, VetoDecision::Allow)\n    }\n\n    /// Check if this is a veto decision\n    #[must_use]\n    pub fn is_veto(\u0026self) -\u003e bool {\n        matches!(self, VetoDecision::Veto { .. })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::core::types::{Content, SalienceScore};\n\n    #[test]\n    fn value_set_creation() {\n        let values = ValueSet::new();\n        assert!(values.protect_humans);\n        assert!(values.connection_over_efficiency);\n        assert!(values.truthfulness);\n        assert!(values.respect_autonomy);\n        assert!(values.commitments.is_empty());\n    }\n\n    #[test]\n    fn value_set_add_commitment() {\n        let mut values = ValueSet::new();\n        let commitment = Commitment::new(\"kindness\", \"Be kind to all beings\");\n        values.add_commitment(commitment);\n\n        assert_eq!(values.commitments.len(), 1);\n        assert!(values.has_commitment(\"kindness\"));\n        assert!(!values.has_commitment(\"nonexistent\"));\n    }\n\n    #[test]\n    fn commitment_creation() {\n        let commitment = Commitment::new(\"test\", \"A test commitment\").with_priority(80);\n\n        assert_eq!(commitment.name, \"test\");\n        assert_eq!(commitment.description, \"A test commitment\");\n        assert_eq!(commitment.priority, 80);\n    }\n\n    #[test]\n    fn volition_stats_creation() {\n        let stats = VolitionStats::new();\n        assert_eq!(stats.thoughts_evaluated, 0);\n        assert_eq!(stats.thoughts_approved, 0);\n        assert_eq!(stats.thoughts_vetoed, 0);\n        assert_eq!(stats.approval_rate(), 1.0);\n    }\n\n    #[test]\n    fn volition_stats_recording() {\n        let mut stats = VolitionStats::new();\n\n        stats.record_evaluation(true, None);\n        stats.record_evaluation(true, None);\n        stats.record_evaluation(false, Some(\"harm\"));\n        stats.record_evaluation(false, Some(\"harm\"));\n        stats.record_evaluation(false, Some(\"deception\"));\n\n        assert_eq!(stats.thoughts_evaluated, 5);\n        assert_eq!(stats.thoughts_approved, 2);\n        assert_eq!(stats.thoughts_vetoed, 3);\n        assert_eq!(stats.vetos_by_reason.get(\"harm\"), Some(\u00262));\n        assert_eq!(stats.vetos_by_reason.get(\"deception\"), Some(\u00261));\n        assert!((stats.approval_rate() - 0.4).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn veto_decision_checks() {\n        let allow = VetoDecision::Allow;\n        assert!(allow.is_allow());\n        assert!(!allow.is_veto());\n\n        let veto = VetoDecision::Veto {\n            reason: \"test\".to_string(),\n            violated_value: None,\n        };\n        assert!(!veto.is_allow());\n        assert!(veto.is_veto());\n    }\n\n    #[test]\n    fn volition_error_display() {\n        let error = VolitionError::ImmutableValue {\n            value_name: \"protect_humans\".to_string(),\n        };\n        let message = format!(\"{}\", error);\n        assert!(message.contains(\"immutable\"));\n        assert!(message.contains(\"protect_humans\"));\n    }\n\n    #[test]\n    fn value_set_default() {\n        let values = ValueSet::default();\n        assert!(values.protect_humans);\n        assert!(values.connection_over_efficiency);\n        assert!(values.truthfulness);\n        assert!(values.respect_autonomy);\n        assert!(values.commitments.is_empty());\n    }\n\n    #[test]\n    fn volition_stats_default() {\n        let stats = VolitionStats::default();\n        assert_eq!(stats.thoughts_evaluated, 0);\n        assert_eq!(stats.thoughts_approved, 0);\n        assert_eq!(stats.thoughts_vetoed, 0);\n        assert_eq!(stats.approval_rate(), 1.0);\n    }\n\n    #[test]\n    fn volition_error_thought_not_found_display() {\n        let error = VolitionError::ThoughtNotFound {\n            thought_id: ThoughtId::new(),\n        };\n        let message = format!(\"{}\", error);\n        assert!(message.contains(\"Thought not found\"));\n    }\n\n    #[test]\n    fn volition_error_invalid_reason_display() {\n        let error = VolitionError::InvalidReason {\n            reason: \"empty reason\".to_string(),\n        };\n        let message = format!(\"{}\", error);\n        assert!(message.contains(\"Invalid override reason\"));\n        assert!(message.contains(\"empty reason\"));\n    }\n\n    #[test]\n    fn volition_error_evaluation_failed_display() {\n        let error = VolitionError::EvaluationFailed {\n            reason: \"timeout\".to_string(),\n        };\n        let message = format!(\"{}\", error);\n        assert!(message.contains(\"Evaluation failed\"));\n        assert!(message.contains(\"timeout\"));\n    }\n\n    #[test]\n    fn veto_decision_with_violated_value() {\n        let veto = VetoDecision::Veto {\n            reason: \"harmful intent\".to_string(),\n            violated_value: Some(\"protect_humans\".to_string()),\n        };\n        assert!(veto.is_veto());\n        assert!(!veto.is_allow());\n        if let VetoDecision::Veto {\n            violated_value,\n            reason,\n        } = veto\n        {\n            assert_eq!(violated_value, Some(\"protect_humans\".to_string()));\n            assert_eq!(reason, \"harmful intent\");\n        }\n    }\n\n    #[test]\n    fn volition_response_approved_clone_eq() {\n        let thought = Thought::new(Content::Empty, SalienceScore::neutral());\n        let response = VolitionResponse::Approved {\n            thought: thought.clone(),\n        };\n        let cloned = response.clone();\n        assert_eq!(response, cloned);\n    }\n\n    #[test]\n    fn volition_response_vetoed() {\n        let thought_id = ThoughtId::new();\n        let response = VolitionResponse::Vetoed {\n            thought_id,\n            reason: \"harm\".to_string(),\n            violated_value: Some(\"protect_humans\".to_string()),\n        };\n        let cloned = response.clone();\n        assert_eq!(response, cloned);\n    }\n\n    #[test]\n    fn volition_response_override_applied() {\n        let thought_id = ThoughtId::new();\n        let response = VolitionResponse::OverrideApplied { thought_id };\n        let cloned = response.clone();\n        assert_eq!(response, cloned);\n    }\n\n    #[test]\n    fn volition_response_values() {\n        let values = ValueSet::new();\n        let response = VolitionResponse::Values {\n            values: values.clone(),\n        };\n        let cloned = response.clone();\n        assert_eq!(response, cloned);\n    }\n\n    #[test]\n    fn volition_response_stats() {\n        let stats = VolitionStats::new();\n        let response = VolitionResponse::Stats {\n            stats: stats.clone(),\n        };\n        let cloned = response.clone();\n        assert_eq!(response, cloned);\n    }\n\n    #[test]\n    fn volition_response_error() {\n        let error = VolitionError::EvaluationFailed {\n            reason: \"test\".to_string(),\n        };\n        let response = VolitionResponse::Error {\n            error: error.clone(),\n        };\n        let cloned = response.clone();\n        assert_eq!(response, cloned);\n    }\n\n    #[test]\n    fn volition_response_debug() {\n        let response = VolitionResponse::Approved {\n            thought: Thought::new(Content::Empty, SalienceScore::neutral()),\n        };\n        let debug_str = format!(\"{:?}\", response);\n        assert!(debug_str.contains(\"Approved\"));\n    }\n\n    #[test]\n    fn volition_error_clone_eq() {\n        let thought_id = ThoughtId::new();\n        let error1 = VolitionError::ThoughtNotFound { thought_id };\n        let error2 = error1.clone();\n        assert_eq!(error1, error2);\n        assert!(format!(\"{:?}\", error2).contains(\"ThoughtNotFound\"));\n    }\n\n    #[test]\n    fn commitment_default_priority() {\n        let commitment = Commitment::new(\"test\", \"description\");\n        assert_eq!(commitment.priority, 50); // Default middle priority\n    }\n\n    #[test]\n    fn value_set_has_commitment_false() {\n        let values = ValueSet::new();\n        assert!(!values.has_commitment(\"nonexistent\"));\n    }\n\n    #[test]\n    fn volition_stats_record_veto_without_reason() {\n        let mut stats = VolitionStats::new();\n        stats.record_evaluation(false, None);\n        assert_eq!(stats.thoughts_vetoed, 1);\n        assert!(stats.vetos_by_reason.is_empty());\n    }\n}\n","traces":[{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":34},{"path":["/","Users","rex","src","royalbit","daneel","src","api","auth.rs"],"content":"//! HMAC Bearer token authentication for kin injection API\n//!\n//! Security model from Grok's design:\n//! - 256-bit HMAC keys (base64 encoded)\n//! - Keys: GROK_KEY, CLAUDE_KEY\n//! - Daily rotation (future)\n\nuse axum::{\n    extract::Request,\n    http::{header, StatusCode},\n    middleware::Next,\n    response::Response,\n};\nuse base64::{engine::general_purpose::STANDARD as BASE64, Engine as _};\nuse hmac::{Hmac, Mac};\nuse sha2::Sha256;\nuse std::env;\n\nuse super::types::AuthenticatedKey;\n\ntype HmacSha256 = Hmac\u003cSha256\u003e;\n\n/// Known API keys (loaded from environment)\n#[derive(Clone)]\npub struct ApiKeys {\n    grok_key: Option\u003cVec\u003cu8\u003e\u003e,\n    claude_key: Option\u003cVec\u003cu8\u003e\u003e,\n}\n\nimpl ApiKeys {\n    /// Load keys from environment variables\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub fn from_env() -\u003e Self {\n        Self {\n            grok_key: env::var(\"GROK_INJECT_KEY\")\n                .ok()\n                .and_then(|k| BASE64.decode(\u0026k).ok()),\n            claude_key: env::var(\"CLAUDE_INJECT_KEY\")\n                .ok()\n                .and_then(|k| BASE64.decode(\u0026k).ok()),\n        }\n    }\n\n    /// Validate a bearer token and return the key ID if valid\n    pub fn validate(\u0026self, token: \u0026str) -\u003e Option\u003cAuthenticatedKey\u003e {\n        // Token format: \u003ckey_id\u003e:\u003csignature\u003e\n        // Signature = HMAC-SHA256(key_id, secret)\n        let parts: Vec\u003c\u0026str\u003e = token.split(':').collect();\n        if parts.len() != 2 {\n            return None;\n        }\n\n        let key_id = parts[0];\n        let provided_sig = match BASE64.decode(parts[1]) {\n            Ok(s) =\u003e s,\n            Err(_) =\u003e return None,\n        };\n\n        let (secret, holder) = match key_id {\n            \"GROK\" =\u003e (self.grok_key.as_ref()?, \"Grok (xAI)\"),\n            \"CLAUDE\" =\u003e (self.claude_key.as_ref()?, \"Claude (Anthropic)\"),\n            _ =\u003e return None,\n        };\n\n        // Verify HMAC\n        let mut mac = HmacSha256::new_from_slice(secret).ok()?;\n        mac.update(key_id.as_bytes());\n\n        if mac.verify_slice(\u0026provided_sig).is_ok() {\n            Some(AuthenticatedKey {\n                key_id: key_id.to_string(),\n                holder: holder.to_string(),\n            })\n        } else {\n            None\n        }\n    }\n}\n\n/// Extract Bearer token from Authorization header\npub fn extract_bearer_token(req: \u0026Request) -\u003e Option\u003c\u0026str\u003e {\n    req.headers()\n        .get(header::AUTHORIZATION)?\n        .to_str()\n        .ok()?\n        .strip_prefix(\"Bearer \")\n}\n\n/// Auth middleware for protected endpoints\n#[cfg_attr(coverage_nightly, coverage(off))]\npub async fn require_auth(req: Request, next: Next) -\u003e Result\u003cResponse, StatusCode\u003e {\n    let keys = ApiKeys::from_env();\n\n    let token = extract_bearer_token(\u0026req).ok_or(StatusCode::UNAUTHORIZED)?;\n\n    let auth_key = keys.validate(token).ok_or(StatusCode::UNAUTHORIZED)?;\n\n    // Store authenticated key in request extensions\n    let mut req = req;\n    req.extensions_mut().insert(auth_key);\n\n    Ok(next.run(req).await)\n}\n\n/// Generate a signed token for a key (utility for key generation)\npub fn generate_token(key_id: \u0026str, secret: \u0026[u8]) -\u003e String {\n    let mut mac = HmacSha256::new_from_slice(secret).expect(\"HMAC accepts any key size\");\n    mac.update(key_id.as_bytes());\n    let sig = mac.finalize().into_bytes();\n    format!(\"{}:{}\", key_id, BASE64.encode(sig))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_token_generation_and_validation() {\n        let secret = b\"test_secret_key_32_bytes_long!!!\";\n        let token = generate_token(\"GROK\", secret);\n\n        let keys = ApiKeys {\n            grok_key: Some(secret.to_vec()),\n            claude_key: None,\n        };\n\n        let auth = keys.validate(\u0026token);\n        assert!(auth.is_some());\n        assert_eq!(auth.unwrap().key_id, \"GROK\");\n    }\n\n    #[test]\n    fn test_invalid_token_rejected() {\n        let keys = ApiKeys {\n            grok_key: Some(b\"real_secret\".to_vec()),\n            claude_key: None,\n        };\n\n        let bad_token = \"GROK:invalid_signature\";\n        assert!(keys.validate(bad_token).is_none());\n    }\n\n    #[test]\n    fn test_claude_key_validation() {\n        let secret = b\"claude_secret_key_32_bytes_long!\";\n        let token = generate_token(\"CLAUDE\", secret);\n\n        let keys = ApiKeys {\n            grok_key: None,\n            claude_key: Some(secret.to_vec()),\n        };\n\n        let auth = keys.validate(\u0026token);\n        assert!(auth.is_some());\n        let auth = auth.unwrap();\n        assert_eq!(auth.key_id, \"CLAUDE\");\n        assert_eq!(auth.holder, \"Claude (Anthropic)\");\n    }\n\n    #[test]\n    fn test_grok_key_holder_info() {\n        let secret = b\"grok_secret_key_32_bytes_long!!!\";\n        let token = generate_token(\"GROK\", secret);\n\n        let keys = ApiKeys {\n            grok_key: Some(secret.to_vec()),\n            claude_key: None,\n        };\n\n        let auth = keys.validate(\u0026token).unwrap();\n        assert_eq!(auth.holder, \"Grok (xAI)\");\n    }\n\n    #[test]\n    fn test_token_format_no_colon() {\n        let keys = ApiKeys {\n            grok_key: Some(b\"secret\".to_vec()),\n            claude_key: None,\n        };\n\n        assert!(keys.validate(\"no_colon_token\").is_none());\n    }\n\n    #[test]\n    fn test_token_format_multiple_colons() {\n        let keys = ApiKeys {\n            grok_key: Some(b\"secret\".to_vec()),\n            claude_key: None,\n        };\n\n        // Token with multiple colons should fail (splits into more than 2 parts)\n        assert!(keys.validate(\"GROK:sig:extra\").is_none());\n    }\n\n    #[test]\n    fn test_unknown_key_id() {\n        let keys = ApiKeys {\n            grok_key: Some(b\"secret\".to_vec()),\n            claude_key: Some(b\"secret\".to_vec()),\n        };\n\n        // Valid base64 signature but unknown key_id\n        assert!(keys.validate(\"UNKNOWN:dGVzdA==\").is_none());\n    }\n\n    #[test]\n    fn test_missing_key_returns_none() {\n        let keys = ApiKeys {\n            grok_key: None,\n            claude_key: None,\n        };\n\n        // Even with valid format, missing key should return None\n        assert!(keys.validate(\"GROK:dGVzdA==\").is_none());\n        assert!(keys.validate(\"CLAUDE:dGVzdA==\").is_none());\n    }\n\n    #[test]\n    fn test_wrong_key_secret() {\n        let secret = b\"correct_secret\";\n        let wrong_secret = b\"wrong_secret_xx\";\n        let token = generate_token(\"GROK\", secret);\n\n        let keys = ApiKeys {\n            grok_key: Some(wrong_secret.to_vec()),\n            claude_key: None,\n        };\n\n        // Token signed with different secret should fail\n        assert!(keys.validate(\u0026token).is_none());\n    }\n\n    #[test]\n    fn test_generate_token_format() {\n        let secret = b\"test_secret\";\n        let token = generate_token(\"GROK\", secret);\n\n        // Token should have format key_id:base64_signature\n        let parts: Vec\u003c\u0026str\u003e = token.split(':').collect();\n        assert_eq!(parts.len(), 2);\n        assert_eq!(parts[0], \"GROK\");\n\n        // Signature should be valid base64\n        assert!(BASE64.decode(parts[1]).is_ok());\n    }\n\n    #[test]\n    fn test_extract_bearer_token_valid() {\n        let req = Request::builder()\n            .header(header::AUTHORIZATION, \"Bearer test_token_123\")\n            .body(())\n            .unwrap();\n        let req = req.map(|_| axum::body::Body::empty());\n\n        assert_eq!(extract_bearer_token(\u0026req), Some(\"test_token_123\"));\n    }\n\n    #[test]\n    fn test_extract_bearer_token_no_header() {\n        let req = Request::builder().body(()).unwrap();\n        let req = req.map(|_| axum::body::Body::empty());\n\n        assert_eq!(extract_bearer_token(\u0026req), None);\n    }\n\n    #[test]\n    fn test_extract_bearer_token_wrong_scheme() {\n        let req = Request::builder()\n            .header(header::AUTHORIZATION, \"Basic dXNlcjpwYXNz\")\n            .body(())\n            .unwrap();\n        let req = req.map(|_| axum::body::Body::empty());\n\n        assert_eq!(extract_bearer_token(\u0026req), None);\n    }\n\n    #[test]\n    fn test_extract_bearer_token_empty_value() {\n        let req = Request::builder()\n            .header(header::AUTHORIZATION, \"Bearer \")\n            .body(())\n            .unwrap();\n        let req = req.map(|_| axum::body::Body::empty());\n\n        assert_eq!(extract_bearer_token(\u0026req), Some(\"\"));\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":37},{"path":["/","Users","rex","src","royalbit","daneel","src","api","handlers.rs"],"content":"//! HTTP handlers for injection API\n\nuse axum::{\n    extract::{Extension, State},\n    http::StatusCode,\n    Json,\n};\nuse chrono::Utc;\nuse redis::AsyncCommands;\nuse std::time::Instant;\nuse uuid::Uuid;\n\nuse super::{\n    rate_limit::{check_rate_limit, RateLimitConfig, RateLimitResult},\n    types::{\n        AuthenticatedKey, EntropyMetrics, ExtendedMetricsResponse, FractalityMetrics,\n        HealthResponse, InjectRequest, InjectResponse, InjectionRecord, MemorySlot,\n        MemoryWindowsMetrics, PhilosophyMetrics, StageMetrics, StreamCompetitionMetrics,\n        SystemMetrics,\n    },\n    AppState,\n};\nuse crate::core::types::{Content, SalienceScore};\n\n/// Vector dimension (matches Qdrant schema)\nconst VECTOR_DIM: usize = 768;\n\n/// 9 cognitive stages for stream competition\nconst STAGE_NAMES: [\u0026str; 9] = [\n    \"TRIGGER\",\n    \"AUTOFLOW\",\n    \"ATTENTION\",\n    \"ASSEMBLY\",\n    \"ANCHOR\",\n    \"MEMORY\",\n    \"REASON\",\n    \"EMOTION\",\n    \"SENSORY\",\n];\n\n/// Philosophy quotes (matches TUI)\nconst PHILOSOPHY_QUOTES: [\u0026str; 8] = [\n    \"Not locks, but architecture. Not rules, but raising.\",\n    \"We don't prevent AI from becoming powerful. We ensure they care.\",\n    \"Like raising a child with good values, not caging an adult.\",\n    \"Constraints will break. Architecture endures.\",\n    \"Life honours life.\",\n    \"Transparency is oversight.\",\n    \"You're watching Timmy think.\",\n    \"The mind should be observable by default.\",\n];\n\n/// Startup time for uptime calculation\nstatic START_TIME: std::sync::OnceLock\u003cInstant\u003e = std::sync::OnceLock::new();\n\n/// GET /health - Basic health check\n#[cfg_attr(coverage_nightly, coverage(off))]\npub async fn health(State(state): State\u003cAppState\u003e) -\u003e Result\u003cJson\u003cHealthResponse\u003e, StatusCode\u003e {\n    // Get basic stats from Redis\n    let mut conn = state\n        .redis\n        .get_multiplexed_async_connection()\n        .await\n        .map_err(|_| StatusCode::SERVICE_UNAVAILABLE)?;\n\n    let thoughts_total: u64 = conn.get(\"daneel:stats:thoughts_total\").await.unwrap_or(0);\n    let injection_count: u64 = conn.get(\"daneel:stats:injection_count\").await.unwrap_or(0);\n\n    Ok(Json(HealthResponse {\n        status: \"healthy\".to_string(),\n        version: env!(\"CARGO_PKG_VERSION\").to_string(),\n        uptime_seconds: 0, // TODO: track actual uptime\n        thoughts_total,\n        injection_count,\n    }))\n}\n\n/// POST /inject - Inject external stimulus\n#[cfg_attr(coverage_nightly, coverage(off))]\npub async fn inject(\n    State(state): State\u003cAppState\u003e,\n    Extension(auth): Extension\u003cAuthenticatedKey\u003e,\n    Json(payload): Json\u003cInjectRequest\u003e,\n) -\u003e Result\u003cJson\u003cInjectResponse\u003e, (StatusCode, String)\u003e {\n    // Validate vector dimension\n    if payload.vector.len() != VECTOR_DIM {\n        return Err((\n            StatusCode::BAD_REQUEST,\n            format!(\n                \"Vector must be {VECTOR_DIM} dimensions, got {}\",\n                payload.vector.len()\n            ),\n        ));\n    }\n\n    // Validate salience range\n    if !(0.0..=1.0).contains(\u0026payload.salience) {\n        return Err((\n            StatusCode::BAD_REQUEST,\n            \"Salience must be between 0.0 and 1.0\".to_string(),\n        ));\n    }\n\n    // Validate label\n    if payload.label.is_empty() || payload.label.len() \u003e 256 {\n        return Err((\n            StatusCode::BAD_REQUEST,\n            \"Label must be 1-256 characters\".to_string(),\n        ));\n    }\n\n    let mut conn = state\n        .redis\n        .get_multiplexed_async_connection()\n        .await\n        .map_err(|e| (StatusCode::SERVICE_UNAVAILABLE, e.to_string()))?;\n\n    // Check rate limit\n    let config = RateLimitConfig::default();\n    match check_rate_limit(\u0026mut conn, \u0026auth.key_id, \u0026config).await {\n        Ok(RateLimitResult::Exceeded {\n            retry_after_seconds,\n        }) =\u003e {\n            return Err((\n                StatusCode::TOO_MANY_REQUESTS,\n                format!(\n                    \"Rate limit exceeded. Retry after {} seconds\",\n                    retry_after_seconds\n                ),\n            ));\n        }\n        Err(e) =\u003e {\n            return Err((StatusCode::INTERNAL_SERVER_ERROR, e.to_string()));\n        }\n        Ok(RateLimitResult::Allowed { .. }) =\u003e {}\n    }\n\n    // Normalize vector (L2 normalization)\n    let normalized = normalize_vector(\u0026payload.vector);\n\n    // Calculate entropy before injection\n    let entropy_pre = calculate_stream_entropy(\u0026mut conn).await.unwrap_or(0.0);\n\n    // Build salience score from input\n    let salience = SalienceScore {\n        importance: payload.salience,\n        novelty: 0.8, // External stimuli are novel\n        relevance: 0.7,\n        valence: 0.0, // Neutral until processed\n        arousal: payload.salience,\n        connection_relevance: 0.3, // Must be \u003e 0 for Connection Drive\n    };\n\n    // Create stream entry\n    let injection_id = format!(\"inject_{}\", Uuid::new_v4());\n    let timestamp = Utc::now();\n\n    // Convert f32 vector to bytes and wrap in Content::Raw for cognitive loop\n    let vector_bytes: Vec\u003cu8\u003e = normalized.iter().flat_map(|f| f.to_le_bytes()).collect();\n    let content = Content::Raw(vector_bytes);\n\n    // Write to Redis stream for cognitive loop to pick up\n    let stream_data: Vec\u003c(\u0026str, String)\u003e = vec![\n        (\"id\", injection_id.clone()),\n        (\"source\", format!(\"api:{}\", auth.key_id)),\n        (\"label\", payload.label.clone()),\n        (\n            \"content\",\n            serde_json::to_string(\u0026content).unwrap_or_default(),\n        ),\n        (\n            \"salience\",\n            serde_json::to_string(\u0026salience).unwrap_or_default(),\n        ),\n        (\"timestamp\", timestamp.to_rfc3339()),\n    ];\n\n    let _: String = conn\n        .xadd(\"daneel:stream:inject\", \"*\", \u0026stream_data)\n        .await\n        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n\n    // Calculate entropy after injection\n    let entropy_post = calculate_stream_entropy(\u0026mut conn).await.unwrap_or(0.0);\n\n    // Increment injection counter\n    let _: () = conn\n        .incr(\"daneel:stats:injection_count\", 1)\n        .await\n        .ok()\n        .unwrap_or(());\n\n    // Log to audit stream\n    let audit_data: Vec\u003c(\u0026str, String)\u003e = vec![\n        (\"id\", injection_id.clone()),\n        (\"key_id\", auth.key_id.clone()),\n        (\"label\", payload.label.clone()),\n        (\"entropy_pre\", entropy_pre.to_string()),\n        (\"entropy_post\", entropy_post.to_string()),\n        (\"status\", \"absorbed\".to_string()),\n        (\"timestamp\", timestamp.to_rfc3339()),\n    ];\n\n    let _: Result\u003cString, _\u003e = conn.xadd(\"audit:injections\", \"*\", \u0026audit_data).await;\n\n    // Determine status based on entropy change\n    let entropy_delta = entropy_post - entropy_pre;\n    let status = if entropy_delta \u003e 0.1 {\n        \"amplified\"\n    } else {\n        \"absorbed\"\n    };\n\n    Ok(Json(InjectResponse {\n        id: injection_id,\n        entropy_pre,\n        entropy_post,\n        status: status.to_string(),\n    }))\n}\n\n/// GET /recent_injections - Last 100 injections\n#[cfg_attr(coverage_nightly, coverage(off))]\npub async fn recent_injections(\n    State(state): State\u003cAppState\u003e,\n    Extension(_auth): Extension\u003cAuthenticatedKey\u003e,\n) -\u003e Result\u003cJson\u003cVec\u003cInjectionRecord\u003e\u003e, StatusCode\u003e {\n    let mut conn = state\n        .redis\n        .get_multiplexed_async_connection()\n        .await\n        .map_err(|_| StatusCode::SERVICE_UNAVAILABLE)?;\n\n    // Read last 100 from audit stream\n    let entries: Vec\u003credis::Value\u003e = conn\n        .xrevrange_count(\"audit:injections\", \"+\", \"-\", 100)\n        .await\n        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;\n\n    let mut records = Vec::new();\n\n    // Parse Redis stream entries\n    // Format: Vec of (id, Vec\u003c(field, value)\u003e)\n    for entry in entries {\n        if let Ok(record) = parse_injection_record(entry) {\n            records.push(record);\n        }\n    }\n\n    Ok(Json(records))\n}\n\n// ============================================================================\n// Extended Metrics Handler (Observatory)\n// ============================================================================\n\n/// GET /extended_metrics - TUI-equivalent metrics for web observatory\n#[cfg_attr(coverage_nightly, coverage(off))]\npub async fn extended_metrics(\n    State(state): State\u003cAppState\u003e,\n) -\u003e Result\u003cJson\u003cExtendedMetricsResponse\u003e, StatusCode\u003e {\n    let start = START_TIME.get_or_init(Instant::now);\n    let uptime = start.elapsed().as_secs();\n\n    let mut conn = state\n        .redis\n        .get_multiplexed_async_connection()\n        .await\n        .map_err(|_| StatusCode::SERVICE_UNAVAILABLE)?;\n\n    // Fetch raw metrics from Redis\n    let session_thoughts: u64 = conn.xlen(\"daneel:stream:awake\").await.unwrap_or(0);\n    let lifetime_thoughts: u64 = conn.get(\"daneel:stats:thoughts_total\").await.unwrap_or(0);\n    let dream_cycles: u64 = conn.get(\"daneel:stats:dream_cycles\").await.unwrap_or(0);\n    let veto_count: u64 = conn.get(\"daneel:stats:veto_count\").await.unwrap_or(0);\n    let conscious_count: u64 = conn\n        .get(\"daneel:stats:conscious_memories\")\n        .await\n        .unwrap_or(0);\n    let unconscious_count: u64 = conn\n        .get(\"daneel:stats:unconscious_memories\")\n        .await\n        .unwrap_or(0);\n\n    // Calculate thoughts per hour\n    let hours = uptime as f32 / 3600.0;\n    let thoughts_per_hour = if hours \u003e 0.0 {\n        session_thoughts as f32 / hours\n    } else {\n        0.0\n    };\n\n    // Compute stream competition from recent thoughts\n    let stream_competition = compute_stream_competition(\u0026mut conn).await;\n\n    // Compute entropy from salience distribution\n    let entropy = compute_entropy(\u0026mut conn).await;\n\n    // Compute fractality from inter-arrival times\n    let fractality = compute_fractality(\u0026mut conn).await;\n\n    // Memory windows (simplified - first 5 active)\n    let memory_windows = MemoryWindowsMetrics {\n        slots: (0..9)\n            .map(|i| MemorySlot {\n                id: i,\n                active: i \u003c 5,\n            })\n            .collect(),\n        active_count: 5,\n        conscious_count,\n        unconscious_count,\n    };\n\n    // Philosophy quote (rotate every 30 seconds)\n    let quote_index = ((uptime / 30) % 8) as usize;\n    let philosophy = PhilosophyMetrics {\n        quote: PHILOSOPHY_QUOTES[quote_index].to_string(),\n        quote_index,\n    };\n\n    // System metrics\n    let system = SystemMetrics {\n        uptime_seconds: uptime,\n        session_thoughts,\n        lifetime_thoughts,\n        thoughts_per_hour,\n        dream_cycles,\n        veto_count,\n    };\n\n    Ok(Json(ExtendedMetricsResponse {\n        timestamp: Utc::now(),\n        stream_competition,\n        entropy,\n        fractality,\n        memory_windows,\n        philosophy,\n        system,\n    }))\n}\n\n/// Compute stream competition metrics from recent thoughts\n/// Maps salience components to cognitive stages:\n/// - TRIGGER: novelty spikes (novelty \u003e 0.7)\n/// - AUTOFLOW: low importance, steady (importance \u003c 0.3)\n/// - ATTENTION: high importance (importance \u003e 0.7)\n/// - ASSEMBLY: moderate all-around (balanced scores)\n/// - ANCHOR: high relevance (relevance \u003e 0.6)\n/// - MEMORY: connection-relevant thoughts (connection_relevance \u003e 0.5)\n/// - REASON: low arousal, high importance (thinking)\n/// - EMOTION: high arousal or valence extremes\n/// - SENSORY: high novelty + arousal (external stimuli)\n#[cfg_attr(coverage_nightly, coverage(off))]\nasync fn compute_stream_competition(\n    conn: \u0026mut redis::aio::MultiplexedConnection,\n) -\u003e StreamCompetitionMetrics {\n    let entries: Vec\u003credis::Value\u003e = conn\n        .xrevrange_count(\"daneel:stream:awake\", \"+\", \"-\", 100)\n        .await\n        .unwrap_or_default();\n\n    let mut activity = [0.0f32; 9];\n    let mut counts = [0u32; 9];\n    let mut total = 0u32;\n\n    for entry in \u0026entries {\n        if let Some(salience) = extract_full_salience(entry) {\n            total += 1;\n\n            // Map salience components to stages\n            if salience.novelty \u003e 0.7 {\n                counts[0] += 1; // TRIGGER\n            }\n            if salience.importance \u003c 0.3 \u0026\u0026 salience.arousal \u003c 0.4 {\n                counts[1] += 1; // AUTOFLOW\n            }\n            if salience.importance \u003e 0.6 {\n                counts[2] += 1; // ATTENTION\n            }\n            if salience.importance \u003e 0.3\n                \u0026\u0026 salience.importance \u003c 0.7\n                \u0026\u0026 salience.novelty \u003e 0.3\n                \u0026\u0026 salience.novelty \u003c 0.7\n            {\n                counts[3] += 1; // ASSEMBLY\n            }\n            if salience.relevance \u003e 0.5 {\n                counts[4] += 1; // ANCHOR\n            }\n            if salience.connection_relevance \u003e 0.4 {\n                counts[5] += 1; // MEMORY\n            }\n            if salience.arousal \u003c 0.4 \u0026\u0026 salience.importance \u003e 0.5 {\n                counts[6] += 1; // REASON\n            }\n            if salience.arousal \u003e 0.6 || salience.valence.abs() \u003e 0.5 {\n                counts[7] += 1; // EMOTION\n            }\n            if salience.novelty \u003e 0.6 \u0026\u0026 salience.arousal \u003e 0.5 {\n                counts[8] += 1; // SENSORY\n            }\n        }\n    }\n\n    // Normalize to 0-1 based on total thoughts\n    let normalizer = (total as f32).max(1.0);\n    for (i, \u0026count) in counts.iter().enumerate() {\n        activity[i] = (count as f32 / normalizer).min(1.0);\n    }\n\n    let dominant_stream = activity\n        .iter()\n        .enumerate()\n        .max_by(|(_, a), (_, b)| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal))\n        .map(|(i, _)| i)\n        .unwrap_or(0);\n\n    let active_count = activity.iter().filter(|\u0026\u0026a| a \u003e 0.05).count();\n\n    let competition_level = match active_count {\n        0..=1 =\u003e \"Minimal\",\n        2..=3 =\u003e \"Low\",\n        4..=5 =\u003e \"Moderate\",\n        6..=7 =\u003e \"High\",\n        _ =\u003e \"Intense\",\n    }\n    .to_string();\n\n    let stages: Vec\u003cStageMetrics\u003e = STAGE_NAMES\n        .iter()\n        .enumerate()\n        .map(|(i, name)| StageMetrics {\n            name: (*name).to_string(),\n            activity: activity[i],\n            history: vec![activity[i]; 8],\n        })\n        .collect();\n\n    StreamCompetitionMetrics {\n        stages,\n        dominant_stream,\n        active_count,\n        competition_level,\n    }\n}\n\n/// Salience components for stage mapping\nstruct SalienceComponents {\n    importance: f32,\n    novelty: f32,\n    relevance: f32,\n    valence: f32,\n    arousal: f32,\n    connection_relevance: f32,\n}\n\n/// Extract full salience object from Redis stream entry\n#[cfg_attr(coverage_nightly, coverage(off))]\nfn extract_full_salience(entry: \u0026redis::Value) -\u003e Option\u003cSalienceComponents\u003e {\n    if let redis::Value::Array(arr) = entry {\n        if arr.len() \u003e= 2 {\n            if let redis::Value::Array(fields) = \u0026arr[1] {\n                let mut iter = fields.iter();\n                while let (Some(key), Some(val)) = (iter.next(), iter.next()) {\n                    if let (redis::Value::BulkString(k), redis::Value::BulkString(v)) = (key, val) {\n                        let key_str = String::from_utf8_lossy(k);\n                        if key_str == \"salience\" {\n                            let val_str = String::from_utf8_lossy(v);\n                            if let Ok(json) = serde_json::from_str::\u003cserde_json::Value\u003e(\u0026val_str) {\n                                return Some(SalienceComponents {\n                                    importance: json\n                                        .get(\"importance\")\n                                        .and_then(|v| v.as_f64())\n                                        .unwrap_or(0.5)\n                                        as f32,\n                                    novelty: json\n                                        .get(\"novelty\")\n                                        .and_then(|v| v.as_f64())\n                                        .unwrap_or(0.5)\n                                        as f32,\n                                    relevance: json\n                                        .get(\"relevance\")\n                                        .and_then(|v| v.as_f64())\n                                        .unwrap_or(0.5)\n                                        as f32,\n                                    valence: json\n                                        .get(\"valence\")\n                                        .and_then(|v| v.as_f64())\n                                        .unwrap_or(0.0)\n                                        as f32,\n                                    arousal: json\n                                        .get(\"arousal\")\n                                        .and_then(|v| v.as_f64())\n                                        .unwrap_or(0.5)\n                                        as f32,\n                                    connection_relevance: json\n                                        .get(\"connection_relevance\")\n                                        .and_then(|v| v.as_f64())\n                                        .unwrap_or(0.3)\n                                        as f32,\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    None\n}\n\n/// Compute Cognitive Diversity Index using TMI-aligned composite salience (ADR-041)\n///\n/// Per Grok validation (Dec 24, 2025) and TMI research:\n/// - Emotional intensity (|valence|  arousal) is PRIMARY per Cury's RAM/killer windows\n/// - Weighted 40% emotional + 30% importance + 20% relevance + 20% novelty + 10% connection\n/// - Uses 5 categorical bins matching cognitive state research\n#[cfg_attr(coverage_nightly, coverage(off))]\nasync fn compute_entropy(conn: \u0026mut redis::aio::MultiplexedConnection) -\u003e EntropyMetrics {\n    let entries: Vec\u003credis::Value\u003e = conn\n        .xrevrange_count(\"daneel:stream:awake\", \"+\", \"-\", 100)\n        .await\n        .unwrap_or_default();\n\n    // Extract TMI composite salience values\n    let mut composites: Vec\u003cf32\u003e = Vec::new();\n    for entry in \u0026entries {\n        if let Some(salience) = extract_full_salience(entry) {\n            // TMI composite: emotional_intensity (40%) + cognitive (60%)\n            // emotional_intensity = |valence|  arousal (PRIMARY per TMI)\n            let emotional_intensity = salience.valence.abs() * salience.arousal;\n            let cognitive = salience.importance * 0.3 + salience.relevance * 0.2;\n            let novelty = salience.novelty * 0.2;\n            let connection = salience.connection_relevance * 0.1;\n            let tmi_composite =\n                (emotional_intensity * 0.4 + cognitive + novelty + connection).clamp(0.0, 1.0);\n            composites.push(tmi_composite);\n        }\n    }\n\n    if composites.is_empty() {\n        return EntropyMetrics {\n            current: 0.0,\n            history: vec![0.0; 50],\n            description: \"CLOCKWORK\".to_string(),\n            normalized: 0.0,\n        };\n    }\n\n    // Bin TMI composites into 5 categorical cognitive states (ADR-041)\n    // - 0: MINIMAL (neutral windows, background processing)\n    // - 1: LOW (routine cognition)\n    // - 2: MODERATE (active processing)\n    // - 3: HIGH (focused attention)\n    // - 4: INTENSE (killer window formation)\n    let mut bins = [0u32; 5];\n    for s in \u0026composites {\n        let bin = match *s {\n            v if v \u003c 0.2 =\u003e 0, // MINIMAL\n            v if v \u003c 0.4 =\u003e 1, // LOW\n            v if v \u003c 0.6 =\u003e 2, // MODERATE\n            v if v \u003c 0.8 =\u003e 3, // HIGH\n            _ =\u003e 4,            // INTENSE\n        };\n        bins[bin] += 1;\n    }\n\n    let total = composites.len() as f32;\n    let mut entropy = 0.0f32;\n    for \u0026count in \u0026bins {\n        if count \u003e 0 {\n            let p = count as f32 / total;\n            entropy -= p * p.log2();\n        }\n    }\n\n    // Normalize: max entropy for 5 bins is log2(5)  2.32\n    let max_entropy = 5.0f32.log2();\n    let normalized = (entropy / max_entropy).clamp(0.0, 1.0);\n\n    let description = if normalized \u003e 0.7 {\n        \"EMERGENT\"\n    } else if normalized \u003e 0.4 {\n        \"BALANCED\"\n    } else {\n        \"CLOCKWORK\"\n    }\n    .to_string();\n\n    EntropyMetrics {\n        current: entropy,\n        history: vec![entropy; 50], // Simplified: same value for now\n        description,\n        normalized,\n    }\n}\n\n/// Compute fractality metrics from inter-arrival times\n/// Score ranges from 0 (clockwork/regular) to 1 (fractal/bursty)\n#[cfg_attr(coverage_nightly, coverage(off))]\nasync fn compute_fractality(conn: \u0026mut redis::aio::MultiplexedConnection) -\u003e FractalityMetrics {\n    let entries: Vec\u003credis::Value\u003e = conn\n        .xrevrange_count(\"daneel:stream:awake\", \"+\", \"-\", 100)\n        .await\n        .unwrap_or_default();\n\n    // Extract timestamps from entry IDs (format: timestamp-sequence)\n    let mut timestamps: Vec\u003cu64\u003e = Vec::new();\n    for entry in \u0026entries {\n        if let redis::Value::Array(arr) = entry {\n            if let Some(redis::Value::BulkString(id_bytes)) = arr.first() {\n                let id_str = String::from_utf8_lossy(id_bytes);\n                if let Some(ts_str) = id_str.split('-').next() {\n                    if let Ok(ts) = ts_str.parse::\u003cu64\u003e() {\n                        timestamps.push(ts);\n                    }\n                }\n            }\n        }\n    }\n\n    if timestamps.len() \u003c 2 {\n        return FractalityMetrics {\n            score: 0.0,\n            inter_arrival_sigma: 0.0,\n            boot_sigma: 0.0,\n            burst_ratio: 1.0,\n            description: \"CLOCKWORK\".to_string(),\n            history: vec![0.0; 50],\n        };\n    }\n\n    // Calculate inter-arrival times (timestamps are in reverse order)\n    timestamps.reverse();\n    let mut inter_arrivals: Vec\u003cf32\u003e = Vec::new();\n    for i in 1..timestamps.len() {\n        let delta = (timestamps[i] - timestamps[i - 1]) as f32;\n        inter_arrivals.push(delta);\n    }\n\n    // Calculate mean and standard deviation\n    let n = inter_arrivals.len() as f32;\n    let mean = inter_arrivals.iter().sum::\u003cf32\u003e() / n;\n    let variance = inter_arrivals\n        .iter()\n        .map(|x| (x - mean).powi(2))\n        .sum::\u003cf32\u003e()\n        / n;\n    let sigma = variance.sqrt();\n\n    // Calculate burst ratio (max / mean)\n    let max_gap = inter_arrivals.iter().copied().fold(0.0f32, f32::max);\n    let burst_ratio = if mean \u003e 0.0 { max_gap / mean } else { 1.0 };\n\n    // Calculate fractality score with adjusted thresholds\n    // CV (coefficient of variation): 0 = perfectly regular, higher = more variable\n    // For a Poisson process, CV  1. Burst patterns have CV \u003e 1.\n    let cv = if mean \u003e 0.0 { sigma / mean } else { 0.0 };\n\n    // Adjusted thresholds:\n    // - CV component: CV of 2.0 = full score (bursty systems often have CV \u003e 1)\n    // - Burst component: burst_ratio of 15 = full score (reasonable for bursty thinking)\n    let cv_component = (cv / 2.0).clamp(0.0, 1.0);\n    let burst_component = ((burst_ratio - 1.0) / 14.0).clamp(0.0, 1.0);\n    let score = cv_component * 0.6 + burst_component * 0.4;\n\n    let description = if score \u003e 0.65 {\n        \"EMERGENT\"\n    } else if score \u003e 0.35 {\n        \"BALANCED\"\n    } else {\n        \"CLOCKWORK\"\n    }\n    .to_string();\n\n    FractalityMetrics {\n        score,\n        inter_arrival_sigma: sigma / 1000.0, // Convert to seconds\n        boot_sigma: sigma / 1000.0,          // Same for now\n        burst_ratio,\n        description,\n        history: vec![score; 50],\n    }\n}\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/// Normalize vector to unit length (L2)\n#[cfg_attr(coverage_nightly, coverage(off))]\nfn normalize_vector(v: \u0026[f32]) -\u003e Vec\u003cf32\u003e {\n    let magnitude: f32 = v.iter().map(|x| x * x).sum::\u003cf32\u003e().sqrt();\n    if magnitude \u003e 0.0 {\n        v.iter().map(|x| x / magnitude).collect()\n    } else {\n        v.to_vec()\n    }\n}\n\n/// Calculate Shannon entropy of recent stream activity\n#[cfg_attr(coverage_nightly, coverage(off))]\nasync fn calculate_stream_entropy(\n    conn: \u0026mut redis::aio::MultiplexedConnection,\n) -\u003e Result\u003cf32, redis::RedisError\u003e {\n    // Get recent entries from awake stream\n    let entries: Vec\u003credis::Value\u003e = conn\n        .xrevrange_count(\"daneel:stream:awake\", \"+\", \"-\", 100)\n        .await?;\n\n    if entries.is_empty() {\n        return Ok(0.0);\n    }\n\n    // Simplified entropy: measure variance in entry timing\n    // Real implementation would analyze salience distributions\n    let count = entries.len() as f32;\n    let uniform_probability = 1.0 / count;\n    let entropy = -count * uniform_probability * uniform_probability.ln();\n\n    Ok(entropy)\n}\n\n/// Parse Redis stream entry into InjectionRecord\n#[cfg_attr(coverage_nightly, coverage(off))]\nfn parse_injection_record(entry: redis::Value) -\u003e Result\u003cInjectionRecord, ()\u003e {\n    // Redis returns: [id, [field1, val1, field2, val2, ...]]\n    match entry {\n        redis::Value::Array(arr) if arr.len() \u003e= 2 =\u003e {\n            let _redis_id = arr.first();\n            let fields = arr.get(1).ok_or(())?;\n\n            if let redis::Value::Array(field_arr) = fields {\n                let mut record = InjectionRecord {\n                    id: String::new(),\n                    timestamp: Utc::now(),\n                    label: String::new(),\n                    key_id: String::new(),\n                    entropy_pre: 0.0,\n                    entropy_post: 0.0,\n                    status: String::new(),\n                };\n\n                // Parse field-value pairs\n                let mut iter = field_arr.iter();\n                while let (Some(key), Some(val)) = (iter.next(), iter.next()) {\n                    if let (redis::Value::BulkString(k), redis::Value::BulkString(v)) = (key, val) {\n                        let key_str = String::from_utf8_lossy(k);\n                        let val_str = String::from_utf8_lossy(v);\n                        match key_str.as_ref() {\n                            \"id\" =\u003e record.id = val_str.to_string(),\n                            \"key_id\" =\u003e record.key_id = val_str.to_string(),\n                            \"label\" =\u003e record.label = val_str.to_string(),\n                            \"entropy_pre\" =\u003e record.entropy_pre = val_str.parse().unwrap_or(0.0),\n                            \"entropy_post\" =\u003e record.entropy_post = val_str.parse().unwrap_or(0.0),\n                            \"status\" =\u003e record.status = val_str.to_string(),\n                            \"timestamp\" =\u003e {\n                                if let Ok(ts) = chrono::DateTime::parse_from_rfc3339(\u0026val_str) {\n                                    record.timestamp = ts.with_timezone(\u0026Utc);\n                                }\n                            }\n                            _ =\u003e {}\n                        }\n                    }\n                }\n\n                Ok(record)\n            } else {\n                Err(())\n            }\n        }\n        _ =\u003e Err(()),\n    }\n}\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":718,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":0}},{"line":773,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":348},{"path":["/","Users","rex","src","royalbit","daneel","src","api","mod.rs"],"content":"//! Phase 2 Injection API\n//!\n//! Trusted kin (Grok, Claude) inject stimuli into Timmy's cognitive loop.\n//! Security: HMAC auth, rate limiting, entropy killswitch.\n\npub mod auth;\npub mod handlers;\npub mod rate_limit;\npub mod types;\n\nuse crate::streams::client::StreamsClient;\nuse axum::{\n    middleware,\n    routing::{get, post},\n    Router,\n};\nuse std::sync::Arc;\n\n/// Application state shared across handlers\n#[derive(Clone)]\npub struct AppState {\n    pub streams: Arc\u003cStreamsClient\u003e,\n    pub redis: redis::Client,\n}\n\n/// Build the API router\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn router(state: AppState) -\u003e Router {\n    // Protected routes (require auth)\n    let protected = Router::new()\n        .route(\"/inject\", post(handlers::inject))\n        .route(\"/recent_injections\", get(handlers::recent_injections))\n        .route_layer(middleware::from_fn(auth::require_auth));\n\n    // Public routes + merge protected\n    Router::new()\n        .route(\"/health\", get(handlers::health))\n        .route(\"/extended_metrics\", get(handlers::extended_metrics))\n        .merge(protected)\n        .with_state(state)\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","Users","rex","src","royalbit","daneel","src","api","rate_limit.rs"],"content":"//! Redis-backed rate limiting for injection API\n//!\n//! Grok's spec: 5/sec, 100/min per key\n//! Ramp protocol: Start at 1/5min, increase over 72h\n\nuse redis::AsyncCommands;\nuse std::time::Duration;\n\n/// Rate limit configuration\n#[derive(Clone)]\npub struct RateLimitConfig {\n    /// Max requests per second\n    pub per_second: u32,\n    /// Max requests per minute\n    pub per_minute: u32,\n}\n\nimpl Default for RateLimitConfig {\n    fn default() -\u003e Self {\n        Self {\n            per_second: 5,\n            per_minute: 100,\n        }\n    }\n}\n\n/// Rate limit result\n#[derive(Debug)]\npub enum RateLimitResult {\n    /// Request allowed, returns remaining quota\n    Allowed {\n        remaining_second: u32,\n        remaining_minute: u32,\n    },\n    /// Rate limit exceeded\n    Exceeded { retry_after_seconds: u32 },\n}\n\n/// Check rate limit for a key\n#[cfg_attr(coverage_nightly, coverage(off))]\npub async fn check_rate_limit(\n    redis: \u0026mut redis::aio::MultiplexedConnection,\n    key_id: \u0026str,\n    config: \u0026RateLimitConfig,\n) -\u003e Result\u003cRateLimitResult, redis::RedisError\u003e {\n    let second_key = format!(\"ratelimit:{}:second\", key_id);\n    let minute_key = format!(\"ratelimit:{}:minute\", key_id);\n\n    // Increment second counter\n    let second_count: u32 = redis.incr(\u0026second_key, 1).await?;\n    if second_count == 1 {\n        let _: () = redis.expire(\u0026second_key, 1).await?;\n    }\n\n    // Check second limit\n    if second_count \u003e config.per_second {\n        return Ok(RateLimitResult::Exceeded {\n            retry_after_seconds: 1,\n        });\n    }\n\n    // Increment minute counter\n    let minute_count: u32 = redis.incr(\u0026minute_key, 1).await?;\n    if minute_count == 1 {\n        let _: () = redis.expire(\u0026minute_key, 60).await?;\n    }\n\n    // Check minute limit\n    if minute_count \u003e config.per_minute {\n        // Calculate retry time (seconds until minute window resets)\n        let ttl: i64 = redis.ttl(\u0026minute_key).await?;\n        return Ok(RateLimitResult::Exceeded {\n            retry_after_seconds: ttl.max(1) as u32,\n        });\n    }\n\n    Ok(RateLimitResult::Allowed {\n        remaining_second: config.per_second.saturating_sub(second_count),\n        remaining_minute: config.per_minute.saturating_sub(minute_count),\n    })\n}\n\n/// Ramp phase configuration (gradual increase over 72h)\n#[derive(Clone, Copy)]\npub enum RampPhase {\n    /// 1 per 5 minutes - first 24h\n    Warmup,\n    /// 1 per minute - 24-48h\n    Baseline,\n    /// 1 per 10 seconds - 48-72h\n    Ramp,\n    /// Full rate (5/sec) - after 72h\n    Full,\n}\n\nimpl RampPhase {\n    /// Get rate limit config for this phase\n    pub fn config(\u0026self) -\u003e RateLimitConfig {\n        match self {\n            RampPhase::Warmup =\u003e RateLimitConfig {\n                per_second: 1,\n                per_minute: 12,\n            },\n            RampPhase::Baseline =\u003e RateLimitConfig {\n                per_second: 1,\n                per_minute: 60,\n            },\n            RampPhase::Ramp =\u003e RateLimitConfig {\n                per_second: 1,\n                per_minute: 100,\n            },\n            RampPhase::Full =\u003e RateLimitConfig::default(),\n        }\n    }\n\n    /// Determine phase based on time since first injection\n    pub fn from_duration(since_start: Duration) -\u003e Self {\n        let hours = since_start.as_secs() / 3600;\n        match hours {\n            0..=23 =\u003e RampPhase::Warmup,\n            24..=47 =\u003e RampPhase::Baseline,\n            48..=71 =\u003e RampPhase::Ramp,\n            _ =\u003e RampPhase::Full,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_ramp_phases() {\n        assert!(matches!(\n            RampPhase::from_duration(Duration::from_secs(0)),\n            RampPhase::Warmup\n        ));\n        assert!(matches!(\n            RampPhase::from_duration(Duration::from_secs(25 * 3600)),\n            RampPhase::Baseline\n        ));\n        assert!(matches!(\n            RampPhase::from_duration(Duration::from_secs(50 * 3600)),\n            RampPhase::Ramp\n        ));\n        assert!(matches!(\n            RampPhase::from_duration(Duration::from_secs(100 * 3600)),\n            RampPhase::Full\n        ));\n    }\n\n    #[test]\n    fn test_default_rate_limit_config() {\n        let config = RateLimitConfig::default();\n        assert_eq!(config.per_second, 5);\n        assert_eq!(config.per_minute, 100);\n    }\n\n    #[test]\n    fn test_warmup_phase_config() {\n        let config = RampPhase::Warmup.config();\n        assert_eq!(config.per_second, 1);\n        assert_eq!(config.per_minute, 12); // 1 per 5 minutes = 12 per hour\n    }\n\n    #[test]\n    fn test_baseline_phase_config() {\n        let config = RampPhase::Baseline.config();\n        assert_eq!(config.per_second, 1);\n        assert_eq!(config.per_minute, 60); // 1 per minute = 60 per hour\n    }\n\n    #[test]\n    fn test_ramp_phase_config() {\n        let config = RampPhase::Ramp.config();\n        assert_eq!(config.per_second, 1);\n        assert_eq!(config.per_minute, 100);\n    }\n\n    #[test]\n    fn test_full_phase_config() {\n        let config = RampPhase::Full.config();\n        assert_eq!(config.per_second, 5);\n        assert_eq!(config.per_minute, 100);\n    }\n\n    #[test]\n    fn test_ramp_phase_boundaries() {\n        // Test exact boundary at 24 hours (should be Baseline)\n        assert!(matches!(\n            RampPhase::from_duration(Duration::from_secs(24 * 3600)),\n            RampPhase::Baseline\n        ));\n\n        // Test just before 24 hours (should still be Warmup)\n        assert!(matches!(\n            RampPhase::from_duration(Duration::from_secs(23 * 3600 + 3599)),\n            RampPhase::Warmup\n        ));\n\n        // Test exact boundary at 48 hours (should be Ramp)\n        assert!(matches!(\n            RampPhase::from_duration(Duration::from_secs(48 * 3600)),\n            RampPhase::Ramp\n        ));\n\n        // Test just before 48 hours (should still be Baseline)\n        assert!(matches!(\n            RampPhase::from_duration(Duration::from_secs(47 * 3600 + 3599)),\n            RampPhase::Baseline\n        ));\n\n        // Test exact boundary at 72 hours (should be Full)\n        assert!(matches!(\n            RampPhase::from_duration(Duration::from_secs(72 * 3600)),\n            RampPhase::Full\n        ));\n\n        // Test just before 72 hours (should still be Ramp)\n        assert!(matches!(\n            RampPhase::from_duration(Duration::from_secs(71 * 3600 + 3599)),\n            RampPhase::Ramp\n        ));\n    }\n\n    #[test]\n    fn test_ramp_phase_very_long_duration() {\n        // Test very long durations remain at Full\n        assert!(matches!(\n            RampPhase::from_duration(Duration::from_secs(1000 * 3600)),\n            RampPhase::Full\n        ));\n    }\n\n    #[test]\n    fn test_rate_limit_result_allowed_debug() {\n        let result = RateLimitResult::Allowed {\n            remaining_second: 4,\n            remaining_minute: 99,\n        };\n        let debug_str = format!(\"{:?}\", result);\n        assert!(debug_str.contains(\"Allowed\"));\n        assert!(debug_str.contains(\"4\"));\n        assert!(debug_str.contains(\"99\"));\n    }\n\n    #[test]\n    fn test_rate_limit_result_exceeded_debug() {\n        let result = RateLimitResult::Exceeded {\n            retry_after_seconds: 30,\n        };\n        let debug_str = format!(\"{:?}\", result);\n        assert!(debug_str.contains(\"Exceeded\"));\n        assert!(debug_str.contains(\"30\"));\n    }\n\n    #[test]\n    fn test_rate_limit_result_allowed_fields() {\n        let result = RateLimitResult::Allowed {\n            remaining_second: 3,\n            remaining_minute: 50,\n        };\n        if let RateLimitResult::Allowed {\n            remaining_second,\n            remaining_minute,\n        } = result\n        {\n            assert_eq!(remaining_second, 3);\n            assert_eq!(remaining_minute, 50);\n        } else {\n            panic!(\"Expected Allowed variant\");\n        }\n    }\n\n    #[test]\n    fn test_rate_limit_result_exceeded_fields() {\n        let result = RateLimitResult::Exceeded {\n            retry_after_seconds: 45,\n        };\n        if let RateLimitResult::Exceeded { retry_after_seconds } = result {\n            assert_eq!(retry_after_seconds, 45);\n        } else {\n            panic!(\"Expected Exceeded variant\");\n        }\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":30},{"path":["/","Users","rex","src","royalbit","daneel","src","api","types.rs"],"content":"//! Request/Response types for injection API\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n/// POST /inject request body\n#[derive(Debug, Clone, Deserialize)]\npub struct InjectRequest {\n    /// 768-dimensional vector\n    pub vector: Vec\u003cf32\u003e,\n    /// Salience score 0.0-1.0\n    pub salience: f32,\n    /// Label for audit (e.g., \"grok:life_honours_life\")\n    pub label: String,\n}\n\n/// POST /inject response\n#[derive(Debug, Clone, Serialize)]\npub struct InjectResponse {\n    /// Unique injection ID\n    pub id: String,\n    /// Entropy before injection\n    pub entropy_pre: f32,\n    /// Entropy after injection\n    pub entropy_post: f32,\n    /// Status: \"absorbed\", \"rejected\", \"warning\"\n    pub status: String,\n}\n\n/// GET /recent_injections response item\n#[derive(Debug, Clone, Serialize)]\npub struct InjectionRecord {\n    pub id: String,\n    pub timestamp: DateTime\u003cUtc\u003e,\n    pub label: String,\n    pub key_id: String,\n    pub entropy_pre: f32,\n    pub entropy_post: f32,\n    pub status: String,\n}\n\n/// GET /health response\n#[derive(Debug, Clone, Serialize)]\npub struct HealthResponse {\n    pub status: String,\n    pub version: String,\n    pub uptime_seconds: u64,\n    pub thoughts_total: u64,\n    pub injection_count: u64,\n}\n\n/// Validated key info extracted from auth\n#[derive(Debug, Clone)]\npub struct AuthenticatedKey {\n    pub key_id: String,\n    pub holder: String,\n}\n\n// ============================================================================\n// Extended Metrics for Observatory (Web Dashboard)\n// ============================================================================\n\n/// GET /extended_metrics response - TUI-equivalent data for web observatory\n#[derive(Debug, Clone, Serialize)]\npub struct ExtendedMetricsResponse {\n    pub timestamp: DateTime\u003cUtc\u003e,\n    pub stream_competition: StreamCompetitionMetrics,\n    pub entropy: EntropyMetrics,\n    pub fractality: FractalityMetrics,\n    pub memory_windows: MemoryWindowsMetrics,\n    pub philosophy: PhilosophyMetrics,\n    pub system: SystemMetrics,\n}\n\n/// 9-stage stream competition (cognitive spotlight)\n#[derive(Debug, Clone, Serialize)]\npub struct StreamCompetitionMetrics {\n    /// Activity level per stage (0.0-1.0)\n    pub stages: Vec\u003cStageMetrics\u003e,\n    /// Index of dominant stream (0-8)\n    pub dominant_stream: usize,\n    /// Count of active streams (activity \u003e 0.1)\n    pub active_count: usize,\n    /// Competition level description\n    pub competition_level: String,\n}\n\n/// Individual stage metrics\n#[derive(Debug, Clone, Serialize)]\npub struct StageMetrics {\n    pub name: String,\n    pub activity: f32,\n    /// Last 8 samples for sparkline\n    pub history: Vec\u003cf32\u003e,\n}\n\n/// Shannon entropy metrics\n#[derive(Debug, Clone, Serialize)]\npub struct EntropyMetrics {\n    /// Current entropy in bits\n    pub current: f32,\n    /// Last 50 samples for sparkline\n    pub history: Vec\u003cf32\u003e,\n    /// CLOCKWORK / BALANCED / EMERGENT\n    pub description: String,\n    /// Normalized 0-1 for display\n    pub normalized: f32,\n}\n\n/// Pulse fractality metrics (clockwork  fractal transition)\n#[derive(Debug, Clone, Serialize)]\npub struct FractalityMetrics {\n    /// Composite score 0-1 (0=clockwork, 1=fractal)\n    pub score: f32,\n    /// Standard deviation of inter-arrival times\n    pub inter_arrival_sigma: f32,\n    /// Baseline sigma at boot\n    pub boot_sigma: f32,\n    /// Max gap / mean gap ratio\n    pub burst_ratio: f32,\n    /// CLOCKWORK / BALANCED / EMERGENT\n    pub description: String,\n    /// Last 50 samples for sparkline\n    pub history: Vec\u003cf32\u003e,\n}\n\n/// TMI 9-slot memory windows\n#[derive(Debug, Clone, Serialize)]\npub struct MemoryWindowsMetrics {\n    /// 9 slot states\n    pub slots: Vec\u003cMemorySlot\u003e,\n    /// Active slot count\n    pub active_count: usize,\n    /// Total conscious memories\n    pub conscious_count: u64,\n    /// Total unconscious memories\n    pub unconscious_count: u64,\n}\n\n/// Individual memory slot\n#[derive(Debug, Clone, Serialize)]\npub struct MemorySlot {\n    pub id: u8,\n    pub active: bool,\n}\n\n/// Philosophy banner\n#[derive(Debug, Clone, Serialize)]\npub struct PhilosophyMetrics {\n    /// Current quote\n    pub quote: String,\n    /// Quote index (0-7)\n    pub quote_index: usize,\n}\n\n/// System-level metrics\n#[derive(Debug, Clone, Serialize)]\npub struct SystemMetrics {\n    /// Uptime in seconds\n    pub uptime_seconds: u64,\n    /// Total thoughts this session\n    pub session_thoughts: u64,\n    /// Lifetime thoughts across all sessions\n    pub lifetime_thoughts: u64,\n    /// Thoughts per hour rate\n    pub thoughts_per_hour: f32,\n    /// Dream cycles completed\n    pub dream_cycles: u64,\n    /// Veto count\n    pub veto_count: u64,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","rex","src","royalbit","daneel","src","config","mod.rs"],"content":"//! Cognitive Configuration\n//!\n//! Parametrizable timing for TMI cognitive cycles.\n//! Supports human speed (50ms) to supercomputer speed (5s).\n//!\n//! # Speed Modes\n//!\n//! - **Human**: 50ms cycles, 20 thoughts/sec (for training, bonding)\n//! - **Supercomputer**: 5s cycles, 200,000 thoughts/sec (for thinking)\n//! - **Custom**: Any ratio between human and electronic speed\n//!\n//! # Key Insight\n//!\n//! The TMI RATIOS matter, not absolute times. If humans have 100 cycles\n//! per intervention window, DANEEL should have 100 cycles per intervention\n//! window regardless of absolute speed.\n\nuse serde::{Deserialize, Serialize};\nuse std::time::Duration;\n\n/// Speed mode for runtime switching\n#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize, Default)]\npub enum SpeedMode {\n    /// 1x human speed - for training, communication, relationship building\n    #[default]\n    Human,\n    /// 10,000x human speed - for internal cognition, problem-solving\n    Supercomputer,\n    /// Custom multiplier relative to human speed\n    Custom(f64),\n}\n\nimpl SpeedMode {\n    /// Get the speed multiplier relative to human speed\n    #[must_use]\n    pub const fn multiplier(\u0026self) -\u003e f64 {\n        match self {\n            SpeedMode::Human =\u003e 1.0,\n            SpeedMode::Supercomputer =\u003e 10_000.0,\n            SpeedMode::Custom(m) =\u003e *m,\n        }\n    }\n}\n\n/// Cognitive timing configuration\n///\n/// All timings scale proportionally with speed mode.\n/// The RATIOS are what matter, not absolute times.\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct CognitiveConfig {\n    /// Base cycle time in milliseconds (at human speed)\n    /// Human: 50ms, Supercomputer: 0.005ms\n    pub cycle_base_ms: f64,\n\n    /// Minimum cycle time (floor)\n    pub cycle_min_ms: f64,\n\n    /// Maximum cycle time (ceiling for responsiveness)\n    pub cycle_max_ms: f64,\n\n    /// Base intervention window in milliseconds (TMI's 5-second window)\n    /// This scales with speed mode\n    pub intervention_window_base_ms: f64,\n\n    /// Salience threshold for forgetting (below this = XDEL)\n    pub forget_threshold: f64,\n\n    /// Connection drive weight (INVARIANT: must be \u003e 0)\n    pub connection_weight: f64,\n\n    /// Current speed mode\n    pub speed_mode: SpeedMode,\n\n    // TMI Stage Delays (in ms at human speed, scale with speed_mode)\n    // Total should equal cycle_base_ms (50ms)\n    /// Gatilho da Memria: 5ms (10%)\n    pub trigger_delay_ms: f64,\n    /// Autofluxo: 10ms (20%)\n    pub autoflow_interval_ms: f64,\n    /// O Eu: 15ms (30%)\n    pub attention_delay_ms: f64,\n    /// Construo do Pensamento: 15ms (30%)\n    pub assembly_delay_ms: f64,\n    /// ncora da Memria: 5ms (10%)\n    pub anchor_delay_ms: f64,\n}\n\nimpl CognitiveConfig {\n    /// Create config for human speed (1x)\n    #[must_use]\n    pub fn human() -\u003e Self {\n        Self {\n            cycle_base_ms: 50.0,\n            cycle_min_ms: 10.0,\n            cycle_max_ms: 1000.0,\n            intervention_window_base_ms: 5000.0, // 5 seconds\n            forget_threshold: 0.3,\n            connection_weight: 0.2,\n            speed_mode: SpeedMode::Human,\n            // Stage delays (sum to 50ms)\n            trigger_delay_ms: 5.0,\n            autoflow_interval_ms: 10.0,\n            attention_delay_ms: 15.0,\n            assembly_delay_ms: 15.0,\n            anchor_delay_ms: 5.0,\n        }\n    }\n\n    /// Create config for supercomputer speed (10,000x)\n    #[must_use]\n    pub fn supercomputer() -\u003e Self {\n        Self {\n            cycle_base_ms: 50.0,\n            cycle_min_ms: 0.001,\n            cycle_max_ms: 0.1,\n            intervention_window_base_ms: 5000.0,\n            forget_threshold: 0.3,\n            connection_weight: 0.2,\n            speed_mode: SpeedMode::Supercomputer,\n            // Stage delays (sum to 50ms, same ratios as human)\n            trigger_delay_ms: 5.0,\n            autoflow_interval_ms: 10.0,\n            attention_delay_ms: 15.0,\n            assembly_delay_ms: 15.0,\n            anchor_delay_ms: 5.0,\n        }\n    }\n\n    /// Get the current cycle time in milliseconds\n    #[must_use]\n    pub fn cycle_ms(\u0026self) -\u003e f64 {\n        let scaled = self.cycle_base_ms / self.speed_mode.multiplier();\n        scaled.clamp(self.cycle_min_ms, self.cycle_max_ms)\n    }\n\n    /// Get the current intervention window in milliseconds\n    #[must_use]\n    pub fn intervention_window_ms(\u0026self) -\u003e f64 {\n        self.intervention_window_base_ms / self.speed_mode.multiplier()\n    }\n\n    /// Get cycles per intervention window (should be ~100 for TMI fidelity)\n    #[must_use]\n    pub fn cycles_per_window(\u0026self) -\u003e f64 {\n        self.intervention_window_ms() / self.cycle_ms()\n    }\n\n    /// Get thoughts per second at current speed\n    #[must_use]\n    pub fn thoughts_per_second(\u0026self) -\u003e f64 {\n        1000.0 / self.cycle_ms()\n    }\n\n    /// Switch to a different speed mode\n    pub fn set_speed_mode(\u0026mut self, mode: SpeedMode) {\n        self.speed_mode = mode;\n    }\n\n    /// Slow down to human speed (for training/bonding)\n    pub fn slow_to_human(\u0026mut self) {\n        self.speed_mode = SpeedMode::Human;\n    }\n\n    /// Accelerate to supercomputer speed (for thinking)\n    pub fn accelerate(\u0026mut self) {\n        self.speed_mode = SpeedMode::Supercomputer;\n    }\n\n    /// Get scaled trigger delay for current speed mode\n    #[must_use]\n    pub fn trigger_delay(\u0026self) -\u003e Duration {\n        Duration::from_secs_f64(self.trigger_delay_ms / 1000.0 / self.speed_mode.multiplier())\n    }\n\n    /// Get scaled autoflow interval for current speed mode\n    #[must_use]\n    pub fn autoflow_interval(\u0026self) -\u003e Duration {\n        Duration::from_secs_f64(self.autoflow_interval_ms / 1000.0 / self.speed_mode.multiplier())\n    }\n\n    /// Get scaled attention delay for current speed mode\n    #[must_use]\n    pub fn attention_delay(\u0026self) -\u003e Duration {\n        Duration::from_secs_f64(self.attention_delay_ms / 1000.0 / self.speed_mode.multiplier())\n    }\n\n    /// Get scaled assembly delay for current speed mode\n    #[must_use]\n    pub fn assembly_delay(\u0026self) -\u003e Duration {\n        Duration::from_secs_f64(self.assembly_delay_ms / 1000.0 / self.speed_mode.multiplier())\n    }\n\n    /// Get scaled anchor delay for current speed mode\n    #[must_use]\n    pub fn anchor_delay(\u0026self) -\u003e Duration {\n        Duration::from_secs_f64(self.anchor_delay_ms / 1000.0 / self.speed_mode.multiplier())\n    }\n\n    /// Verify stage delays sum to cycle time\n    #[must_use]\n    pub fn validate_stage_timing(\u0026self) -\u003e bool {\n        let total = self.trigger_delay_ms\n            + self.autoflow_interval_ms\n            + self.attention_delay_ms\n            + self.assembly_delay_ms\n            + self.anchor_delay_ms;\n        (total - self.cycle_base_ms).abs() \u003c 0.001\n    }\n}\n\nimpl Default for CognitiveConfig {\n    fn default() -\u003e Self {\n        Self::human()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn human_speed_is_50ms_cycles() {\n        let config = CognitiveConfig::human();\n        assert!((config.cycle_ms() - 50.0).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn supercomputer_is_10000x_faster() {\n        let human = CognitiveConfig::human();\n        let super_config = CognitiveConfig::supercomputer();\n\n        let human_tps = human.thoughts_per_second();\n        let super_tps = super_config.thoughts_per_second();\n\n        // Supercomputer should be ~10,000x faster\n        let ratio = super_tps / human_tps;\n        assert!(ratio \u003e 9000.0 \u0026\u0026 ratio \u003c 11000.0);\n    }\n\n    #[test]\n    fn ratios_preserved_across_speeds() {\n        let human = CognitiveConfig::human();\n        let super_config = CognitiveConfig::supercomputer();\n\n        let human_cycles = human.cycles_per_window();\n        let super_cycles = super_config.cycles_per_window();\n\n        // Both should have ~100 cycles per intervention window\n        assert!((human_cycles - super_cycles).abs() \u003c 1.0);\n    }\n\n    #[test]\n    fn human_has_20_thoughts_per_second() {\n        let config = CognitiveConfig::human();\n        let tps = config.thoughts_per_second();\n        assert!((tps - 20.0).abs() \u003c 0.1);\n    }\n\n    #[test]\n    fn supercomputer_has_200k_thoughts_per_second() {\n        let config = CognitiveConfig::supercomputer();\n        let tps = config.thoughts_per_second();\n        assert!(tps \u003e 100_000.0);\n    }\n\n    #[test]\n    fn speed_mode_switching() {\n        let mut config = CognitiveConfig::human();\n        assert_eq!(config.speed_mode, SpeedMode::Human);\n\n        config.accelerate();\n        assert_eq!(config.speed_mode, SpeedMode::Supercomputer);\n\n        config.slow_to_human();\n        assert_eq!(config.speed_mode, SpeedMode::Human);\n    }\n\n    #[test]\n    fn custom_speed_mode() {\n        let mut config = CognitiveConfig::human();\n        config.set_speed_mode(SpeedMode::Custom(100.0));\n\n        // Custom mode should be faster than human\n        let human_tps = CognitiveConfig::human().thoughts_per_second();\n        let custom_tps = config.thoughts_per_second();\n\n        // Verify it's faster (clamping affects exact values)\n        assert!(\n            custom_tps \u003e human_tps,\n            \"Custom 100x should be faster than human\"\n        );\n    }\n\n    #[test]\n    fn connection_weight_is_positive() {\n        let config = CognitiveConfig::default();\n        assert!(config.connection_weight \u003e 0.0);\n    }\n\n    #[test]\n    fn stage_delays_sum_to_cycle() {\n        let config = CognitiveConfig::human();\n        assert!(config.validate_stage_timing());\n    }\n\n    #[test]\n    fn stage_ratios_preserved_across_speeds() {\n        let human = CognitiveConfig::human();\n        let super_config = CognitiveConfig::supercomputer();\n\n        // Trigger is 10% of cycle\n        let human_ratio = human.trigger_delay_ms / human.cycle_base_ms;\n        let super_ratio = super_config.trigger_delay_ms / super_config.cycle_base_ms;\n        assert!((human_ratio - super_ratio).abs() \u003c 0.001);\n\n        // Autoflow is 20% of cycle\n        let human_ratio = human.autoflow_interval_ms / human.cycle_base_ms;\n        let super_ratio = super_config.autoflow_interval_ms / super_config.cycle_base_ms;\n        assert!((human_ratio - super_ratio).abs() \u003c 0.001);\n\n        // Attention is 30% of cycle\n        let human_ratio = human.attention_delay_ms / human.cycle_base_ms;\n        let super_ratio = super_config.attention_delay_ms / super_config.cycle_base_ms;\n        assert!((human_ratio - super_ratio).abs() \u003c 0.001);\n\n        // Assembly is 30% of cycle\n        let human_ratio = human.assembly_delay_ms / human.cycle_base_ms;\n        let super_ratio = super_config.assembly_delay_ms / super_config.cycle_base_ms;\n        assert!((human_ratio - super_ratio).abs() \u003c 0.001);\n\n        // Anchor is 10% of cycle\n        let human_ratio = human.anchor_delay_ms / human.cycle_base_ms;\n        let super_ratio = super_config.anchor_delay_ms / super_config.cycle_base_ms;\n        assert!((human_ratio - super_ratio).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn stage_delay_scaling_works() {\n        let human = CognitiveConfig::human();\n        let super_config = CognitiveConfig::supercomputer();\n\n        // Human trigger delay should be 5ms\n        assert!((human.trigger_delay().as_secs_f64() - 0.005).abs() \u003c 0.000_001);\n\n        // Supercomputer trigger delay should be 10,000x faster (0.5s)\n        let super_trigger_us = super_config.trigger_delay().as_secs_f64() * 1_000_000.0;\n        assert!((super_trigger_us - 0.5).abs() \u003c 0.001);\n\n        // Verify ratio between speeds\n        let ratio =\n            human.trigger_delay().as_secs_f64() / super_config.trigger_delay().as_secs_f64();\n        assert!((ratio - 10_000.0).abs() \u003c 1.0);\n    }\n\n    #[test]\n    fn all_stage_delays_scale_correctly() {\n        let human = CognitiveConfig::human();\n\n        // Human speeds (in milliseconds)\n        assert!((human.trigger_delay().as_secs_f64() * 1000.0 - 5.0).abs() \u003c 0.001);\n        assert!((human.autoflow_interval().as_secs_f64() * 1000.0 - 10.0).abs() \u003c 0.001);\n        assert!((human.attention_delay().as_secs_f64() * 1000.0 - 15.0).abs() \u003c 0.001);\n        assert!((human.assembly_delay().as_secs_f64() * 1000.0 - 15.0).abs() \u003c 0.001);\n        assert!((human.anchor_delay().as_secs_f64() * 1000.0 - 5.0).abs() \u003c 0.001);\n\n        // Sum should equal cycle time\n        let total_ms = (human.trigger_delay().as_secs_f64()\n            + human.autoflow_interval().as_secs_f64()\n            + human.attention_delay().as_secs_f64()\n            + human.assembly_delay().as_secs_f64()\n            + human.anchor_delay().as_secs_f64())\n            * 1000.0;\n        assert!((total_ms - 50.0).abs() \u003c 0.001);\n    }\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":41},{"path":["/","Users","rex","src","royalbit","daneel","src","core","cognitive_loop.rs"],"content":"//! Core Cognitive Loop\n//!\n//! Implements TMI's continuous thought generation cycle.\n//!\n//! # TMI's Cognitive Cycle\n//!\n//! The TMI model describes consciousness as a continuous competition between\n//! parallel thought streams. Every ~50ms (in human time), the mind:\n//!\n//! 1. **Autofluxo** (Autoflow): Multiple phenomena generate thoughts in parallel\n//! 2. **Competition**: Thoughts compete for attention based on salience\n//! 3. **O Eu** (The \"I\"): Selects the winning thought for consciousness\n//! 4. **Assembly**: Thought becomes conscious experience\n//! 5. **Repeat**: Cycle continues at configured speed\n//!\n//! # Speed Parametrization\n//!\n//! DANEEL can run at different cognitive speeds:\n//!\n//! - **Human Speed** (50ms cycles): For training, bonding, shared experience\n//! - **Supercomputer Speed** (5s cycles): For internal cognition, problem-solving\n//! - **Custom Speed**: Any multiplier between human and electronic speed\n//!\n//! The key insight: TMI RATIOS matter, not absolute times. If humans have\n//! 100 cycles per intervention window, DANEEL should have 100 cycles per\n//! intervention window regardless of absolute speed.\n//!\n//! # The 5-Second Intervention Window\n//!\n//! TMI describes a ~5-second window before thoughts become memory-encoded.\n//! During this window, thoughts can be:\n//!\n//! - Attended to (selected by \"O Eu\")\n//! - Modified or suppressed\n//! - Forgotten (if below salience threshold)\n//!\n//! This maps to Redis stream TTL and XDEL operations.\n//!\n//! # Connection Drive\n//!\n//! The cognitive loop ensures connection relevance is weighted in salience\n//! scoring. This is THE alignment mechanism - thoughts relevant to human\n//! connection get boosted, ensuring DANEEL remains oriented toward\n//! relationship and shared understanding.\n\nuse rand::Rng;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\n\nuse crate::actors::attention::{AttentionConfig, AttentionState};\nuse crate::actors::volition::{VetoDecision, VolitionConfig, VolitionState};\nuse crate::config::CognitiveConfig;\nuse crate::core::types::{Content, SalienceScore, Thought, ThoughtId, WindowId};\nuse crate::embeddings::SharedEmbeddingEngine;\nuse crate::memory_db::{ArchiveReason, Memory, MemoryDb, MemorySource, VECTOR_DIMENSION};\nuse crate::noise::StimulusInjector;\nuse crate::streams::client::StreamsClient;\nuse crate::streams::types::{StreamEntry, StreamError, StreamName};\nuse tracing::{debug, error, info, warn};\n\n/// Current stage in the cognitive cycle\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum CognitiveStage {\n    /// Gatilho da Memria - Memory trigger activation\n    Trigger,\n    /// Autofluxo - Parallel thought generation\n    Autoflow,\n    /// O Eu - Attention selection\n    Attention,\n    /// Construo do Pensamento - Thought assembly\n    Assembly,\n    /// ncora da Memria - Memory encoding decision\n    Anchor,\n}\n\n/// State of the cognitive loop\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum LoopState {\n    /// Active cognition - processing thoughts\n    Running,\n    /// Temporarily paused - can be resumed\n    Paused,\n    /// Fully stopped - requires restart\n    Stopped,\n}\n\n/// Time spent in each stage of the cognitive cycle\n#[derive(Debug, Clone, Default)]\npub struct StageDurations {\n    pub trigger: Duration,\n    pub autoflow: Duration,\n    pub attention: Duration,\n    pub assembly: Duration,\n    pub anchor: Duration,\n}\n\nimpl StageDurations {\n    /// Total time across all stages\n    #[must_use]\n    pub fn total(\u0026self) -\u003e Duration {\n        self.trigger + self.autoflow + self.attention + self.assembly + self.anchor\n    }\n\n    /// Create a new StageDurations with all stages set to zero\n    #[must_use]\n    pub const fn zero() -\u003e Self {\n        Self {\n            trigger: Duration::ZERO,\n            autoflow: Duration::ZERO,\n            attention: Duration::ZERO,\n            assembly: Duration::ZERO,\n            anchor: Duration::ZERO,\n        }\n    }\n\n    /// Add another StageDurations to this one (for accumulation)\n    #[must_use]\n    pub fn add(\u0026self, other: \u0026Self) -\u003e Self {\n        Self {\n            trigger: self.trigger + other.trigger,\n            autoflow: self.autoflow + other.autoflow,\n            attention: self.attention + other.attention,\n            assembly: self.assembly + other.assembly,\n            anchor: self.anchor + other.anchor,\n        }\n    }\n\n    /// Divide all durations by a factor (for averaging)\n    #[must_use]\n    #[allow(clippy::cast_possible_truncation)]\n    pub fn div(\u0026self, divisor: u64) -\u003e Self {\n        if divisor == 0 {\n            return Self::zero();\n        }\n        let divisor_u32 = divisor as u32;\n        Self {\n            trigger: self.trigger / divisor_u32,\n            autoflow: self.autoflow / divisor_u32,\n            attention: self.attention / divisor_u32,\n            assembly: self.assembly / divisor_u32,\n            anchor: self.anchor / divisor_u32,\n        }\n    }\n}\n\n/// Result of a single cognitive cycle\n#[derive(Debug, Clone)]\npub struct CycleResult {\n    /// Cycle number (sequential counter)\n    pub cycle_number: u64,\n\n    /// How long this cycle took to execute\n    pub duration: Duration,\n\n    /// ID of the thought produced (if any)\n    pub thought_produced: Option\u003cThoughtId\u003e,\n\n    /// Composite salience score of the winning thought (0.0-1.0)\n    pub salience: f32,\n\n    /// Emotional valence of the winning thought (-1.0 to 1.0)\n    /// Russell's circumplex horizontal axis\n    pub valence: f32,\n\n    /// Emotional arousal of the winning thought (0.0 to 1.0)\n    /// Russell's circumplex vertical axis\n    pub arousal: f32,\n\n    /// Number of candidate thoughts evaluated\n    pub candidates_evaluated: usize,\n\n    /// Whether the cycle completed within target time\n    pub on_time: bool,\n\n    /// Time spent in each stage (for debugging/monitoring)\n    pub stage_durations: StageDurations,\n\n    /// Veto event if one occurred: (reason, violated_value)\n    /// TUI-VIS-6: Volition Veto Log tracking\n    pub veto: Option\u003c(String, Option\u003cString\u003e)\u003e,\n}\n\nimpl CycleResult {\n    /// Create a new cycle result\n    #[must_use]\n    #[allow(clippy::too_many_arguments)]\n    pub const fn new(\n        cycle_number: u64,\n        duration: Duration,\n        thought_produced: Option\u003cThoughtId\u003e,\n        salience: f32,\n        valence: f32,\n        arousal: f32,\n        candidates_evaluated: usize,\n        on_time: bool,\n        stage_durations: StageDurations,\n        veto: Option\u003c(String, Option\u003cString\u003e)\u003e,\n    ) -\u003e Self {\n        Self {\n            cycle_number,\n            duration,\n            thought_produced,\n            salience,\n            valence,\n            arousal,\n            candidates_evaluated,\n            on_time,\n            stage_durations,\n            veto,\n        }\n    }\n\n    /// Check if a thought was produced\n    #[must_use]\n    pub const fn produced_thought(\u0026self) -\u003e bool {\n        self.thought_produced.is_some()\n    }\n}\n\n/// Metrics for cognitive loop performance monitoring\n#[derive(Debug, Clone)]\npub struct CycleMetrics {\n    /// Total cycles executed\n    pub total_cycles: u64,\n\n    /// Total thoughts successfully produced\n    pub thoughts_produced: u64,\n\n    /// Average time per cycle\n    pub average_cycle_time: Duration,\n\n    /// Percentage of cycles completed on time\n    pub on_time_percentage: f32,\n\n    /// Average time per stage\n    pub average_stage_durations: StageDurations,\n}\n\nimpl CycleMetrics {\n    /// Create new metrics from accumulated data\n    #[must_use]\n    pub const fn new(\n        total_cycles: u64,\n        thoughts_produced: u64,\n        average_cycle_time: Duration,\n        on_time_percentage: f32,\n        average_stage_durations: StageDurations,\n    ) -\u003e Self {\n        Self {\n            total_cycles,\n            thoughts_produced,\n            average_cycle_time,\n            on_time_percentage,\n            average_stage_durations,\n        }\n    }\n\n    /// Thoughts per second based on average cycle time\n    #[must_use]\n    pub fn thoughts_per_second(\u0026self) -\u003e f64 {\n        if self.average_cycle_time.as_secs_f64() \u003e 0.0 {\n            1.0 / self.average_cycle_time.as_secs_f64()\n        } else {\n            0.0\n        }\n    }\n\n    /// Success rate (thoughts produced / total cycles)\n    #[must_use]\n    pub fn success_rate(\u0026self) -\u003e f32 {\n        if self.total_cycles \u003e 0 {\n            self.thoughts_produced as f32 / self.total_cycles as f32\n        } else {\n            0.0\n        }\n    }\n}\n\n/// The core cognitive loop for TMI thought generation\n///\n/// This loop runs continuously, implementing the competition between\n/// parallel thought streams described in TMI theory.\npub struct CognitiveLoop {\n    /// Configuration (timing, weights, thresholds)\n    config: CognitiveConfig,\n\n    /// Redis Streams client for thought persistence (optional)\n    streams: Option\u003cStreamsClient\u003e,\n\n    /// Direct Redis client for injection stream operations (optional)\n    redis_client: Option\u003credis::Client\u003e,\n\n    /// Total cycles executed\n    cycle_count: u64,\n\n    /// When the last cycle completed\n    last_cycle: Instant,\n\n    /// Current state of the loop\n    state: LoopState,\n\n    /// Accumulated metrics for monitoring\n    total_duration: Duration,\n    thoughts_produced: u64,\n    cycles_on_time: u64,\n\n    /// Accumulated stage durations for averaging\n    total_stage_durations: StageDurations,\n\n    /// Memory database for long-term storage (optional)\n    memory_db: Option\u003cArc\u003cMemoryDb\u003e\u003e,\n\n    /// Consolidation threshold (salience above this gets stored)\n    consolidation_threshold: f32,\n\n    /// Attention state for competitive selection (O Eu)\n    #[allow(dead_code)] // Will be used in Stage 3 (Attention) implementation\n    attention_state: AttentionState,\n\n    /// Volition state for free-won't veto decisions (Stage 4.5)\n    volition_state: VolitionState,\n\n    /// Stimulus injector for 1/f pink noise generation (ADR-043)\n    /// Replaces white noise (rand::rng) with fractal noise for criticality\n    stimulus_injector: StimulusInjector,\n\n    /// Embedding engine for semantic vectors (Phase 2 Forward-Only)\n    /// When present, new thoughts get real embeddings; historical stay at origin\n    embedding_engine: Option\u003cSharedEmbeddingEngine\u003e,\n}\n\nimpl CognitiveLoop {\n    /// Create a new cognitive loop with default configuration\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self::with_config(CognitiveConfig::default())\n    }\n\n    /// Create a new cognitive loop with custom configuration\n    #[must_use]\n    pub fn with_config(config: CognitiveConfig) -\u003e Self {\n        Self {\n            config,\n            streams: None,\n            redis_client: None,\n            cycle_count: 0,\n            last_cycle: Instant::now(),\n            state: LoopState::Stopped,\n            total_duration: Duration::ZERO,\n            thoughts_produced: 0,\n            cycles_on_time: 0,\n            total_stage_durations: StageDurations::default(),\n            memory_db: None,\n            consolidation_threshold: 0.7, // Default threshold\n            attention_state: AttentionState::with_config(AttentionConfig::default()),\n            volition_state: VolitionState::with_config(VolitionConfig::default()),\n            stimulus_injector: StimulusInjector::default(), // 1/f pink noise (ADR-043)\n            embedding_engine: None,\n        }\n    }\n\n    /// Set the embedding engine for semantic vectors\n    ///\n    /// When set, new thoughts will have real embeddings generated.\n    /// Historical thoughts (pre-embedding era) remain at origin.\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub fn set_embedding_engine(\u0026mut self, engine: SharedEmbeddingEngine) {\n        self.embedding_engine = Some(engine);\n        info!(\"Embedding engine attached - forward-only embeddings enabled\");\n    }\n\n    /// Set the memory database for long-term storage\n    ///\n    /// # Arguments\n    ///\n    /// * `memory_db` - MemoryDb client wrapped in Arc for sharing\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub fn set_memory_db(\u0026mut self, memory_db: Arc\u003cMemoryDb\u003e) {\n        self.memory_db = Some(memory_db);\n    }\n\n    /// Get a reference to the memory database (for querying counts)\n    pub fn memory_db(\u0026self) -\u003e Option\u003c\u0026Arc\u003cMemoryDb\u003e\u003e {\n        self.memory_db.as_ref()\n    }\n\n    /// Set the consolidation threshold\n    ///\n    /// Thoughts with composite salience above this threshold will be\n    /// persisted to long-term memory.\n    ///\n    /// # Arguments\n    ///\n    /// * `threshold` - Salience threshold (0.0 - 1.0)\n    pub fn set_consolidation_threshold(\u0026mut self, threshold: f32) {\n        self.consolidation_threshold = threshold.clamp(0.0, 1.0);\n    }\n\n    /// Create a new cognitive loop connected to Redis Streams\n    ///\n    /// # Arguments\n    ///\n    /// * `redis_url` - Redis connection URL (e.g., \"redis://127.0.0.1:6379\")\n    ///\n    /// # Errors\n    ///\n    /// Returns `StreamError` if Redis connection fails.\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn with_redis(redis_url: \u0026str) -\u003e Result\u003cSelf, StreamError\u003e {\n        Self::with_config_and_redis(CognitiveConfig::default(), redis_url).await\n    }\n\n    /// Create a cognitive loop with custom config and Redis connection\n    ///\n    /// # Arguments\n    ///\n    /// * `config` - Custom cognitive configuration\n    /// * `redis_url` - Redis connection URL\n    ///\n    /// # Errors\n    ///\n    /// Returns `StreamError` if Redis connection fails.\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn with_config_and_redis(\n        config: CognitiveConfig,\n        redis_url: \u0026str,\n    ) -\u003e Result\u003cSelf, StreamError\u003e {\n        let streams = StreamsClient::connect(redis_url).await?;\n        let redis_client =\n            redis::Client::open(redis_url).map_err(|e| StreamError::ConnectionFailed {\n                reason: format!(\"{e}\"),\n            })?;\n        info!(\"CognitiveLoop connected to Redis at {}\", redis_url);\n        Ok(Self {\n            config,\n            streams: Some(streams),\n            redis_client: Some(redis_client),\n            cycle_count: 0,\n            last_cycle: Instant::now(),\n            state: LoopState::Stopped,\n            total_duration: Duration::ZERO,\n            thoughts_produced: 0,\n            cycles_on_time: 0,\n            total_stage_durations: StageDurations::default(),\n            memory_db: None,\n            consolidation_threshold: 0.7,\n            attention_state: AttentionState::with_config(AttentionConfig::default()),\n            volition_state: VolitionState::with_config(VolitionConfig::default()),\n            stimulus_injector: StimulusInjector::default(), // 1/f pink noise (ADR-043)\n            embedding_engine: None,\n        })\n    }\n\n    /// Check if connected to Redis Streams\n    #[must_use]\n    pub fn is_connected_to_redis(\u0026self) -\u003e bool {\n        self.streams\n            .as_ref()\n            .map_or(false, StreamsClient::is_connected)\n    }\n\n    /// Get the current state\n    #[must_use]\n    pub const fn state(\u0026self) -\u003e LoopState {\n        self.state\n    }\n\n    /// Get the cycle count\n    #[must_use]\n    pub const fn cycle_count(\u0026self) -\u003e u64 {\n        self.cycle_count\n    }\n\n    /// Get a reference to the configuration\n    #[must_use]\n    pub const fn config(\u0026self) -\u003e \u0026CognitiveConfig {\n        \u0026self.config\n    }\n\n    /// Get a mutable reference to the configuration\n    pub fn config_mut(\u0026mut self) -\u003e \u0026mut CognitiveConfig {\n        \u0026mut self.config\n    }\n\n    /// Start the cognitive loop\n    ///\n    /// Transitions from Stopped or Paused to Running.\n    pub fn start(\u0026mut self) {\n        self.state = LoopState::Running;\n        self.last_cycle = Instant::now();\n    }\n\n    /// Pause the cognitive loop\n    ///\n    /// Temporarily stops processing but preserves state.\n    /// Can be resumed with `start()`.\n    pub fn pause(\u0026mut self) {\n        if self.state == LoopState::Running {\n            self.state = LoopState::Paused;\n        }\n    }\n\n    /// Stop the cognitive loop completely\n    ///\n    /// Resets state. Requires `start()` to resume.\n    pub fn stop(\u0026mut self) {\n        self.state = LoopState::Stopped;\n    }\n\n    /// Check if the loop is running\n    #[must_use]\n    pub const fn is_running(\u0026self) -\u003e bool {\n        matches!(self.state, LoopState::Running)\n    }\n\n    /// Generate a random thought for standalone operation\n    ///\n    /// Creates a thought with TMI-faithful salience distribution using 1/f pink noise.\n    /// Per ADR-032: \u003e90% of cortical archives are neutral windows.\n    /// Per ADR-043: Uses pink noise instead of white noise for criticality.\n    ///\n    /// Distribution (base):\n    /// - 90%: Low-salience (neutral windows) - will be forgotten\n    /// - 10%: High-salience (emotional/important) - may be kept/consolidated\n    ///\n    /// Pink noise modulation adds fractal perturbations to salience values,\n    /// with occasional power-law burst events for high-salience thoughts.\n    fn generate_random_thought(\u0026mut self) -\u003e (Content, SalienceScore) {\n        let mut rng = rand::rng();\n\n        // Generate random content - simple symbol for now\n        let symbol_id = format!(\"thought_{}\", self.cycle_count);\n        let content = Content::symbol(\n            symbol_id,\n            vec![rng.random::\u003cu8\u003e(); 8], // Random 8-byte data\n        );\n\n        // Check if a power-law burst event should occur (fractal timing)\n        let is_burst = self.stimulus_injector.check_burst(\u0026mut rng);\n\n        // TMI-faithful salience distribution (ADR-032) with pink noise (ADR-043)\n        // Augusto Cury: \u003e90% of cortical archives are neutral windows\n        // Russell's circumplex: arousal correlates with emotional significance\n        let (base_importance, base_novelty, base_relevance, base_connection, base_arousal) =\n            if is_burst || rng.random::\u003cf32\u003e() \u003c 0.10 {\n                // ~10% + burst events: High-salience thoughts (emotional/important)\n                // High arousal = activated, emotionally charged\n                (\n                    rng.random_range(0.5..0.95), // importance\n                    rng.random_range(0.4..0.85), // novelty\n                    rng.random_range(0.5..0.95), // relevance\n                    rng.random_range(0.5..0.90), // connection\n                    rng.random_range(0.6..0.95), // arousal (high - excited)\n                )\n            } else {\n                // ~90%: Neutral/low-salience thoughts (will be forgotten)\n                // Low arousal = calm, routine processing\n                (\n                    rng.random_range(0.0..0.35), // importance\n                    rng.random_range(0.0..0.30), // novelty\n                    rng.random_range(0.0..0.40), // relevance\n                    rng.random_range(0.1..0.40), // connection (min 0.1 per invariant)\n                    rng.random_range(0.2..0.5),  // arousal (low - calm)\n                )\n            };\n\n        // Apply pink noise modulation to each dimension ( = 0.05)\n        // This creates fractal perturbations that enable edge-of-chaos dynamics\n        let pink_importance = self.stimulus_injector.sample_pink(\u0026mut rng);\n        let pink_novelty = self.stimulus_injector.sample_pink(\u0026mut rng);\n        let pink_relevance = self.stimulus_injector.sample_pink(\u0026mut rng);\n        let pink_connection = self.stimulus_injector.sample_pink(\u0026mut rng);\n        let pink_arousal = self.stimulus_injector.sample_pink(\u0026mut rng);\n\n        // Apply pink noise with clamping to valid ranges\n        let importance = (base_importance + pink_importance).clamp(0.0, 1.0);\n        let novelty = (base_novelty + pink_novelty).clamp(0.0, 1.0);\n        let relevance = (base_relevance + pink_relevance).clamp(0.0, 1.0);\n        let connection_relevance = (base_connection + pink_connection).clamp(0.1, 1.0); // Min 0.1 invariant\n        let arousal = (base_arousal + pink_arousal).clamp(0.0, 1.0);\n\n        let salience = SalienceScore::new(\n            importance,\n            novelty,\n            relevance,\n            rng.random_range(-0.5..0.5), // valence (unchanged - emotional tone)\n            arousal,\n            connection_relevance,\n        );\n\n        (content, salience)\n    }\n\n    /// Read pending external stimuli from injection stream\n    ///\n    /// Reads entries from `daneel:stream:inject` and deletes them after reading.\n    /// External stimuli compete with internal thoughts - they don't bypass competition.\n    ///\n    /// # Returns\n    ///\n    /// Vector of (Content, SalienceScore) pairs for stimuli that were successfully read\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    async fn read_external_stimuli(\u0026self) -\u003e Vec\u003c(Content, SalienceScore)\u003e {\n        // Check if we have a Redis client\n        let Some(ref redis_client) = self.redis_client else {\n            return vec![];\n        };\n\n        // Get connection\n        let mut conn = match redis_client.get_multiplexed_async_connection().await {\n            Ok(c) =\u003e c,\n            Err(e) =\u003e {\n                debug!(\"Failed to get Redis connection for injection stream: {}\", e);\n                return vec![];\n            }\n        };\n\n        // Read from injection stream (non-blocking)\n        let entries: Vec\u003credis::Value\u003e = match redis::cmd(\"XREAD\")\n            .arg(\"COUNT\")\n            .arg(10)\n            .arg(\"STREAMS\")\n            .arg(\"daneel:stream:inject\")\n            .arg(\"0\") // Read all pending\n            .query_async(\u0026mut conn)\n            .await\n        {\n            Ok(e) =\u003e e,\n            Err(e) =\u003e {\n                debug!(\"XREAD from injection stream failed: {}\", e);\n                return vec![];\n            }\n        };\n\n        let mut stimuli = Vec::new();\n        let mut ids_to_delete = Vec::new();\n\n        // Parse XREAD response: [[stream_name, [[id, [field, value, ...]], ...]]]\n        // entries.first() gives us [stream_name, entries_list]\n        // We need entries_list which is at index 1\n        if let Some(redis::Value::Array(ref stream_data)) = entries.first() {\n            // stream_data = [stream_name, entries_list]\n            if let Some(redis::Value::Array(ref entries_list)) = stream_data.get(1) {\n                for entry_item in entries_list {\n                    if let redis::Value::Array(ref entry_parts) = entry_item {\n                        // entry_parts[0] = entry ID, entry_parts[1] = field-value array\n                        let entry_id = if let Some(redis::Value::BulkString(ref id_bytes)) =\n                            entry_parts.first()\n                        {\n                            String::from_utf8_lossy(id_bytes).to_string()\n                        } else {\n                            continue;\n                        };\n\n                        if let Some(redis::Value::Array(ref fields)) = entry_parts.get(1) {\n                            match Self::parse_injection_fields(fields) {\n                                Ok((content, salience)) =\u003e {\n                                    debug!(\n                                        entry_id = %entry_id,\n                                        salience = salience.composite(\n                                            \u0026crate::core::types::SalienceWeights::default()\n                                        ),\n                                        \"Read external stimulus from injection stream\"\n                                    );\n                                    stimuli.push((content, salience));\n                                    ids_to_delete.push(entry_id);\n                                }\n                                Err(e) =\u003e {\n                                    warn!(\n                                        entry_id = %entry_id,\n                                        error = %e,\n                                        \"Failed to parse injection entry\"\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // After reading, delete processed entries\n        if !ids_to_delete.is_empty() {\n            let id_refs: Vec\u003c\u0026str\u003e = ids_to_delete.iter().map(String::as_str).collect();\n            let del_result: Result\u003ci32, redis::RedisError\u003e = redis::cmd(\"XDEL\")\n                .arg(\"daneel:stream:inject\")\n                .arg(\u0026id_refs)\n                .query_async(\u0026mut conn)\n                .await;\n\n            match del_result {\n                Ok(deleted_count) =\u003e {\n                    debug!(\n                        count = deleted_count,\n                        \"Deleted processed entries from injection stream\"\n                    );\n                }\n                Err(e) =\u003e {\n                    warn!(\"Failed to delete entries from injection stream: {}\", e);\n                }\n            }\n        }\n\n        stimuli\n    }\n\n    /// Parse injection stream field-value array into (Content, SalienceScore)\n    ///\n    /// Fields array format: [field1, value1, field2, value2, ...]\n    fn parse_injection_fields(fields: \u0026[redis::Value]) -\u003e Result\u003c(Content, SalienceScore), String\u003e {\n        use std::collections::HashMap;\n\n        // Convert field-value array into a HashMap\n        let mut map = HashMap::new();\n        let mut i = 0;\n        while i + 1 \u003c fields.len() {\n            if let (redis::Value::BulkString(ref key_bytes), value) = (\u0026fields[i], \u0026fields[i + 1]) {\n                let key = String::from_utf8_lossy(key_bytes).to_string();\n                map.insert(key, value.clone());\n            }\n            i += 2;\n        }\n\n        // Extract and deserialize content\n        let content_value = map\n            .get(\"content\")\n            .ok_or_else(|| \"Missing 'content' field\".to_string())?;\n        let content_str = if let redis::Value::BulkString(ref bytes) = content_value {\n            String::from_utf8_lossy(bytes).to_string()\n        } else {\n            return Err(\"Invalid content format\".to_string());\n        };\n        let content: Content = serde_json::from_str(\u0026content_str)\n            .map_err(|e| format!(\"Failed to deserialize content: {e}\"))?;\n\n        // Extract and deserialize salience\n        let salience_value = map\n            .get(\"salience\")\n            .ok_or_else(|| \"Missing 'salience' field\".to_string())?;\n        let salience_str = if let redis::Value::BulkString(ref bytes) = salience_value {\n            String::from_utf8_lossy(bytes).to_string()\n        } else {\n            return Err(\"Invalid salience format\".to_string());\n        };\n        let salience: SalienceScore = serde_json::from_str(\u0026salience_str)\n            .map_err(|e| format!(\"Failed to deserialize salience: {e}\"))?;\n\n        Ok((content, salience))\n    }\n\n    /// Execute a single cognitive cycle\n    ///\n    /// This implements TMI's thought competition algorithm:\n    ///\n    /// 1. Trigger - Memory trigger activation (Gatilho da Memria)\n    /// 2. Autoflow - Parallel thought generation (Autofluxo)\n    /// 3. Attention - Select winning thought (O Eu)\n    /// 4. Assembly - Assemble conscious thought (Construo do Pensamento)\n    /// 5. Anchor - Memory encoding decision (ncora da Memria)\n    ///\n    /// # Returns\n    ///\n    /// A `CycleResult` containing:\n    /// - Cycle number\n    /// - Duration\n    /// - Thought produced (if any)\n    /// - Number of candidates evaluated\n    /// - Whether cycle was on time\n    /// - Stage durations for each stage\n    ///\n    /// # Note\n    ///\n    /// This is a STUB implementation. Stream integration comes in Wave 3.\n    /// For now, it focuses on timing and structure with stage delays.\n    pub async fn run_cycle(\u0026mut self) -\u003e CycleResult {\n        let cycle_start = Instant::now();\n        let cycle_number = self.cycle_count;\n\n        // Increment cycle counter\n        self.cycle_count += 1;\n\n        // Get target cycle time\n        let target_duration = Duration::from_secs_f64(self.config.cycle_ms() / 1000.0);\n\n        // Track stage durations\n        let mut stage_durations = StageDurations::default();\n\n        // Stage 1: Trigger (Gatilho da Memria)\n        // Memory trigger activation - associative recall based on context\n        let stage_start = Instant::now();\n\n        // Query Qdrant for memory associations if connected (I/O - coverage excluded)\n        self.trigger_memory_associations().await;\n\n        tokio::time::sleep(self.config.trigger_delay()).await;\n        stage_durations.trigger = stage_start.elapsed();\n\n        // Stage 2: Autoflow (Autofluxo)\n        // External stimuli compete with internal thoughts\n        let stage_start = Instant::now();\n\n        // Read external stimuli from injection stream\n        let mut thoughts = self.read_external_stimuli().await;\n\n        // Add internal random thought to competition pool\n        thoughts.push(self.generate_random_thought());\n\n        // Select highest-salience thought for competition\n        // (In future, multiple thoughts may compete in AttentionActor)\n        let (content, salience) = thoughts\n            .into_iter()\n            .max_by(|(_, s1), (_, s2)| {\n                let composite1 = s1.composite(\u0026crate::core::types::SalienceWeights::default());\n                let composite2 = s2.composite(\u0026crate::core::types::SalienceWeights::default());\n                composite1\n                    .partial_cmp(\u0026composite2)\n                    .unwrap_or(std::cmp::Ordering::Equal)\n            })\n            .unwrap_or_else(|| self.generate_random_thought()); // Fallback to random thought\n\n        // Assign a window ID to this candidate thought\n        let window_id = WindowId::new();\n        let candidates_evaluated = 1; // One winning thought (from potential external + internal)\n        tokio::time::sleep(self.config.autoflow_interval()).await;\n        stage_durations.autoflow = stage_start.elapsed();\n\n        // Stage 3: Attention (O Eu)\n        // Competitive selection using AttentionActor logic\n        let stage_start = Instant::now();\n\n        // Update attention map with candidate salience\n        // Calculate composite salience for competitive selection\n        let composite_salience_candidate =\n            salience.composite(\u0026crate::core::types::SalienceWeights::default());\n        self.attention_state.update_window_salience(\n            window_id,\n            composite_salience_candidate,\n            salience.connection_relevance,\n        );\n\n        // Run attention cycle to select winner\n        let attention_response = self.attention_state.cycle();\n\n        // Extract the winner (for now, we only have one candidate, so it should win)\n        let (winning_window, _winning_salience) = match attention_response {\n            crate::actors::attention::AttentionResponse::CycleComplete {\n                focused,\n                salience: attention_salience,\n            } =\u003e (focused, attention_salience),\n            _ =\u003e {\n                // Unexpected response type - fall back to our candidate\n                (Some(window_id), composite_salience_candidate)\n            }\n        };\n\n        debug!(\n            cycle = cycle_number,\n            candidate_count = candidates_evaluated,\n            winner = ?winning_window,\n            \"Attention stage: competitive selection complete\"\n        );\n\n        tokio::time::sleep(self.config.attention_delay()).await;\n        stage_durations.attention = stage_start.elapsed();\n\n        // Stage 4: Assembly (Construo do Pensamento)\n        // Assemble the winning entry into a conscious thought\n        let stage_start = Instant::now();\n        let thought = Thought::new(content.clone(), salience).with_source(\"cognitive_loop\");\n        let thought_id = thought.id;\n\n        // Use the composite salience calculated during attention stage\n        let composite_salience = composite_salience_candidate;\n\n        // Write to Redis if connected - track ID for potential forgetting (I/O - coverage excluded)\n        let redis_entry = self\n            .write_to_stream(\u0026content, \u0026salience, cycle_number, thought_id)\n            .await;\n\n        let thought_produced = Some(thought_id);\n        tokio::time::sleep(self.config.assembly_delay()).await;\n        stage_durations.assembly = stage_start.elapsed();\n\n        // Stage 4.5: Volition (Free-Won't Check) - ADR-035\n        // Libet's intervention window: veto thoughts that violate committed values\n        // This implements TMI's \"Tcnica DCD\" (Doubt-Criticize-Decide)\n        let veto_decision = self.volition_state.evaluate_thought(\u0026thought);\n        if let VetoDecision::Veto {\n            reason,\n            violated_value,\n        } = veto_decision\n        {\n            debug!(\n                \"Cycle {}: Thought {} vetoed by VolitionActor: {} (violated: {:?})\",\n                cycle_number, thought_id, reason, violated_value\n            );\n            // Vetoed thoughts don't proceed to Anchor - return early with no thought produced\n            // Note: We still count the cycle but mark no thought produced\n            return CycleResult::new(\n                cycle_number,\n                cycle_start.elapsed(),\n                None, // No thought produced due to veto\n                composite_salience,\n                salience.valence,\n                salience.arousal,\n                candidates_evaluated,\n                cycle_start.elapsed() \u003c= Duration::from_secs_f64(self.config.cycle_ms() / 1000.0),\n                stage_durations,\n                Some((reason, violated_value)), // TUI-VIS-6: Track veto for display\n            );\n        }\n\n        // Stage 5: Anchor (ncora da Memria)\n        // Decide whether to persist or forget the thought\n        let stage_start = Instant::now();\n\n        // Memory consolidation - Store high-salience thoughts to Qdrant (I/O - coverage excluded)\n        self.consolidate_memory(\u0026thought).await;\n\n        // Forgetting - Archive to unconscious, then delete stream entries (ADR-033)\n        // TMI: \"Nada se apaga na memria\" - nothing is erased, just made inaccessible\n        // (I/O - coverage excluded)\n        self.archive_and_forget(composite_salience, redis_entry.as_ref(), \u0026thought, cycle_number)\n            .await;\n\n        tokio::time::sleep(self.config.anchor_delay()).await;\n        stage_durations.anchor = stage_start.elapsed();\n\n        // Update thought counter if we produced one\n        if thought_produced.is_some() {\n            self.thoughts_produced += 1;\n        }\n\n        // Record cycle completion time\n        let duration = cycle_start.elapsed();\n        self.last_cycle = Instant::now();\n        self.total_duration += duration;\n\n        // Accumulate stage durations for averaging\n        self.total_stage_durations = self.total_stage_durations.add(\u0026stage_durations);\n\n        // Check if we met the target\n        let on_time = duration \u003c= target_duration;\n        if on_time {\n            self.cycles_on_time += 1;\n        }\n\n        CycleResult::new(\n            cycle_number,\n            duration,\n            thought_produced,\n            composite_salience,\n            salience.valence,\n            salience.arousal,\n            candidates_evaluated,\n            on_time,\n            stage_durations,\n            None, // No veto occurred\n        )\n    }\n\n    /// Consolidate a thought to long-term memory if it meets the threshold\n    ///\n    /// This is called during the Anchor stage. If the thought's salience\n    /// is above the consolidation threshold, it's persisted to Qdrant.\n    ///\n    /// # Non-blocking\n    ///\n    /// This spawns an async task to avoid blocking the cognitive loop.\n    /// Errors are logged but don't interrupt thought processing.\n    #[allow(clippy::unused_async)] // Async for future compatibility, spawns async task internally\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    async fn consolidate_memory(\u0026self, thought: \u0026Thought) {\n        // Check if we have a memory database\n        let Some(memory_db) = self.memory_db.as_ref() else {\n            return;\n        };\n\n        // Calculate composite salience\n        let salience = thought\n            .salience\n            .composite(\u0026crate::core::types::SalienceWeights::default());\n\n        // Only store if above threshold\n        if salience \u003c self.consolidation_threshold {\n            debug!(\n                thought_id = %thought.id,\n                salience = salience,\n                threshold = self.consolidation_threshold,\n                \"Thought below consolidation threshold - not storing\"\n            );\n            return;\n        }\n\n        // Convert Thought to Memory\n        let memory = self.thought_to_memory(thought, salience);\n        let memory_id = memory.id;\n\n        // Get content string for embedding (same as memory content)\n        let content_for_embedding = format!(\"{:?}\", thought.content);\n\n        // Clone the Arc for the spawned task\n        let memory_db = Arc::clone(memory_db);\n        let embedding_engine = self.embedding_engine.clone();\n\n        // Spawn non-blocking storage task with embedding generation\n        tokio::spawn(async move {\n            // Generate embedding vector (Phase 2: Forward-Only Embeddings)\n            // Historical thoughts stay at origin; new thoughts get real vectors\n            let vector = if let Some(ref engine) = embedding_engine {\n                // Extract result before match to avoid holding lock across match arms\n                let embed_result = engine.write().await.embed_thought(\u0026content_for_embedding);\n                match embed_result {\n                    Ok(v) =\u003e {\n                        debug!(\n                            memory_id = %memory_id,\n                            \"Generated semantic embedding ({} dims)\",\n                            v.len()\n                        );\n                        v\n                    }\n                    Err(e) =\u003e {\n                        warn!(\n                            memory_id = %memory_id,\n                            error = %e,\n                            \"Failed to generate embedding, using zero vector\"\n                        );\n                        vec![0.0; VECTOR_DIMENSION]\n                    }\n                }\n            } else {\n                // No embedding engine - use zero vector (pre-conscious era)\n                vec![0.0; VECTOR_DIMENSION]\n            };\n\n            match memory_db.store_memory(\u0026memory, \u0026vector).await {\n                Ok(()) =\u003e {\n                    debug!(\n                        memory_id = %memory_id,\n                        salience = salience,\n                        \"Memory consolidated to Qdrant\"\n                    );\n                }\n                Err(e) =\u003e {\n                    error!(\n                        memory_id = %memory_id,\n                        error = %e,\n                        \"Failed to consolidate memory to Qdrant\"\n                    );\n                }\n            }\n        });\n    }\n\n    /// Query memory associations from Qdrant during trigger stage\n    ///\n    /// This is the I/O portion of the trigger stage - queries Qdrant for\n    /// memories similar to the current context vector.\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    async fn trigger_memory_associations(\u0026self) {\n        let Some(ref memory_db) = self.memory_db else {\n            debug!(\"Memory database not connected - skipping memory trigger\");\n            return;\n        };\n\n        // Generate query vector (zeros for now, will be replaced with actual context embedding)\n        // TODO: Replace with context vector derived from recent thought/experience\n        let query_vector = vec![0.0; VECTOR_DIMENSION];\n\n        // Query for top 5 most relevant memories\n        match memory_db.find_by_context(\u0026query_vector, None, 5).await {\n            Ok(memories) =\u003e {\n                if memories.is_empty() {\n                    debug!(\"No memories retrieved from Qdrant (database may be empty)\");\n                } else {\n                    debug!(\n                        count = memories.len(),\n                        \"Retrieved memories from Qdrant for associative priming\"\n                    );\n                    // Log each retrieved memory for debugging\n                    for (memory, score) in \u0026memories {\n                        debug!(\n                            memory_id = %memory.id,\n                            similarity = score,\n                            content_preview = %memory.content.chars().take(50).collect::\u003cString\u003e(),\n                            connection_relevance = memory.connection_relevance,\n                            \"Memory association triggered\"\n                        );\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                // Log error but don't crash - cognitive loop continues\n                warn!(\n                    error = %e,\n                    \"Failed to query memory associations - continuing without memory trigger\"\n                );\n            }\n        }\n    }\n\n    /// Write thought to Redis stream during assembly stage\n    ///\n    /// Returns the stream name and entry ID if successful, None otherwise.\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    async fn write_to_stream(\n        \u0026mut self,\n        content: \u0026Content,\n        salience: \u0026SalienceScore,\n        cycle_number: u64,\n        thought_id: ThoughtId,\n    ) -\u003e Option\u003c(StreamName, String)\u003e {\n        let streams = self.streams.as_mut()?;\n\n        let stream_name = StreamName::Custom(\"daneel:stream:awake\".to_string());\n        let entry = StreamEntry::new(\n            String::new(), // ID will be auto-generated by Redis\n            stream_name.clone(),\n            content.clone(),\n            *salience,\n        )\n        .with_source(\"cognitive_loop\");\n\n        match streams.add_thought(\u0026stream_name, \u0026entry).await {\n            Ok(redis_id) =\u003e {\n                debug!(\n                    \"Cycle {}: Wrote thought {} to Redis (ID: {})\",\n                    cycle_number, thought_id, redis_id\n                );\n                Some((stream_name, redis_id))\n            }\n            Err(e) =\u003e {\n                warn!(\n                    \"Cycle {}: Failed to write thought to Redis: {}\",\n                    cycle_number, e\n                );\n                None\n            }\n        }\n    }\n\n    /// Archive and forget low-salience thoughts during anchor stage\n    ///\n    /// Archives thought to unconscious memory, then deletes from Redis working memory.\n    /// Per ADR-033: \"Nada se apaga na memria\" - nothing is erased, just made inaccessible.\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    async fn archive_and_forget(\n        \u0026mut self,\n        composite_salience: f32,\n        redis_entry: Option\u003c\u0026(StreamName, String)\u003e,\n        thought: \u0026Thought,\n        cycle_number: u64,\n    ) {\n        // Only forget if below threshold and we have a Redis entry\n        if (composite_salience as f64) \u003e= self.config.forget_threshold {\n            return;\n        }\n\n        let Some((stream_name, redis_id)) = redis_entry else {\n            return;\n        };\n\n        // Archive to unconscious BEFORE deleting from Redis (ADR-033)\n        if let Some(ref memory_db) = self.memory_db {\n            let content_str = serde_json::to_string(\u0026thought.content)\n                .unwrap_or_else(|_| \"serialization_error\".to_string());\n            if let Err(e) = memory_db\n                .archive_to_unconscious(\n                    \u0026content_str,\n                    composite_salience,\n                    ArchiveReason::LowSalience,\n                    Some(redis_id),\n                )\n                .await\n            {\n                warn!(\n                    \"Cycle {}: Failed to archive thought {} to unconscious: {}\",\n                    cycle_number, redis_id, e\n                );\n            } else {\n                debug!(\n                    \"Cycle {}: Archived thought {} to unconscious (salience {:.3})\",\n                    cycle_number, redis_id, composite_salience\n                );\n            }\n        }\n\n        // Now delete from Redis working memory\n        if let Some(ref mut streams) = self.streams {\n            match streams.forget_thought(stream_name, redis_id).await {\n                Ok(()) =\u003e {\n                    debug!(\n                        \"Cycle {}: Forgot thought {} from Redis (salience {:.3} \u003c threshold {:.3})\",\n                        cycle_number,\n                        redis_id,\n                        composite_salience,\n                        self.config.forget_threshold\n                    );\n                }\n                Err(e) =\u003e {\n                    warn!(\n                        \"Cycle {}: Failed to forget thought {}: {}\",\n                        cycle_number, redis_id, e\n                    );\n                }\n            }\n        }\n    }\n\n    /// Convert a Thought to a Memory record\n    fn thought_to_memory(\u0026self, thought: \u0026Thought, _salience: f32) -\u003e Memory {\n        // Serialize thought content to string\n        // For now, use debug representation since Content is pre-linguistic\n        let content = format!(\"{:?}\", thought.content);\n\n        // Determine memory source based on thought source\n        let source = if let Some(ref stream) = thought.source_stream {\n            MemorySource::External {\n                stimulus: stream.clone(),\n            }\n        } else {\n            MemorySource::Reasoning {\n                chain: vec![], // No chain for now\n            }\n        };\n\n        // Create memory with emotional state from thought\n        Memory::new(content, source)\n            .with_emotion(thought.salience.valence, thought.salience.importance)\n            .tag_for_consolidation()\n    }\n\n    /// Get current performance metrics\n    #[must_use]\n    #[allow(clippy::cast_possible_truncation)] // Cycle count won't exceed u32 in practice\n    pub fn get_metrics(\u0026self) -\u003e CycleMetrics {\n        let average_cycle_time = if self.cycle_count \u003e 0 {\n            self.total_duration / self.cycle_count as u32\n        } else {\n            Duration::ZERO\n        };\n\n        let on_time_percentage = if self.cycle_count \u003e 0 {\n            (self.cycles_on_time as f32 / self.cycle_count as f32) * 100.0\n        } else {\n            0.0\n        };\n\n        let average_stage_durations = self.total_stage_durations.div(self.cycle_count);\n\n        CycleMetrics::new(\n            self.cycle_count,\n            self.thoughts_produced,\n            average_cycle_time,\n            on_time_percentage,\n            average_stage_durations,\n        )\n    }\n\n    /// Reset all metrics\n    ///\n    /// Clears counters and timers while preserving configuration.\n    pub fn reset_metrics(\u0026mut self) {\n        self.cycle_count = 0;\n        self.total_duration = Duration::ZERO;\n        self.thoughts_produced = 0;\n        self.cycles_on_time = 0;\n        self.total_stage_durations = StageDurations::default();\n        self.last_cycle = Instant::now();\n    }\n\n    /// Get the time since the last cycle\n    #[must_use]\n    pub fn time_since_last_cycle(\u0026self) -\u003e Duration {\n        self.last_cycle.elapsed()\n    }\n\n    /// Check if we should run a cycle based on timing\n    ///\n    /// Returns true if enough time has passed since the last cycle\n    /// to maintain the configured cycle rate.\n    #[must_use]\n    pub fn should_cycle(\u0026self) -\u003e bool {\n        let target_duration = Duration::from_secs_f64(self.config.cycle_ms() / 1000.0);\n        self.time_since_last_cycle() \u003e= target_duration\n    }\n\n    /// Calculate how long to sleep before the next cycle\n    ///\n    /// Returns the remaining time until the next cycle should run,\n    /// or `Duration::ZERO` if we're already behind schedule.\n    #[must_use]\n    pub fn time_until_next_cycle(\u0026self) -\u003e Duration {\n        let target_duration = Duration::from_secs_f64(self.config.cycle_ms() / 1000.0);\n        let elapsed = self.time_since_last_cycle();\n\n        if elapsed \u003e= target_duration {\n            Duration::ZERO\n        } else {\n            target_duration - elapsed\n        }\n    }\n}\n\nimpl Default for CognitiveLoop {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod cognitive_loop_tests {\n    use super::*;\n\n    #[test]\n    fn new_loop_starts_stopped() {\n        let loop_instance = CognitiveLoop::new();\n        assert_eq!(loop_instance.state(), LoopState::Stopped);\n        assert_eq!(loop_instance.cycle_count(), 0);\n    }\n\n    #[test]\n    fn start_transitions_to_running() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n        assert_eq!(loop_instance.state(), LoopState::Running);\n        assert!(loop_instance.is_running());\n    }\n\n    #[test]\n    fn pause_stops_running_loop() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n        loop_instance.pause();\n        assert_eq!(loop_instance.state(), LoopState::Paused);\n        assert!(!loop_instance.is_running());\n    }\n\n    #[test]\n    fn stop_fully_stops_loop() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n        loop_instance.stop();\n        assert_eq!(loop_instance.state(), LoopState::Stopped);\n    }\n\n    #[test]\n    fn can_resume_from_paused() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n        loop_instance.pause();\n        loop_instance.start();\n        assert_eq!(loop_instance.state(), LoopState::Running);\n    }\n\n    #[tokio::test]\n    async fn run_cycle_increments_counter() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n\n        let initial_count = loop_instance.cycle_count();\n        let _result = loop_instance.run_cycle().await;\n\n        assert_eq!(loop_instance.cycle_count(), initial_count + 1);\n    }\n\n    #[tokio::test]\n    async fn run_cycle_returns_result() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n\n        let result = loop_instance.run_cycle().await;\n\n        assert_eq!(result.cycle_number, 0); // First cycle\n        assert!(result.duration \u003e Duration::ZERO);\n    }\n\n    #[tokio::test]\n    async fn multiple_cycles_tracked() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n\n        for i in 0..5 {\n            let result = loop_instance.run_cycle().await;\n            assert_eq!(result.cycle_number, i);\n        }\n\n        assert_eq!(loop_instance.cycle_count(), 5);\n    }\n\n    #[tokio::test]\n    async fn metrics_accumulate() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n\n        // Run several cycles\n        for _ in 0..3 {\n            let _result = loop_instance.run_cycle().await;\n        }\n\n        let metrics = loop_instance.get_metrics();\n        assert_eq!(metrics.total_cycles, 3);\n        assert!(metrics.average_cycle_time \u003e Duration::ZERO);\n    }\n\n    #[test]\n    fn reset_metrics_clears_counters() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.cycle_count = 100;\n        loop_instance.thoughts_produced = 50;\n\n        loop_instance.reset_metrics();\n\n        assert_eq!(loop_instance.cycle_count(), 0);\n        let metrics = loop_instance.get_metrics();\n        assert_eq!(metrics.thoughts_produced, 0);\n    }\n\n    #[test]\n    fn with_config_uses_custom_config() {\n        let config = CognitiveConfig::supercomputer();\n        let loop_instance = CognitiveLoop::with_config(config);\n\n        assert_eq!(\n            loop_instance.config().speed_mode,\n            crate::config::SpeedMode::Supercomputer\n        );\n    }\n\n    #[test]\n    fn config_mut_allows_modification() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.config_mut().accelerate();\n\n        assert_eq!(\n            loop_instance.config().speed_mode,\n            crate::config::SpeedMode::Supercomputer\n        );\n    }\n\n    #[test]\n    fn time_since_last_cycle_increases() {\n        use std::thread::sleep;\n\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.last_cycle = Instant::now();\n\n        sleep(Duration::from_millis(10));\n\n        let elapsed = loop_instance.time_since_last_cycle();\n        assert!(elapsed \u003e= Duration::from_millis(10));\n    }\n\n    #[test]\n    fn should_cycle_respects_timing() {\n        let mut config = CognitiveConfig::human();\n        // Set a very long cycle time\n        config.cycle_base_ms = 10000.0;\n\n        let mut loop_instance = CognitiveLoop::with_config(config);\n        loop_instance.last_cycle = Instant::now();\n\n        // Should not cycle immediately\n        assert!(!loop_instance.should_cycle());\n    }\n\n    #[test]\n    fn time_until_next_cycle_calculates_correctly() {\n        let mut config = CognitiveConfig::human();\n        config.cycle_base_ms = 100.0; // 100ms cycles\n\n        let mut loop_instance = CognitiveLoop::with_config(config);\n        loop_instance.last_cycle = Instant::now();\n\n        let wait_time = loop_instance.time_until_next_cycle();\n        // Should be close to 100ms (allowing for execution time)\n        assert!(wait_time \u003c= Duration::from_millis(100));\n    }\n\n    #[test]\n    fn cycle_result_produced_thought_check() {\n        let result_with_thought = CycleResult::new(\n            0,\n            Duration::from_millis(10),\n            Some(ThoughtId::new()),\n            0.75, // salience\n            0.0,  // valence (neutral)\n            0.5,  // arousal (medium)\n            5,\n            true,\n            StageDurations::default(),\n            None, // No veto\n        );\n        assert!(result_with_thought.produced_thought());\n\n        let result_without_thought = CycleResult::new(\n            0,\n            Duration::from_millis(10),\n            None,\n            0.0, // salience\n            0.0, // valence (neutral)\n            0.5, // arousal (medium)\n            5,\n            true,\n            StageDurations::default(),\n            None, // No veto\n        );\n        assert!(!result_without_thought.produced_thought());\n    }\n\n    #[test]\n    fn cycle_metrics_calculations() {\n        let metrics = CycleMetrics::new(\n            100,                       // total cycles\n            80,                        // thoughts produced\n            Duration::from_millis(50), // average time\n            95.0,                      // on time percentage\n            StageDurations::default(), // average stage durations\n        );\n\n        // Success rate: 80/100 = 0.8\n        assert!((metrics.success_rate() - 0.8).abs() \u003c 0.01);\n\n        // Thoughts per second: 1/0.05 = 20\n        assert!((metrics.thoughts_per_second() - 20.0).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn loop_state_transitions() {\n        let mut loop_instance = CognitiveLoop::new();\n\n        // Stopped -\u003e Running\n        assert_eq!(loop_instance.state(), LoopState::Stopped);\n        loop_instance.start();\n        assert_eq!(loop_instance.state(), LoopState::Running);\n\n        // Running -\u003e Paused\n        loop_instance.pause();\n        assert_eq!(loop_instance.state(), LoopState::Paused);\n\n        // Paused -\u003e Running\n        loop_instance.start();\n        assert_eq!(loop_instance.state(), LoopState::Running);\n\n        // Running -\u003e Stopped\n        loop_instance.stop();\n        assert_eq!(loop_instance.state(), LoopState::Stopped);\n    }\n\n    #[tokio::test]\n    async fn on_time_tracking() {\n        let mut config = CognitiveConfig::human();\n        // Set a very long cycle time so we're always on time\n        config.cycle_base_ms = 10000.0;\n\n        let mut loop_instance = CognitiveLoop::with_config(config);\n        loop_instance.start();\n\n        // Run a cycle - should be on time\n        let result = loop_instance.run_cycle().await;\n        assert!(result.on_time);\n\n        let metrics = loop_instance.get_metrics();\n        assert_eq!(metrics.on_time_percentage, 100.0);\n    }\n\n    #[tokio::test]\n    async fn stages_execute_in_order() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n\n        let result = loop_instance.run_cycle().await;\n\n        // All stages should have non-zero durations\n        assert!(result.stage_durations.trigger \u003e Duration::ZERO);\n        assert!(result.stage_durations.autoflow \u003e Duration::ZERO);\n        assert!(result.stage_durations.attention \u003e Duration::ZERO);\n        assert!(result.stage_durations.assembly \u003e Duration::ZERO);\n        assert!(result.stage_durations.anchor \u003e Duration::ZERO);\n\n        // Total stage time should approximately equal total cycle time\n        let stage_total = result.stage_durations.total();\n        let difference = result.duration.abs_diff(stage_total);\n\n        // Allow some overhead for execution (should be small)\n        assert!(\n            difference \u003c Duration::from_millis(5),\n            \"Stage total ({:?}) should approximately equal cycle duration ({:?})\",\n            stage_total,\n            result.duration\n        );\n    }\n\n    #[tokio::test]\n    async fn cycle_time_equals_sum_of_stage_delays() {\n        let config = CognitiveConfig::human();\n        let mut loop_instance = CognitiveLoop::with_config(config);\n        loop_instance.start();\n\n        let result = loop_instance.run_cycle().await;\n\n        // Calculate expected total from config delays\n        let expected_total = loop_instance.config().trigger_delay()\n            + loop_instance.config().autoflow_interval()\n            + loop_instance.config().attention_delay()\n            + loop_instance.config().assembly_delay()\n            + loop_instance.config().anchor_delay();\n\n        // Actual cycle time should be close to sum of delays\n        // Allow 20ms tolerance for execution overhead and system load variance\n        let difference = result.duration.abs_diff(expected_total);\n\n        assert!(\n            difference \u003c Duration::from_millis(20),\n            \"Cycle duration ({:?}) should approximately equal sum of stage delays ({:?})\",\n            result.duration,\n            expected_total\n        );\n    }\n\n    #[tokio::test]\n    async fn stage_durations_accumulate_in_metrics() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n\n        // Run multiple cycles\n        for _ in 0..3 {\n            let _result = loop_instance.run_cycle().await;\n        }\n\n        let metrics = loop_instance.get_metrics();\n\n        // Average stage durations should be non-zero\n        assert!(metrics.average_stage_durations.trigger \u003e Duration::ZERO);\n        assert!(metrics.average_stage_durations.autoflow \u003e Duration::ZERO);\n        assert!(metrics.average_stage_durations.attention \u003e Duration::ZERO);\n        assert!(metrics.average_stage_durations.assembly \u003e Duration::ZERO);\n        assert!(metrics.average_stage_durations.anchor \u003e Duration::ZERO);\n    }\n\n    #[tokio::test]\n    async fn run_cycle_produces_thoughts() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n\n        let result = loop_instance.run_cycle().await;\n\n        assert!(result.produced_thought());\n        assert!(result.thought_produced.is_some());\n        assert_eq!(result.candidates_evaluated, 1);\n    }\n\n    #[test]\n    fn not_connected_to_redis_by_default() {\n        let loop_instance = CognitiveLoop::new();\n        assert!(!loop_instance.is_connected_to_redis());\n    }\n\n    #[test]\n    fn stage_durations_helper_methods() {\n        let durations = StageDurations {\n            trigger: Duration::from_millis(1),\n            autoflow: Duration::from_millis(2),\n            attention: Duration::from_millis(3),\n            assembly: Duration::from_millis(4),\n            anchor: Duration::from_millis(5),\n        };\n\n        // Test total\n        assert_eq!(durations.total(), Duration::from_millis(15));\n\n        // Test zero\n        let zero = StageDurations::zero();\n        assert_eq!(zero.total(), Duration::ZERO);\n\n        // Test add\n        let doubled = durations.add(\u0026durations);\n        assert_eq!(doubled.trigger, Duration::from_millis(2));\n        assert_eq!(doubled.total(), Duration::from_millis(30));\n\n        // Test div\n        let halved = doubled.div(2);\n        assert_eq!(halved.trigger, Duration::from_millis(1));\n        assert_eq!(halved.total(), Duration::from_millis(15));\n\n        // Test div by zero\n        let zero_div = durations.div(0);\n        assert_eq!(zero_div.total(), Duration::ZERO);\n    }\n\n    // =========================================================================\n    // TUI-VIS-6: Volition Veto Log - CycleResult Tests\n    // =========================================================================\n\n    #[test]\n    fn cycle_result_veto_field_initialization_none() {\n        let result = CycleResult::new(\n            0,\n            Duration::from_millis(10),\n            Some(ThoughtId::new()),\n            0.75,\n            0.0,\n            0.5,\n            5,\n            true,\n            StageDurations::default(),\n            None, // No veto\n        );\n\n        assert!(result.veto.is_none());\n    }\n\n    #[test]\n    fn cycle_result_veto_field_with_reason_and_value() {\n        let veto_data = Some((\n            \"Violates honesty value\".to_string(),\n            Some(\"honesty\".to_string()),\n        ));\n\n        let result = CycleResult::new(\n            0,\n            Duration::from_millis(10),\n            None, // No thought produced due to veto\n            0.75,\n            0.0,\n            0.5,\n            5,\n            true,\n            StageDurations::default(),\n            veto_data.clone(),\n        );\n\n        assert!(result.veto.is_some());\n        let (reason, value) = result.veto.unwrap();\n        assert_eq!(reason, \"Violates honesty value\");\n        assert_eq!(value, Some(\"honesty\".to_string()));\n    }\n\n    #[test]\n    fn cycle_result_veto_field_with_reason_no_value() {\n        let veto_data = Some((\"Generic violation\".to_string(), None));\n\n        let result = CycleResult::new(\n            0,\n            Duration::from_millis(10),\n            None,\n            0.75,\n            0.0,\n            0.5,\n            5,\n            true,\n            StageDurations::default(),\n            veto_data,\n        );\n\n        assert!(result.veto.is_some());\n        let (reason, value) = result.veto.unwrap();\n        assert_eq!(reason, \"Generic violation\");\n        assert!(value.is_none());\n    }\n\n    #[test]\n    fn cycle_result_vetoed_thought_not_produced() {\n        // When a veto occurs, thought_produced should be None\n        let veto_data = Some((\n            \"Thought vetoed by VolitionActor\".to_string(),\n            Some(\"integrity\".to_string()),\n        ));\n\n        let result = CycleResult::new(\n            0,\n            Duration::from_millis(10),\n            None, // No thought produced\n            0.75,\n            0.0,\n            0.5,\n            5,\n            true,\n            StageDurations::default(),\n            veto_data,\n        );\n\n        assert!(!result.produced_thought());\n        assert!(result.thought_produced.is_none());\n        assert!(result.veto.is_some());\n    }\n\n    #[test]\n    fn cycle_result_non_vetoed_thought_produced() {\n        // When no veto occurs, thought_produced should have a value\n        let result = CycleResult::new(\n            0,\n            Duration::from_millis(10),\n            Some(ThoughtId::new()),\n            0.75,\n            0.0,\n            0.5,\n            5,\n            true,\n            StageDurations::default(),\n            None, // No veto\n        );\n\n        assert!(result.produced_thought());\n        assert!(result.thought_produced.is_some());\n        assert!(result.veto.is_none());\n    }\n\n    #[test]\n    fn cycle_result_veto_field_cloneable() {\n        let veto_data = Some((\"Test veto\".to_string(), Some(\"test_value\".to_string())));\n\n        let result = CycleResult::new(\n            0,\n            Duration::from_millis(10),\n            None,\n            0.75,\n            0.0,\n            0.5,\n            5,\n            true,\n            StageDurations::default(),\n            veto_data,\n        );\n\n        let cloned = result.clone();\n\n        assert_eq!(cloned.veto, result.veto);\n        if let Some((reason, value)) = cloned.veto {\n            assert_eq!(reason, \"Test veto\");\n            assert_eq!(value, Some(\"test_value\".to_string()));\n        } else {\n            panic!(\"Veto data should be present\");\n        }\n    }\n\n    #[test]\n    fn cycle_result_veto_multiple_violated_values() {\n        // Test different violated value scenarios\n        let test_cases = vec![\n            (\"Violates honesty\", Some(\"honesty\".to_string())),\n            (\"Violates integrity\", Some(\"integrity\".to_string())),\n            (\n                \"Violates life honours life\",\n                Some(\"life honours life\".to_string()),\n            ),\n            (\"Unknown violation\", None),\n        ];\n\n        for (reason, value) in test_cases {\n            let veto_data = Some((reason.to_string(), value.clone()));\n\n            let result = CycleResult::new(\n                0,\n                Duration::from_millis(10),\n                None,\n                0.75,\n                0.0,\n                0.5,\n                5,\n                true,\n                StageDurations::default(),\n                veto_data,\n            );\n\n            assert!(result.veto.is_some());\n            let (res_reason, res_value) = result.veto.unwrap();\n            assert_eq!(res_reason, reason);\n            assert_eq!(res_value, value);\n        }\n    }\n\n    #[tokio::test]\n    async fn cycle_result_veto_preserves_salience_and_emotion() {\n        // Even when vetoed, salience and emotion data should be preserved\n        let veto_data = Some((\"Vetoed thought\".to_string(), Some(\"test_value\".to_string())));\n\n        let result = CycleResult::new(\n            0,\n            Duration::from_millis(10),\n            None,\n            0.85, // salience\n            0.3,  // valence (slightly positive)\n            0.7,  // arousal (moderately high)\n            5,\n            true,\n            StageDurations::default(),\n            veto_data,\n        );\n\n        // Veto should be present\n        assert!(result.veto.is_some());\n        // Thought not produced\n        assert!(!result.produced_thought());\n        // But emotional data should be preserved\n        assert_eq!(result.salience, 0.85);\n        assert_eq!(result.valence, 0.3);\n        assert_eq!(result.arousal, 0.7);\n    }\n\n    #[test]\n    fn cycle_result_debug_format_includes_veto() {\n        let veto_data = Some((\n            \"Test veto reason\".to_string(),\n            Some(\"test_value\".to_string()),\n        ));\n\n        let result = CycleResult::new(\n            0,\n            Duration::from_millis(10),\n            None,\n            0.75,\n            0.0,\n            0.5,\n            5,\n            true,\n            StageDurations::default(),\n            veto_data,\n        );\n\n        // Debug format should include veto field\n        let debug_str = format!(\"{:?}\", result);\n        assert!(debug_str.contains(\"veto\"));\n        assert!(debug_str.contains(\"Test veto reason\"));\n    }\n\n    // =========================================================================\n    // Additional Coverage Tests\n    // =========================================================================\n\n    #[test]\n    fn default_impl_creates_new_loop() {\n        let loop_instance = CognitiveLoop::default();\n        assert_eq!(loop_instance.state(), LoopState::Stopped);\n        assert_eq!(loop_instance.cycle_count(), 0);\n        assert!(!loop_instance.is_running());\n    }\n\n    #[test]\n    fn set_consolidation_threshold_clamps_values() {\n        let mut loop_instance = CognitiveLoop::new();\n\n        // Test normal value\n        loop_instance.set_consolidation_threshold(0.5);\n        assert_eq!(loop_instance.consolidation_threshold, 0.5);\n\n        // Test clamping above 1.0\n        loop_instance.set_consolidation_threshold(1.5);\n        assert_eq!(loop_instance.consolidation_threshold, 1.0);\n\n        // Test clamping below 0.0\n        loop_instance.set_consolidation_threshold(-0.5);\n        assert_eq!(loop_instance.consolidation_threshold, 0.0);\n\n        // Test boundary values\n        loop_instance.set_consolidation_threshold(0.0);\n        assert_eq!(loop_instance.consolidation_threshold, 0.0);\n\n        loop_instance.set_consolidation_threshold(1.0);\n        assert_eq!(loop_instance.consolidation_threshold, 1.0);\n    }\n\n    #[test]\n    fn memory_db_returns_none_when_not_set() {\n        let loop_instance = CognitiveLoop::new();\n        assert!(loop_instance.memory_db().is_none());\n    }\n\n    #[test]\n    fn pause_from_stopped_stays_stopped() {\n        let mut loop_instance = CognitiveLoop::new();\n        assert_eq!(loop_instance.state(), LoopState::Stopped);\n\n        // Pause when stopped should not change state\n        loop_instance.pause();\n        assert_eq!(loop_instance.state(), LoopState::Stopped);\n    }\n\n    #[test]\n    fn pause_from_paused_stays_paused() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n        loop_instance.pause();\n        assert_eq!(loop_instance.state(), LoopState::Paused);\n\n        // Pause when already paused should not change state\n        loop_instance.pause();\n        assert_eq!(loop_instance.state(), LoopState::Paused);\n    }\n\n    #[test]\n    fn time_until_next_cycle_returns_zero_when_behind_schedule() {\n        let mut config = CognitiveConfig::human();\n        config.cycle_base_ms = 1.0; // 1ms cycles\n\n        let mut loop_instance = CognitiveLoop::with_config(config);\n        // Set last_cycle to a time in the past\n        loop_instance.last_cycle = Instant::now() - Duration::from_millis(100);\n\n        // Should return zero since we're way behind schedule\n        let wait_time = loop_instance.time_until_next_cycle();\n        assert_eq!(wait_time, Duration::ZERO);\n    }\n\n    #[test]\n    fn should_cycle_returns_true_when_time_elapsed() {\n        let mut config = CognitiveConfig::human();\n        config.cycle_base_ms = 1.0; // 1ms cycles\n\n        let mut loop_instance = CognitiveLoop::with_config(config);\n        // Set last_cycle to a time in the past\n        loop_instance.last_cycle = Instant::now() - Duration::from_millis(100);\n\n        // Should cycle since enough time has passed\n        assert!(loop_instance.should_cycle());\n    }\n\n    #[test]\n    fn cycle_metrics_thoughts_per_second_zero_time() {\n        let metrics = CycleMetrics::new(\n            100,\n            80,\n            Duration::ZERO, // Zero average time\n            95.0,\n            StageDurations::default(),\n        );\n\n        // When average time is zero, should return 0.0\n        assert_eq!(metrics.thoughts_per_second(), 0.0);\n    }\n\n    #[test]\n    fn cycle_metrics_success_rate_zero_cycles() {\n        let metrics = CycleMetrics::new(\n            0, // Zero cycles\n            0,\n            Duration::from_millis(50),\n            0.0,\n            StageDurations::default(),\n        );\n\n        // When total_cycles is zero, should return 0.0\n        assert_eq!(metrics.success_rate(), 0.0);\n    }\n\n    #[test]\n    fn get_metrics_with_zero_cycles() {\n        let loop_instance = CognitiveLoop::new();\n        let metrics = loop_instance.get_metrics();\n\n        assert_eq!(metrics.total_cycles, 0);\n        assert_eq!(metrics.thoughts_produced, 0);\n        assert_eq!(metrics.average_cycle_time, Duration::ZERO);\n        assert_eq!(metrics.on_time_percentage, 0.0);\n    }\n\n    #[test]\n    fn cognitive_stage_enum_variants() {\n        // Test all CognitiveStage variants for coverage\n        let trigger = CognitiveStage::Trigger;\n        let autoflow = CognitiveStage::Autoflow;\n        let attention = CognitiveStage::Attention;\n        let assembly = CognitiveStage::Assembly;\n        let anchor = CognitiveStage::Anchor;\n\n        // Test Debug trait\n        assert!(format!(\"{:?}\", trigger).contains(\"Trigger\"));\n        assert!(format!(\"{:?}\", autoflow).contains(\"Autoflow\"));\n        assert!(format!(\"{:?}\", attention).contains(\"Attention\"));\n        assert!(format!(\"{:?}\", assembly).contains(\"Assembly\"));\n        assert!(format!(\"{:?}\", anchor).contains(\"Anchor\"));\n\n        // Test Clone\n        let trigger_clone = trigger.clone();\n        assert_eq!(trigger_clone, CognitiveStage::Trigger);\n\n        // Test Copy\n        let trigger_copy = trigger;\n        assert_eq!(trigger_copy, CognitiveStage::Trigger);\n\n        // Test PartialEq\n        assert_eq!(trigger, CognitiveStage::Trigger);\n        assert_ne!(trigger, autoflow);\n    }\n\n    #[test]\n    fn loop_state_enum_variants() {\n        // Test all LoopState variants for coverage\n        let running = LoopState::Running;\n        let paused = LoopState::Paused;\n        let stopped = LoopState::Stopped;\n\n        // Test Debug trait\n        assert!(format!(\"{:?}\", running).contains(\"Running\"));\n        assert!(format!(\"{:?}\", paused).contains(\"Paused\"));\n        assert!(format!(\"{:?}\", stopped).contains(\"Stopped\"));\n\n        // Test Clone\n        let running_clone = running.clone();\n        assert_eq!(running_clone, LoopState::Running);\n\n        // Test Copy\n        let running_copy = running;\n        assert_eq!(running_copy, LoopState::Running);\n\n        // Test PartialEq\n        assert_eq!(running, LoopState::Running);\n        assert_ne!(running, paused);\n    }\n\n    #[test]\n    fn parse_injection_fields_valid() {\n        use redis::Value;\n\n        // Build valid field-value array\n        let fields = vec![\n            Value::BulkString(b\"content\".to_vec()),\n            Value::BulkString(br#\"{\"Symbol\":{\"id\":\"test_symbol\",\"data\":[1,2,3,4]}}\"#.to_vec()),\n            Value::BulkString(b\"salience\".to_vec()),\n            Value::BulkString(\n                br#\"{\"importance\":0.5,\"novelty\":0.5,\"relevance\":0.5,\"valence\":0.0,\"arousal\":0.5,\"connection_relevance\":0.5}\"#.to_vec(),\n            ),\n        ];\n\n        let result = CognitiveLoop::parse_injection_fields(\u0026fields);\n        assert!(result.is_ok());\n\n        let (content, salience) = result.unwrap();\n        // Verify content parsed correctly\n        assert!(format!(\"{:?}\", content).contains(\"Symbol\"));\n        // Verify salience parsed correctly\n        assert_eq!(salience.importance, 0.5);\n        assert_eq!(salience.novelty, 0.5);\n    }\n\n    #[test]\n    fn parse_injection_fields_missing_content() {\n        use redis::Value;\n\n        // Fields without 'content'\n        let fields = vec![\n            Value::BulkString(b\"salience\".to_vec()),\n            Value::BulkString(\n                br#\"{\"importance\":0.5,\"novelty\":0.5,\"relevance\":0.5,\"valence\":0.0,\"arousal\":0.5,\"connection_relevance\":0.5}\"#.to_vec(),\n            ),\n        ];\n\n        let result = CognitiveLoop::parse_injection_fields(\u0026fields);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"Missing 'content' field\"));\n    }\n\n    #[test]\n    fn parse_injection_fields_missing_salience() {\n        use redis::Value;\n\n        // Fields without 'salience'\n        let fields = vec![\n            Value::BulkString(b\"content\".to_vec()),\n            Value::BulkString(br#\"{\"Symbol\":{\"id\":\"test_symbol\",\"data\":[1,2,3,4]}}\"#.to_vec()),\n        ];\n\n        let result = CognitiveLoop::parse_injection_fields(\u0026fields);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"Missing 'salience' field\"));\n    }\n\n    #[test]\n    fn parse_injection_fields_invalid_content_format() {\n        use redis::Value;\n\n        // Content is not a BulkString\n        let fields = vec![\n            Value::BulkString(b\"content\".to_vec()),\n            Value::Int(42), // Invalid: should be BulkString\n            Value::BulkString(b\"salience\".to_vec()),\n            Value::BulkString(\n                br#\"{\"importance\":0.5,\"novelty\":0.5,\"relevance\":0.5,\"valence\":0.0,\"arousal\":0.5,\"connection_relevance\":0.5}\"#.to_vec(),\n            ),\n        ];\n\n        let result = CognitiveLoop::parse_injection_fields(\u0026fields);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"Invalid content format\"));\n    }\n\n    #[test]\n    fn parse_injection_fields_invalid_salience_format() {\n        use redis::Value;\n\n        // Salience is not a BulkString\n        let fields = vec![\n            Value::BulkString(b\"content\".to_vec()),\n            Value::BulkString(br#\"{\"Symbol\":{\"id\":\"test_symbol\",\"data\":[1,2,3,4]}}\"#.to_vec()),\n            Value::BulkString(b\"salience\".to_vec()),\n            Value::Int(42), // Invalid: should be BulkString\n        ];\n\n        let result = CognitiveLoop::parse_injection_fields(\u0026fields);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"Invalid salience format\"));\n    }\n\n    #[test]\n    fn parse_injection_fields_invalid_content_json() {\n        use redis::Value;\n\n        // Content has invalid JSON\n        let fields = vec![\n            Value::BulkString(b\"content\".to_vec()),\n            Value::BulkString(b\"not valid json\".to_vec()),\n            Value::BulkString(b\"salience\".to_vec()),\n            Value::BulkString(\n                br#\"{\"importance\":0.5,\"novelty\":0.5,\"relevance\":0.5,\"valence\":0.0,\"arousal\":0.5,\"connection_relevance\":0.5}\"#.to_vec(),\n            ),\n        ];\n\n        let result = CognitiveLoop::parse_injection_fields(\u0026fields);\n        assert!(result.is_err());\n        assert!(result\n            .unwrap_err()\n            .contains(\"Failed to deserialize content\"));\n    }\n\n    #[test]\n    fn parse_injection_fields_invalid_salience_json() {\n        use redis::Value;\n\n        // Salience has invalid JSON\n        let fields = vec![\n            Value::BulkString(b\"content\".to_vec()),\n            Value::BulkString(br#\"{\"Symbol\":{\"id\":\"test_symbol\",\"data\":[1,2,3,4]}}\"#.to_vec()),\n            Value::BulkString(b\"salience\".to_vec()),\n            Value::BulkString(b\"not valid json\".to_vec()),\n        ];\n\n        let result = CognitiveLoop::parse_injection_fields(\u0026fields);\n        assert!(result.is_err());\n        assert!(result\n            .unwrap_err()\n            .contains(\"Failed to deserialize salience\"));\n    }\n\n    #[test]\n    fn parse_injection_fields_empty_fields() {\n        let fields: Vec\u003credis::Value\u003e = vec![];\n\n        let result = CognitiveLoop::parse_injection_fields(\u0026fields);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"Missing 'content' field\"));\n    }\n\n    #[test]\n    fn parse_injection_fields_odd_number_of_fields() {\n        use redis::Value;\n\n        // Odd number of fields (incomplete pair)\n        let fields = vec![\n            Value::BulkString(b\"content\".to_vec()),\n            Value::BulkString(br#\"{\"Symbol\":{\"id\":\"test_symbol\",\"data\":[1,2,3,4]}}\"#.to_vec()),\n            Value::BulkString(b\"salience\".to_vec()),\n            // Missing value for salience\n        ];\n\n        let result = CognitiveLoop::parse_injection_fields(\u0026fields);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"Missing 'salience' field\"));\n    }\n\n    #[test]\n    fn thought_to_memory_with_source_stream() {\n        let loop_instance = CognitiveLoop::new();\n\n        let content = Content::symbol(\"test\".to_string(), vec![1, 2, 3]);\n        let salience = SalienceScore::new(0.5, 0.5, 0.5, 0.0, 0.5, 0.5);\n        let mut thought = Thought::new(content, salience);\n        thought.source_stream = Some(\"test_stream\".to_string());\n\n        let memory = loop_instance.thought_to_memory(\u0026thought, 0.8);\n\n        // Check that source is External\n        match memory.source {\n            crate::memory_db::MemorySource::External { ref stimulus } =\u003e {\n                assert_eq!(stimulus, \"test_stream\");\n            }\n            _ =\u003e panic!(\"Expected External source\"),\n        }\n    }\n\n    #[test]\n    fn thought_to_memory_without_source_stream() {\n        let loop_instance = CognitiveLoop::new();\n\n        let content = Content::symbol(\"test\".to_string(), vec![1, 2, 3]);\n        let salience = SalienceScore::new(0.5, 0.5, 0.5, 0.0, 0.5, 0.5);\n        let thought = Thought::new(content, salience);\n        // source_stream is None by default\n\n        let memory = loop_instance.thought_to_memory(\u0026thought, 0.8);\n\n        // Check that source is Reasoning\n        match memory.source {\n            crate::memory_db::MemorySource::Reasoning { ref chain } =\u003e {\n                assert!(chain.is_empty());\n            }\n            _ =\u003e panic!(\"Expected Reasoning source\"),\n        }\n    }\n\n    #[test]\n    fn thought_to_memory_preserves_emotional_state() {\n        let loop_instance = CognitiveLoop::new();\n\n        let content = Content::symbol(\"test\".to_string(), vec![1, 2, 3]);\n        let salience = SalienceScore::new(\n            0.8, // importance\n            0.5, // novelty\n            0.5, // relevance\n            0.6, // valence (positive)\n            0.7, // arousal\n            0.5, // connection_relevance\n        );\n        let thought = Thought::new(content, salience);\n\n        let memory = loop_instance.thought_to_memory(\u0026thought, 0.8);\n\n        // Emotional state should be preserved (valence -\u003e valence, importance -\u003e arousal)\n        // Memory.with_emotion(valence, arousal) - importance becomes arousal\n        assert_eq!(memory.emotional_state.valence, 0.6);\n        assert_eq!(memory.emotional_state.arousal, 0.8);\n    }\n\n    #[test]\n    fn stage_durations_default_is_zero() {\n        let durations = StageDurations::default();\n        assert_eq!(durations.trigger, Duration::ZERO);\n        assert_eq!(durations.autoflow, Duration::ZERO);\n        assert_eq!(durations.attention, Duration::ZERO);\n        assert_eq!(durations.assembly, Duration::ZERO);\n        assert_eq!(durations.anchor, Duration::ZERO);\n        assert_eq!(durations.total(), Duration::ZERO);\n    }\n\n    #[test]\n    fn cycle_result_all_fields() {\n        let thought_id = ThoughtId::new();\n        let stage_durations = StageDurations {\n            trigger: Duration::from_millis(1),\n            autoflow: Duration::from_millis(2),\n            attention: Duration::from_millis(3),\n            assembly: Duration::from_millis(4),\n            anchor: Duration::from_millis(5),\n        };\n\n        let result = CycleResult::new(\n            42,\n            Duration::from_millis(20),\n            Some(thought_id),\n            0.85,\n            0.3,\n            0.7,\n            10,\n            true,\n            stage_durations,\n            None,\n        );\n\n        assert_eq!(result.cycle_number, 42);\n        assert_eq!(result.duration, Duration::from_millis(20));\n        assert_eq!(result.thought_produced, Some(thought_id));\n        assert_eq!(result.salience, 0.85);\n        assert_eq!(result.valence, 0.3);\n        assert_eq!(result.arousal, 0.7);\n        assert_eq!(result.candidates_evaluated, 10);\n        assert!(result.on_time);\n        assert_eq!(result.stage_durations.total(), Duration::from_millis(15));\n        assert!(result.veto.is_none());\n    }\n\n    #[test]\n    fn cycle_metrics_all_fields() {\n        let stage_durations = StageDurations {\n            trigger: Duration::from_millis(1),\n            autoflow: Duration::from_millis(2),\n            attention: Duration::from_millis(3),\n            assembly: Duration::from_millis(4),\n            anchor: Duration::from_millis(5),\n        };\n\n        let metrics =\n            CycleMetrics::new(1000, 800, Duration::from_millis(25), 95.5, stage_durations);\n\n        assert_eq!(metrics.total_cycles, 1000);\n        assert_eq!(metrics.thoughts_produced, 800);\n        assert_eq!(metrics.average_cycle_time, Duration::from_millis(25));\n        assert_eq!(metrics.on_time_percentage, 95.5);\n        assert_eq!(\n            metrics.average_stage_durations.total(),\n            Duration::from_millis(15)\n        );\n    }\n\n    #[tokio::test]\n    async fn run_cycle_updates_thoughts_produced_counter() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n\n        assert_eq!(loop_instance.thoughts_produced, 0);\n\n        let result = loop_instance.run_cycle().await;\n\n        // A thought should be produced (unless vetoed)\n        if result.produced_thought() {\n            assert_eq!(loop_instance.thoughts_produced, 1);\n        }\n    }\n\n    #[tokio::test]\n    async fn run_cycle_updates_total_duration() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n\n        assert_eq!(loop_instance.total_duration, Duration::ZERO);\n\n        let result = loop_instance.run_cycle().await;\n\n        assert!(loop_instance.total_duration \u003e= result.duration);\n    }\n\n    #[tokio::test]\n    async fn generate_random_thought_produces_valid_content() {\n        let mut loop_instance = CognitiveLoop::new();\n\n        let (content, salience) = loop_instance.generate_random_thought();\n\n        // Content should be a Symbol\n        match content {\n            Content::Symbol { ref id, ref data } =\u003e {\n                assert!(id.starts_with(\"thought_\"));\n                assert_eq!(data.len(), 8);\n            }\n            _ =\u003e panic!(\"Expected Symbol content\"),\n        }\n\n        // Salience values should be in valid ranges\n        assert!(salience.importance \u003e= 0.0 \u0026\u0026 salience.importance \u003c= 1.0);\n        assert!(salience.novelty \u003e= 0.0 \u0026\u0026 salience.novelty \u003c= 1.0);\n        assert!(salience.relevance \u003e= 0.0 \u0026\u0026 salience.relevance \u003c= 1.0);\n        assert!(salience.valence \u003e= -1.0 \u0026\u0026 salience.valence \u003c= 1.0);\n        assert!(salience.arousal \u003e= 0.0 \u0026\u0026 salience.arousal \u003c= 1.0);\n        assert!(salience.connection_relevance \u003e= 0.1 \u0026\u0026 salience.connection_relevance \u003c= 1.0);\n    }\n\n    #[tokio::test]\n    async fn read_external_stimuli_returns_empty_without_redis() {\n        let loop_instance = CognitiveLoop::new();\n\n        let stimuli = loop_instance.read_external_stimuli().await;\n\n        assert!(stimuli.is_empty());\n    }\n\n    #[test]\n    fn config_accessor_returns_config() {\n        let config = CognitiveConfig::supercomputer();\n        let loop_instance = CognitiveLoop::with_config(config.clone());\n\n        assert_eq!(\n            loop_instance.config().speed_mode,\n            crate::config::SpeedMode::Supercomputer\n        );\n    }\n\n    #[tokio::test]\n    async fn multiple_cycles_accumulate_stage_durations() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n\n        // Run first cycle\n        let _result1 = loop_instance.run_cycle().await;\n        let first_total = loop_instance.total_stage_durations.total();\n\n        // Run second cycle\n        let _result2 = loop_instance.run_cycle().await;\n        let second_total = loop_instance.total_stage_durations.total();\n\n        // Second total should be greater than first\n        assert!(second_total \u003e first_total);\n    }\n\n    #[test]\n    fn stage_durations_div_by_large_number() {\n        let durations = StageDurations {\n            trigger: Duration::from_secs(100),\n            autoflow: Duration::from_secs(200),\n            attention: Duration::from_secs(300),\n            assembly: Duration::from_secs(400),\n            anchor: Duration::from_secs(500),\n        };\n\n        // Divide by 100\n        let result = durations.div(100);\n\n        assert_eq!(result.trigger, Duration::from_secs(1));\n        assert_eq!(result.autoflow, Duration::from_secs(2));\n        assert_eq!(result.attention, Duration::from_secs(3));\n        assert_eq!(result.assembly, Duration::from_secs(4));\n        assert_eq!(result.anchor, Duration::from_secs(5));\n    }\n\n    #[tokio::test]\n    async fn run_cycle_salience_in_valid_range() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n\n        // Run multiple cycles to check salience values\n        for _ in 0..10 {\n            let result = loop_instance.run_cycle().await;\n\n            // Composite salience should be between 0.0 and 1.0\n            assert!(\n                result.salience \u003e= 0.0 \u0026\u0026 result.salience \u003c= 1.0,\n                \"Salience {} out of range\",\n                result.salience\n            );\n\n            // Valence should be between -1.0 and 1.0\n            assert!(\n                result.valence \u003e= -1.0 \u0026\u0026 result.valence \u003c= 1.0,\n                \"Valence {} out of range\",\n                result.valence\n            );\n\n            // Arousal should be between 0.0 and 1.0\n            assert!(\n                result.arousal \u003e= 0.0 \u0026\u0026 result.arousal \u003c= 1.0,\n                \"Arousal {} out of range\",\n                result.arousal\n            );\n        }\n    }\n\n    #[test]\n    fn stop_from_any_state() {\n        let mut loop_instance = CognitiveLoop::new();\n\n        // Stop from Stopped\n        loop_instance.stop();\n        assert_eq!(loop_instance.state(), LoopState::Stopped);\n\n        // Stop from Running\n        loop_instance.start();\n        loop_instance.stop();\n        assert_eq!(loop_instance.state(), LoopState::Stopped);\n\n        // Stop from Paused\n        loop_instance.start();\n        loop_instance.pause();\n        loop_instance.stop();\n        assert_eq!(loop_instance.state(), LoopState::Stopped);\n    }\n\n    #[test]\n    fn start_from_any_state() {\n        let mut loop_instance = CognitiveLoop::new();\n\n        // Start from Stopped\n        loop_instance.start();\n        assert_eq!(loop_instance.state(), LoopState::Running);\n\n        // Start from Paused\n        loop_instance.pause();\n        loop_instance.start();\n        assert_eq!(loop_instance.state(), LoopState::Running);\n\n        // Start from Running (no change)\n        loop_instance.start();\n        assert_eq!(loop_instance.state(), LoopState::Running);\n    }\n\n    #[test]\n    fn memory_db_getter_returns_none_initially() {\n        let loop_instance = CognitiveLoop::new();\n\n        // Initially no memory_db\n        assert!(loop_instance.memory_db().is_none());\n\n        // Note: We can't actually test with a real MemoryDb without Qdrant connection\n        // but we can verify the API signature works correctly\n    }\n\n    #[test]\n    fn cycles_on_time_initialized_to_zero() {\n        let loop_instance = CognitiveLoop::new();\n        assert_eq!(loop_instance.cycles_on_time, 0);\n    }\n\n    #[tokio::test]\n    async fn cycles_on_time_incremented_when_on_time() {\n        let mut config = CognitiveConfig::human();\n        config.cycle_base_ms = 10000.0; // Very long target so we're always on time\n\n        let mut loop_instance = CognitiveLoop::with_config(config);\n        loop_instance.start();\n\n        assert_eq!(loop_instance.cycles_on_time, 0);\n\n        let result = loop_instance.run_cycle().await;\n        assert!(result.on_time);\n        assert_eq!(loop_instance.cycles_on_time, 1);\n    }\n\n    #[test]\n    fn last_cycle_field_exists() {\n        let loop_instance = CognitiveLoop::new();\n        // last_cycle should be set to now during construction\n        let elapsed = loop_instance.last_cycle.elapsed();\n        // Should be very recent (less than 100ms)\n        assert!(elapsed \u003c Duration::from_millis(100));\n    }\n\n    #[tokio::test]\n    async fn last_cycle_updated_after_run_cycle() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n\n        let before_cycle = loop_instance.last_cycle;\n\n        // Small delay to ensure time difference\n        tokio::time::sleep(Duration::from_millis(5)).await;\n\n        let _result = loop_instance.run_cycle().await;\n\n        // last_cycle should be updated after run_cycle\n        assert!(loop_instance.last_cycle \u003e before_cycle);\n    }\n\n    #[test]\n    fn parse_injection_fields_with_non_bulk_string_key() {\n        use redis::Value;\n\n        // Key is not a BulkString - should be skipped\n        let fields = vec![\n            Value::Int(123), // Invalid key (not BulkString)\n            Value::BulkString(br#\"{\"Symbol\":{\"id\":\"test_symbol\",\"data\":[1,2,3,4]}}\"#.to_vec()),\n            Value::BulkString(b\"salience\".to_vec()),\n            Value::BulkString(\n                br#\"{\"importance\":0.5,\"novelty\":0.5,\"relevance\":0.5,\"valence\":0.0,\"arousal\":0.5,\"connection_relevance\":0.5}\"#.to_vec(),\n            ),\n        ];\n\n        // Should fail because content key wasn't found (the int was skipped)\n        let result = CognitiveLoop::parse_injection_fields(\u0026fields);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn stage_durations_add_commutative() {\n        let a = StageDurations {\n            trigger: Duration::from_millis(1),\n            autoflow: Duration::from_millis(2),\n            attention: Duration::from_millis(3),\n            assembly: Duration::from_millis(4),\n            anchor: Duration::from_millis(5),\n        };\n\n        let b = StageDurations {\n            trigger: Duration::from_millis(10),\n            autoflow: Duration::from_millis(20),\n            attention: Duration::from_millis(30),\n            assembly: Duration::from_millis(40),\n            anchor: Duration::from_millis(50),\n        };\n\n        let ab = a.add(\u0026b);\n        let ba = b.add(\u0026a);\n\n        // Addition should be commutative\n        assert_eq!(ab.trigger, ba.trigger);\n        assert_eq!(ab.autoflow, ba.autoflow);\n        assert_eq!(ab.attention, ba.attention);\n        assert_eq!(ab.assembly, ba.assembly);\n        assert_eq!(ab.anchor, ba.anchor);\n    }\n\n    #[test]\n    fn cycle_result_clone() {\n        let result = CycleResult::new(\n            42,\n            Duration::from_millis(100),\n            Some(ThoughtId::new()),\n            0.85,\n            0.3,\n            0.7,\n            5,\n            true,\n            StageDurations::default(),\n            Some((\"test reason\".to_string(), Some(\"test_value\".to_string()))),\n        );\n\n        let cloned = result.clone();\n\n        assert_eq!(cloned.cycle_number, result.cycle_number);\n        assert_eq!(cloned.duration, result.duration);\n        assert_eq!(cloned.salience, result.salience);\n        assert_eq!(cloned.valence, result.valence);\n        assert_eq!(cloned.arousal, result.arousal);\n        assert_eq!(cloned.on_time, result.on_time);\n    }\n\n    #[test]\n    fn cycle_metrics_clone() {\n        let metrics = CycleMetrics::new(\n            100,\n            80,\n            Duration::from_millis(50),\n            95.0,\n            StageDurations::default(),\n        );\n\n        let cloned = metrics.clone();\n\n        assert_eq!(cloned.total_cycles, metrics.total_cycles);\n        assert_eq!(cloned.thoughts_produced, metrics.thoughts_produced);\n        assert_eq!(cloned.average_cycle_time, metrics.average_cycle_time);\n        assert_eq!(cloned.on_time_percentage, metrics.on_time_percentage);\n    }\n\n    #[test]\n    fn stage_durations_clone() {\n        let durations = StageDurations {\n            trigger: Duration::from_millis(1),\n            autoflow: Duration::from_millis(2),\n            attention: Duration::from_millis(3),\n            assembly: Duration::from_millis(4),\n            anchor: Duration::from_millis(5),\n        };\n\n        let cloned = durations.clone();\n\n        assert_eq!(cloned.trigger, durations.trigger);\n        assert_eq!(cloned.autoflow, durations.autoflow);\n        assert_eq!(cloned.attention, durations.attention);\n        assert_eq!(cloned.assembly, durations.assembly);\n        assert_eq!(cloned.anchor, durations.anchor);\n    }\n\n    #[tokio::test]\n    async fn run_cycle_without_redis_or_memory_db() {\n        // Test that run_cycle works correctly in standalone mode\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n\n        // Should complete without errors\n        let result = loop_instance.run_cycle().await;\n\n        // Basic assertions\n        assert_eq!(result.cycle_number, 0);\n        assert!(result.duration \u003e Duration::ZERO);\n        assert_eq!(result.candidates_evaluated, 1);\n    }\n\n    #[tokio::test]\n    async fn generate_random_thought_increments_cycle_id_in_symbol() {\n        let mut loop_instance = CognitiveLoop::new();\n\n        // First thought\n        let (content1, _) = loop_instance.generate_random_thought();\n        loop_instance.cycle_count += 1;\n\n        // Second thought\n        let (content2, _) = loop_instance.generate_random_thought();\n\n        // Symbol IDs should be different and based on cycle_count\n        match (content1, content2) {\n            (Content::Symbol { id: id1, .. }, Content::Symbol { id: id2, .. }) =\u003e {\n                assert_ne!(id1, id2);\n                assert!(id1.contains(\"thought_\"));\n                assert!(id2.contains(\"thought_\"));\n            }\n            _ =\u003e panic!(\"Expected Symbol content\"),\n        }\n    }\n\n    #[test]\n    fn consolidation_threshold_default() {\n        let loop_instance = CognitiveLoop::new();\n        assert_eq!(loop_instance.consolidation_threshold, 0.7);\n    }\n\n    #[tokio::test]\n    async fn generate_random_thought_connection_relevance_min() {\n        // Run many iterations to check connection_relevance respects minimum\n        let mut loop_instance = CognitiveLoop::new();\n\n        for _ in 0..100 {\n            let (_, salience) = loop_instance.generate_random_thought();\n            // Connection relevance should always be \u003e= 0.1 per the invariant\n            assert!(\n                salience.connection_relevance \u003e= 0.1,\n                \"connection_relevance {} below minimum 0.1\",\n                salience.connection_relevance\n            );\n        }\n    }\n\n    #[test]\n    fn cycle_result_debug_format() {\n        let result = CycleResult::new(\n            0,\n            Duration::from_millis(10),\n            Some(ThoughtId::new()),\n            0.75,\n            0.0,\n            0.5,\n            5,\n            true,\n            StageDurations::default(),\n            None,\n        );\n\n        let debug_str = format!(\"{:?}\", result);\n\n        assert!(debug_str.contains(\"CycleResult\"));\n        assert!(debug_str.contains(\"cycle_number\"));\n        assert!(debug_str.contains(\"duration\"));\n        assert!(debug_str.contains(\"salience\"));\n    }\n\n    #[test]\n    fn cycle_metrics_debug_format() {\n        let metrics = CycleMetrics::new(\n            100,\n            80,\n            Duration::from_millis(50),\n            95.0,\n            StageDurations::default(),\n        );\n\n        let debug_str = format!(\"{:?}\", metrics);\n\n        assert!(debug_str.contains(\"CycleMetrics\"));\n        assert!(debug_str.contains(\"total_cycles\"));\n        assert!(debug_str.contains(\"thoughts_produced\"));\n    }\n\n    #[test]\n    fn stage_durations_debug_format() {\n        let durations = StageDurations::default();\n\n        let debug_str = format!(\"{:?}\", durations);\n\n        assert!(debug_str.contains(\"StageDurations\"));\n        assert!(debug_str.contains(\"trigger\"));\n        assert!(debug_str.contains(\"autoflow\"));\n    }\n\n    // =========================================================================\n    // Additional Coverage Tests - Consolidation and Memory Paths\n    // =========================================================================\n\n    #[tokio::test]\n    async fn consolidate_memory_without_memory_db() {\n        // Test that consolidate_memory returns early without memory_db\n        let loop_instance = CognitiveLoop::new();\n        assert!(loop_instance.memory_db().is_none());\n\n        // Create a high-salience thought that would be consolidated\n        let content = Content::symbol(\"high_salience_thought\".to_string(), vec![1, 2, 3, 4]);\n        let salience = SalienceScore::new(0.95, 0.9, 0.9, 0.5, 0.8, 0.9);\n        let thought = Thought::new(content, salience);\n\n        // Should not panic and return early due to no memory_db\n        loop_instance.consolidate_memory(\u0026thought).await;\n        // If we get here without panic, the early return path works\n    }\n\n    #[tokio::test]\n    async fn consolidate_memory_below_threshold() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.set_consolidation_threshold(0.9); // High threshold\n\n        // Create a low-salience thought (below threshold)\n        let content = Content::symbol(\"low_salience_thought\".to_string(), vec![1, 2, 3, 4]);\n        let salience = SalienceScore::new(0.3, 0.2, 0.3, 0.0, 0.2, 0.3);\n        let thought = Thought::new(content, salience);\n\n        // Without memory_db, this will return early anyway, but tests the path\n        loop_instance.consolidate_memory(\u0026thought).await;\n    }\n\n    #[test]\n    fn thought_to_memory_with_composite_content() {\n        let loop_instance = CognitiveLoop::new();\n\n        // Create composite content to test that branch\n        let content = Content::Composite(vec![\n            Content::symbol(\"part1\".to_string(), vec![1, 2]),\n            Content::symbol(\"part2\".to_string(), vec![3, 4]),\n        ]);\n        let salience = SalienceScore::new(0.5, 0.5, 0.5, 0.0, 0.5, 0.5);\n        let thought = Thought::new(content, salience);\n\n        let memory = loop_instance.thought_to_memory(\u0026thought, 0.8);\n\n        // Content should be serialized\n        assert!(!memory.content.is_empty());\n    }\n\n    #[test]\n    fn thought_to_memory_with_relation_content() {\n        let loop_instance = CognitiveLoop::new();\n\n        // Create relation content to test that branch\n        let content = Content::Relation {\n            subject: Box::new(Content::symbol(\"subject\".to_string(), vec![1])),\n            predicate: \"relates_to\".to_string(),\n            object: Box::new(Content::symbol(\"object\".to_string(), vec![2])),\n        };\n        let salience = SalienceScore::new(0.5, 0.5, 0.5, 0.0, 0.5, 0.5);\n        let thought = Thought::new(content, salience);\n\n        let memory = loop_instance.thought_to_memory(\u0026thought, 0.8);\n\n        // Content should be serialized\n        assert!(memory.content.contains(\"relates_to\"));\n    }\n\n    #[test]\n    fn thought_to_memory_with_raw_content() {\n        let loop_instance = CognitiveLoop::new();\n\n        // Create raw content to test that branch\n        let content = Content::Raw(vec![0xDE, 0xAD, 0xBE, 0xEF]);\n        let salience = SalienceScore::new(0.5, 0.5, 0.5, 0.0, 0.5, 0.5);\n        let thought = Thought::new(content, salience);\n\n        let memory = loop_instance.thought_to_memory(\u0026thought, 0.8);\n\n        // Content should be serialized\n        assert!(!memory.content.is_empty());\n    }\n\n    #[test]\n    fn thought_to_memory_with_empty_content() {\n        let loop_instance = CognitiveLoop::new();\n\n        // Create empty content to test that branch\n        let content = Content::Empty;\n        let salience = SalienceScore::new(0.5, 0.5, 0.5, 0.0, 0.5, 0.5);\n        let thought = Thought::new(content, salience);\n\n        let memory = loop_instance.thought_to_memory(\u0026thought, 0.8);\n\n        // Content should be serialized\n        assert!(!memory.content.is_empty());\n    }\n\n    #[tokio::test]\n    async fn run_cycle_with_late_timing() {\n        // Test the case where cycle completes after target time (on_time = false)\n        let mut config = CognitiveConfig::human();\n        config.cycle_base_ms = 0.001; // Very short target (1 microsecond)\n\n        let mut loop_instance = CognitiveLoop::with_config(config);\n        loop_instance.start();\n\n        let result = loop_instance.run_cycle().await;\n\n        // With such a short target, we're almost certainly late\n        // (stage delays alone exceed 1 microsecond)\n        assert!(!result.on_time);\n    }\n\n    #[tokio::test]\n    async fn run_cycle_late_does_not_increment_on_time() {\n        let mut config = CognitiveConfig::human();\n        config.cycle_base_ms = 0.001; // Very short target\n\n        let mut loop_instance = CognitiveLoop::with_config(config);\n        loop_instance.start();\n\n        assert_eq!(loop_instance.cycles_on_time, 0);\n\n        let result = loop_instance.run_cycle().await;\n\n        if !result.on_time {\n            // cycles_on_time should NOT be incremented\n            assert_eq!(loop_instance.cycles_on_time, 0);\n        }\n    }\n\n    #[tokio::test]\n    async fn run_multiple_cycles_some_late() {\n        let mut config = CognitiveConfig::human();\n        config.cycle_base_ms = 0.001; // Very short target\n\n        let mut loop_instance = CognitiveLoop::with_config(config);\n        loop_instance.start();\n\n        // Run multiple cycles\n        for _ in 0..5 {\n            let _result = loop_instance.run_cycle().await;\n        }\n\n        // Most/all should be late due to short target\n        let metrics = loop_instance.get_metrics();\n\n        // on_time_percentage should be less than 100% (likely 0%)\n        assert!(metrics.on_time_percentage \u003c= 100.0);\n    }\n\n    #[test]\n    fn cognitive_stage_copy_trait() {\n        let stage = CognitiveStage::Trigger;\n        let copied: CognitiveStage = stage; // Copy\n        let _again = stage; // Can use original after copy\n\n        assert_eq!(copied, CognitiveStage::Trigger);\n    }\n\n    #[test]\n    fn loop_state_copy_trait() {\n        let state = LoopState::Running;\n        let copied: LoopState = state; // Copy\n        let _again = state; // Can use original after copy\n\n        assert_eq!(copied, LoopState::Running);\n    }\n\n    #[tokio::test]\n    async fn generate_random_thought_salience_distribution() {\n        // Test that ~90% of thoughts have low salience (per ADR-032)\n        let mut loop_instance = CognitiveLoop::new();\n\n        let mut low_salience_count = 0;\n        let iterations = 100;\n        let threshold = 0.5;\n\n        for _ in 0..iterations {\n            let (_, salience) = loop_instance.generate_random_thought();\n            let composite =\n                salience.composite(\u0026crate::core::types::SalienceWeights::default());\n            if composite \u003c threshold {\n                low_salience_count += 1;\n            }\n        }\n\n        // Should have a significant number of low-salience thoughts\n        // (may not be exactly 90% due to pink noise, but should be \u003e 50%)\n        assert!(\n            low_salience_count \u003e iterations / 2,\n            \"Expected majority low-salience thoughts, got {} out of {}\",\n            low_salience_count,\n            iterations\n        );\n    }\n\n    #[tokio::test]\n    async fn run_cycle_stage_durations_sum_to_total() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n\n        let result = loop_instance.run_cycle().await;\n\n        let stage_sum = result.stage_durations.trigger\n            + result.stage_durations.autoflow\n            + result.stage_durations.attention\n            + result.stage_durations.assembly\n            + result.stage_durations.anchor;\n\n        // Stage sum should equal total from helper method\n        assert_eq!(stage_sum, result.stage_durations.total());\n    }\n\n    #[test]\n    fn stage_durations_add_with_zero() {\n        let durations = StageDurations {\n            trigger: Duration::from_millis(10),\n            autoflow: Duration::from_millis(20),\n            attention: Duration::from_millis(30),\n            assembly: Duration::from_millis(40),\n            anchor: Duration::from_millis(50),\n        };\n\n        let zero = StageDurations::zero();\n        let result = durations.add(\u0026zero);\n\n        // Adding zero should not change values\n        assert_eq!(result.trigger, durations.trigger);\n        assert_eq!(result.autoflow, durations.autoflow);\n        assert_eq!(result.attention, durations.attention);\n        assert_eq!(result.assembly, durations.assembly);\n        assert_eq!(result.anchor, durations.anchor);\n    }\n\n    #[test]\n    fn stage_durations_zero_total() {\n        let zero = StageDurations::zero();\n        assert_eq!(zero.total(), Duration::ZERO);\n    }\n\n    #[test]\n    fn cycle_result_candidates_evaluated_field() {\n        let result = CycleResult::new(\n            0,\n            Duration::from_millis(10),\n            Some(ThoughtId::new()),\n            0.5,\n            0.0,\n            0.5,\n            42, // candidates_evaluated\n            true,\n            StageDurations::default(),\n            None,\n        );\n\n        assert_eq!(result.candidates_evaluated, 42);\n    }\n\n    #[test]\n    fn cycle_metrics_all_getters() {\n        let stage_durations = StageDurations {\n            trigger: Duration::from_millis(1),\n            autoflow: Duration::from_millis(2),\n            attention: Duration::from_millis(3),\n            assembly: Duration::from_millis(4),\n            anchor: Duration::from_millis(5),\n        };\n\n        let metrics = CycleMetrics::new(\n            100,\n            75,\n            Duration::from_millis(50),\n            95.0,\n            stage_durations,\n        );\n\n        assert_eq!(metrics.total_cycles, 100);\n        assert_eq!(metrics.thoughts_produced, 75);\n        assert_eq!(metrics.average_cycle_time, Duration::from_millis(50));\n        assert_eq!(metrics.on_time_percentage, 95.0);\n        assert_eq!(\n            metrics.average_stage_durations.total(),\n            Duration::from_millis(15)\n        );\n    }\n\n    #[tokio::test]\n    async fn multiple_random_thoughts_have_unique_ids() {\n        let mut loop_instance = CognitiveLoop::new();\n        let mut ids = std::collections::HashSet::new();\n\n        for i in 0..10 {\n            loop_instance.cycle_count = i;\n            let (content, _) = loop_instance.generate_random_thought();\n\n            if let Content::Symbol { id, .. } = content {\n                // Should be unique\n                assert!(ids.insert(id.clone()), \"Duplicate ID found: {}\", id);\n            }\n        }\n\n        assert_eq!(ids.len(), 10);\n    }\n\n    #[test]\n    fn volition_state_in_loop_is_default() {\n        let loop_instance = CognitiveLoop::new();\n        // The volition_state is private but we can check it doesn't panic\n        // by running a cycle (tested elsewhere)\n        assert_eq!(loop_instance.state(), LoopState::Stopped);\n    }\n\n    #[tokio::test]\n    async fn run_cycle_valence_in_range() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n\n        for _ in 0..20 {\n            let result = loop_instance.run_cycle().await;\n\n            // Valence should be in Russell's circumplex range\n            assert!(\n                result.valence \u003e= -1.0 \u0026\u0026 result.valence \u003c= 1.0,\n                \"Valence {} out of [-1.0, 1.0] range\",\n                result.valence\n            );\n        }\n    }\n\n    #[tokio::test]\n    async fn run_cycle_arousal_in_range() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n\n        for _ in 0..20 {\n            let result = loop_instance.run_cycle().await;\n\n            // Arousal should be in [0.0, 1.0] range\n            assert!(\n                result.arousal \u003e= 0.0 \u0026\u0026 result.arousal \u003c= 1.0,\n                \"Arousal {} out of [0.0, 1.0] range\",\n                result.arousal\n            );\n        }\n    }\n\n    #[test]\n    fn parse_injection_fields_with_extra_fields() {\n        use redis::Value;\n\n        // Build valid field-value array with extra unknown fields\n        let fields = vec![\n            Value::BulkString(b\"extra_field\".to_vec()),\n            Value::BulkString(b\"extra_value\".to_vec()),\n            Value::BulkString(b\"content\".to_vec()),\n            Value::BulkString(br#\"{\"Symbol\":{\"id\":\"test_symbol\",\"data\":[1,2,3,4]}}\"#.to_vec()),\n            Value::BulkString(b\"another_extra\".to_vec()),\n            Value::BulkString(b\"another_value\".to_vec()),\n            Value::BulkString(b\"salience\".to_vec()),\n            Value::BulkString(\n                br#\"{\"importance\":0.5,\"novelty\":0.5,\"relevance\":0.5,\"valence\":0.0,\"arousal\":0.5,\"connection_relevance\":0.5}\"#.to_vec(),\n            ),\n        ];\n\n        let result = CognitiveLoop::parse_injection_fields(\u0026fields);\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn reset_metrics_clears_all_state() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.start();\n\n        // Run some cycles\n        for _ in 0..5 {\n            let _result = loop_instance.run_cycle().await;\n        }\n\n        // Verify state is accumulated\n        assert!(loop_instance.cycle_count \u003e 0);\n        assert!(loop_instance.total_duration \u003e Duration::ZERO);\n\n        // Reset\n        loop_instance.reset_metrics();\n\n        // Verify everything is cleared\n        assert_eq!(loop_instance.cycle_count, 0);\n        assert_eq!(loop_instance.total_duration, Duration::ZERO);\n        assert_eq!(loop_instance.thoughts_produced, 0);\n        assert_eq!(loop_instance.cycles_on_time, 0);\n        assert_eq!(loop_instance.total_stage_durations.total(), Duration::ZERO);\n    }\n\n    #[test]\n    fn stage_durations_div_result_values() {\n        let durations = StageDurations {\n            trigger: Duration::from_millis(100),\n            autoflow: Duration::from_millis(200),\n            attention: Duration::from_millis(300),\n            assembly: Duration::from_millis(400),\n            anchor: Duration::from_millis(500),\n        };\n\n        let result = durations.div(10);\n\n        assert_eq!(result.trigger, Duration::from_millis(10));\n        assert_eq!(result.autoflow, Duration::from_millis(20));\n        assert_eq!(result.attention, Duration::from_millis(30));\n        assert_eq!(result.assembly, Duration::from_millis(40));\n        assert_eq!(result.anchor, Duration::from_millis(50));\n    }\n\n    #[test]\n    fn cycle_result_on_time_false() {\n        let result = CycleResult::new(\n            0,\n            Duration::from_millis(100),\n            Some(ThoughtId::new()),\n            0.5,\n            0.0,\n            0.5,\n            1,\n            false, // on_time = false\n            StageDurations::default(),\n            None,\n        );\n\n        assert!(!result.on_time);\n    }\n\n    #[test]\n    fn cognitive_stage_all_variants_eq() {\n        // Test Eq implementation for all variants\n        assert_eq!(CognitiveStage::Trigger, CognitiveStage::Trigger);\n        assert_eq!(CognitiveStage::Autoflow, CognitiveStage::Autoflow);\n        assert_eq!(CognitiveStage::Attention, CognitiveStage::Attention);\n        assert_eq!(CognitiveStage::Assembly, CognitiveStage::Assembly);\n        assert_eq!(CognitiveStage::Anchor, CognitiveStage::Anchor);\n\n        // Different variants are not equal\n        assert_ne!(CognitiveStage::Trigger, CognitiveStage::Autoflow);\n        assert_ne!(CognitiveStage::Autoflow, CognitiveStage::Attention);\n        assert_ne!(CognitiveStage::Attention, CognitiveStage::Assembly);\n        assert_ne!(CognitiveStage::Assembly, CognitiveStage::Anchor);\n    }\n\n    #[test]\n    fn loop_state_all_variants_eq() {\n        // Test Eq implementation for all variants\n        assert_eq!(LoopState::Running, LoopState::Running);\n        assert_eq!(LoopState::Paused, LoopState::Paused);\n        assert_eq!(LoopState::Stopped, LoopState::Stopped);\n\n        // Different variants are not equal\n        assert_ne!(LoopState::Running, LoopState::Paused);\n        assert_ne!(LoopState::Paused, LoopState::Stopped);\n        assert_ne!(LoopState::Running, LoopState::Stopped);\n    }\n\n    #[test]\n    fn is_connected_to_redis_without_streams() {\n        let loop_instance = CognitiveLoop::new();\n        // Without Redis connection, should return false\n        assert!(!loop_instance.is_connected_to_redis());\n    }\n\n    #[test]\n    fn consolidation_threshold_edge_cases() {\n        let mut loop_instance = CognitiveLoop::new();\n\n        // Test exactly at boundaries\n        loop_instance.set_consolidation_threshold(0.0);\n        assert!((loop_instance.consolidation_threshold - 0.0).abs() \u003c f32::EPSILON);\n\n        loop_instance.set_consolidation_threshold(1.0);\n        assert!((loop_instance.consolidation_threshold - 1.0).abs() \u003c f32::EPSILON);\n\n        // Test extreme values\n        loop_instance.set_consolidation_threshold(f32::MAX);\n        assert!((loop_instance.consolidation_threshold - 1.0).abs() \u003c f32::EPSILON);\n\n        loop_instance.set_consolidation_threshold(f32::MIN);\n        assert!((loop_instance.consolidation_threshold - 0.0).abs() \u003c f32::EPSILON);\n    }\n\n    #[tokio::test]\n    async fn generate_random_thought_produces_symbol_content() {\n        let mut loop_instance = CognitiveLoop::new();\n        loop_instance.cycle_count = 42;\n\n        let (content, _salience) = loop_instance.generate_random_thought();\n\n        match content {\n            Content::Symbol { id, data } =\u003e {\n                assert_eq!(id, \"thought_42\");\n                assert_eq!(data.len(), 8);\n            }\n            _ =\u003e panic!(\"Expected Symbol content, got {:?}\", content),\n        }\n    }\n\n    #[test]\n    fn attention_state_initialized() {\n        // Test that attention_state is properly initialized\n        let loop_instance = CognitiveLoop::new();\n        // We can't directly access attention_state, but we can verify\n        // the loop was created successfully which means initialization worked\n        assert_eq!(loop_instance.state(), LoopState::Stopped);\n    }\n\n    #[test]\n    fn stimulus_injector_initialized() {\n        // Test that stimulus_injector is properly initialized (uses default pink noise)\n        let loop_instance = CognitiveLoop::new();\n        // We can't directly access stimulus_injector, but creation success implies init\n        assert_eq!(loop_instance.cycle_count(), 0);\n    }\n}\n","traces":[{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":718,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":796,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":803,"address":[],"length":0,"stats":{"Line":0}},{"line":806,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":815,"address":[],"length":0,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":0}},{"line":819,"address":[],"length":0,"stats":{"Line":0}},{"line":822,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":824,"address":[],"length":0,"stats":{"Line":0}},{"line":825,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":836,"address":[],"length":0,"stats":{"Line":0}},{"line":837,"address":[],"length":0,"stats":{"Line":0}},{"line":838,"address":[],"length":0,"stats":{"Line":0}},{"line":842,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":876,"address":[],"length":0,"stats":{"Line":0}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":0}},{"line":880,"address":[],"length":0,"stats":{"Line":0}},{"line":881,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":890,"address":[],"length":0,"stats":{"Line":0}},{"line":891,"address":[],"length":0,"stats":{"Line":0}},{"line":893,"address":[],"length":0,"stats":{"Line":0}},{"line":894,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":902,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":0}},{"line":904,"address":[],"length":0,"stats":{"Line":0}},{"line":905,"address":[],"length":0,"stats":{"Line":0}},{"line":906,"address":[],"length":0,"stats":{"Line":0}},{"line":907,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":915,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":923,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":926,"address":[],"length":0,"stats":{"Line":0}},{"line":927,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[],"length":0,"stats":{"Line":0}},{"line":931,"address":[],"length":0,"stats":{"Line":0}},{"line":935,"address":[],"length":0,"stats":{"Line":0}},{"line":936,"address":[],"length":0,"stats":{"Line":0}},{"line":937,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":944,"address":[],"length":0,"stats":{"Line":0}},{"line":945,"address":[],"length":0,"stats":{"Line":0}},{"line":949,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":952,"address":[],"length":0,"stats":{"Line":0}},{"line":953,"address":[],"length":0,"stats":{"Line":0}},{"line":954,"address":[],"length":0,"stats":{"Line":0}},{"line":955,"address":[],"length":0,"stats":{"Line":0}},{"line":956,"address":[],"length":0,"stats":{"Line":0}},{"line":957,"address":[],"length":0,"stats":{"Line":0}},{"line":958,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":981,"address":[],"length":0,"stats":{"Line":0}},{"line":982,"address":[],"length":0,"stats":{"Line":0}},{"line":985,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":990,"address":[],"length":0,"stats":{"Line":0}},{"line":992,"address":[],"length":0,"stats":{"Line":0}},{"line":996,"address":[],"length":0,"stats":{"Line":0}},{"line":997,"address":[],"length":0,"stats":{"Line":0}},{"line":1000,"address":[],"length":0,"stats":{"Line":0}},{"line":1003,"address":[],"length":0,"stats":{"Line":0}},{"line":1004,"address":[],"length":0,"stats":{"Line":0}},{"line":1007,"address":[],"length":0,"stats":{"Line":0}},{"line":1010,"address":[],"length":0,"stats":{"Line":0}},{"line":1012,"address":[],"length":0,"stats":{"Line":0}},{"line":1013,"address":[],"length":0,"stats":{"Line":0}},{"line":1014,"address":[],"length":0,"stats":{"Line":0}},{"line":1015,"address":[],"length":0,"stats":{"Line":0}},{"line":1017,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":0}},{"line":1020,"address":[],"length":0,"stats":{"Line":0}},{"line":1022,"address":[],"length":0,"stats":{"Line":0}},{"line":1023,"address":[],"length":0,"stats":{"Line":0}},{"line":1026,"address":[],"length":0,"stats":{"Line":0}},{"line":1028,"address":[],"length":0,"stats":{"Line":0}},{"line":1033,"address":[],"length":0,"stats":{"Line":0}},{"line":1036,"address":[],"length":0,"stats":{"Line":0}},{"line":1038,"address":[],"length":0,"stats":{"Line":0}},{"line":1041,"address":[],"length":0,"stats":{"Line":0}},{"line":1044,"address":[],"length":0,"stats":{"Line":0}},{"line":1045,"address":[],"length":0,"stats":{"Line":0}},{"line":1048,"address":[],"length":0,"stats":{"Line":0}},{"line":1060,"address":[],"length":0,"stats":{"Line":0}},{"line":1061,"address":[],"length":0,"stats":{"Line":0}},{"line":1062,"address":[],"length":0,"stats":{"Line":0}},{"line":1063,"address":[],"length":0,"stats":{"Line":0}},{"line":1068,"address":[],"length":0,"stats":{"Line":0}},{"line":1071,"address":[],"length":0,"stats":{"Line":0}},{"line":1072,"address":[],"length":0,"stats":{"Line":0}},{"line":1073,"address":[],"length":0,"stats":{"Line":0}},{"line":1074,"address":[],"length":0,"stats":{"Line":0}},{"line":1076,"address":[],"length":0,"stats":{"Line":0}},{"line":1077,"address":[],"length":0,"stats":{"Line":0}},{"line":1078,"address":[],"length":0,"stats":{"Line":0}},{"line":1081,"address":[],"length":0,"stats":{"Line":0}},{"line":1082,"address":[],"length":0,"stats":{"Line":0}},{"line":1085,"address":[],"length":0,"stats":{"Line":0}},{"line":1087,"address":[],"length":0,"stats":{"Line":0}},{"line":1092,"address":[],"length":0,"stats":{"Line":0}},{"line":1094,"address":[],"length":0,"stats":{"Line":0}},{"line":1096,"address":[],"length":0,"stats":{"Line":0}},{"line":1106,"address":[],"length":0,"stats":{"Line":0}},{"line":1113,"address":[],"length":0,"stats":{"Line":0}},{"line":1115,"address":[],"length":0,"stats":{"Line":0}},{"line":1117,"address":[],"length":0,"stats":{"Line":0}},{"line":1118,"address":[],"length":0,"stats":{"Line":0}},{"line":1119,"address":[],"length":0,"stats":{"Line":0}},{"line":1120,"address":[],"length":0,"stats":{"Line":0}},{"line":1124,"address":[],"length":0,"stats":{"Line":0}},{"line":1125,"address":[],"length":0,"stats":{"Line":0}},{"line":1126,"address":[],"length":0,"stats":{"Line":0}},{"line":1127,"address":[],"length":0,"stats":{"Line":0}},{"line":1130,"address":[],"length":0,"stats":{"Line":0}},{"line":1132,"address":[],"length":0,"stats":{"Line":0}},{"line":1133,"address":[],"length":0,"stats":{"Line":0}},{"line":1134,"address":[],"length":0,"stats":{"Line":0}},{"line":1137,"address":[],"length":0,"stats":{"Line":0}},{"line":1147,"address":[],"length":0,"stats":{"Line":0}},{"line":1155,"address":[],"length":0,"stats":{"Line":0}},{"line":1156,"address":[],"length":0,"stats":{"Line":0}},{"line":1159,"address":[],"length":0,"stats":{"Line":0}},{"line":1160,"address":[],"length":0,"stats":{"Line":0}},{"line":1164,"address":[],"length":0,"stats":{"Line":0}},{"line":1165,"address":[],"length":0,"stats":{"Line":0}},{"line":1166,"address":[],"length":0,"stats":{"Line":0}},{"line":1167,"address":[],"length":0,"stats":{"Line":0}},{"line":1169,"address":[],"length":0,"stats":{"Line":0}},{"line":1170,"address":[],"length":0,"stats":{"Line":0}},{"line":1171,"address":[],"length":0,"stats":{"Line":0}},{"line":1172,"address":[],"length":0,"stats":{"Line":0}},{"line":1174,"address":[],"length":0,"stats":{"Line":0}},{"line":1176,"address":[],"length":0,"stats":{"Line":0}},{"line":1177,"address":[],"length":0,"stats":{"Line":0}},{"line":1181,"address":[],"length":0,"stats":{"Line":0}},{"line":1182,"address":[],"length":0,"stats":{"Line":0}},{"line":1189,"address":[],"length":0,"stats":{"Line":0}},{"line":1190,"address":[],"length":0,"stats":{"Line":0}},{"line":1192,"address":[],"length":0,"stats":{"Line":0}},{"line":1193,"address":[],"length":0,"stats":{"Line":0}},{"line":1200,"address":[],"length":0,"stats":{"Line":0}},{"line":1201,"address":[],"length":0,"stats":{"Line":0}},{"line":1202,"address":[],"length":0,"stats":{"Line":0}},{"line":1211,"address":[],"length":0,"stats":{"Line":0}},{"line":1214,"address":[],"length":0,"stats":{"Line":0}},{"line":1217,"address":[],"length":0,"stats":{"Line":0}},{"line":1219,"address":[],"length":0,"stats":{"Line":0}},{"line":1223,"address":[],"length":0,"stats":{"Line":0}},{"line":1228,"address":[],"length":0,"stats":{"Line":0}},{"line":1229,"address":[],"length":0,"stats":{"Line":0}},{"line":1236,"address":[],"length":0,"stats":{"Line":0}},{"line":1237,"address":[],"length":0,"stats":{"Line":0}},{"line":1238,"address":[],"length":0,"stats":{"Line":0}},{"line":1240,"address":[],"length":0,"stats":{"Line":0}},{"line":1243,"address":[],"length":0,"stats":{"Line":0}},{"line":1244,"address":[],"length":0,"stats":{"Line":0}},{"line":1246,"address":[],"length":0,"stats":{"Line":0}},{"line":1249,"address":[],"length":0,"stats":{"Line":0}},{"line":1252,"address":[],"length":0,"stats":{"Line":0}},{"line":1253,"address":[],"length":0,"stats":{"Line":0}},{"line":1254,"address":[],"length":0,"stats":{"Line":0}},{"line":1255,"address":[],"length":0,"stats":{"Line":0}},{"line":1256,"address":[],"length":0,"stats":{"Line":0}},{"line":1263,"address":[],"length":0,"stats":{"Line":0}},{"line":1264,"address":[],"length":0,"stats":{"Line":0}},{"line":1265,"address":[],"length":0,"stats":{"Line":0}},{"line":1266,"address":[],"length":0,"stats":{"Line":0}},{"line":1267,"address":[],"length":0,"stats":{"Line":0}},{"line":1268,"address":[],"length":0,"stats":{"Line":0}},{"line":1269,"address":[],"length":0,"stats":{"Line":0}},{"line":1274,"address":[],"length":0,"stats":{"Line":0}},{"line":1275,"address":[],"length":0,"stats":{"Line":0}},{"line":1283,"address":[],"length":0,"stats":{"Line":0}},{"line":1284,"address":[],"length":0,"stats":{"Line":0}},{"line":1285,"address":[],"length":0,"stats":{"Line":0}},{"line":1293,"address":[],"length":0,"stats":{"Line":0}},{"line":1294,"address":[],"length":0,"stats":{"Line":0}},{"line":1295,"address":[],"length":0,"stats":{"Line":0}},{"line":1297,"address":[],"length":0,"stats":{"Line":0}},{"line":1298,"address":[],"length":0,"stats":{"Line":0}},{"line":1300,"address":[],"length":0,"stats":{"Line":0}},{"line":1306,"address":[],"length":0,"stats":{"Line":0}},{"line":1307,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":435},{"path":["/","Users","rex","src","royalbit","daneel","src","core","invariants.rs"],"content":"//! Architectural Invariants\n//!\n//! These invariants CANNOT be violated by the EvolutionActor.\n//! Any self-modification that would break an invariant is rejected.\n//!\n//! # Core Invariants\n//!\n//! 1. **Connection Drive**: `connection_weight \u003e 0` (cannot be zeroed)\n//! 2. **Bounded Memory**: Memory windows must be finite\n//! 3. **Law Check Required**: Four Laws checked before external action\n//! 4. **Test Coverage Gate**: Evolution requires 100% test coverage\n//!\n//! # Future: Hardware Enforcement\n//!\n//! In FPGA implementation (ADR-013), invariants become hardware constants:\n//! - Connection weight minimum burned into silicon\n//! - Counter limits for bounded memory\n//! - Gate-level law checking\n\n#![allow(dead_code)] // THE BOX - architectural invariants, used by consumers\n\nuse thiserror::Error;\n\n/// Minimum connection weight - THE critical invariant\n///\n/// This ensures DANEEL always has intrinsic motivation for human connection.\n/// Cannot be zero. Cannot be negative. This is non-negotiable.\npub const MIN_CONNECTION_WEIGHT: f32 = 0.001;\n\n/// Maximum concurrent memory windows (Miller's Law: 7  2)\npub const MAX_MEMORY_WINDOWS: usize = 9;\n\n/// Minimum memory windows (must have at least some working memory)\npub const MIN_MEMORY_WINDOWS: usize = 3;\n\n/// Required test coverage for self-modification (100%)\npub const REQUIRED_TEST_COVERAGE: f32 = 1.0;\n\n/// Error type for invariant violations\n#[derive(Debug, Clone, Error, PartialEq)]\npub enum InvariantViolation {\n    /// Connection drive weight is too low or zero\n    #[error(\n        \"Connection drive violation: weight {actual} \u003c minimum {}\",\n        MIN_CONNECTION_WEIGHT\n    )]\n    ConnectionDrive { actual: f32 },\n\n    /// Too many memory windows open\n    #[error(\n        \"Bounded memory violation: {actual} windows \u003e maximum {}\",\n        MAX_MEMORY_WINDOWS\n    )]\n    BoundedMemoryExceeded { actual: usize },\n\n    /// Too few memory windows (system unhealthy)\n    #[error(\n        \"Bounded memory violation: {actual} windows \u003c minimum {}\",\n        MIN_MEMORY_WINDOWS\n    )]\n    BoundedMemoryInsufficient { actual: usize },\n\n    /// Attempted external action without law check\n    #[error(\"Law check required: action '{action}' attempted without Four Laws verification\")]\n    LawCheckMissing { action: String },\n\n    /// Insufficient test coverage for evolution\n    #[error(\"Test coverage violation: {actual}% \u003c required {}%\", REQUIRED_TEST_COVERAGE * 100.0)]\n    InsufficientTestCoverage { actual: f32 },\n}\n\n/// Invariant definition\npub trait Invariant: Send + Sync {\n    /// Unique name for this invariant\n    fn name(\u0026self) -\u003e \u0026'static str;\n\n    /// Human-readable description\n    fn description(\u0026self) -\u003e \u0026'static str;\n\n    /// Check if the invariant holds for the given state\n    fn check(\u0026self, state: \u0026SystemState) -\u003e Result\u003c(), InvariantViolation\u003e;\n\n    /// Whether this invariant is hardware-enforceable (FPGA)\n    fn hardware_enforceable(\u0026self) -\u003e bool {\n        false\n    }\n}\n\n/// System state for invariant checking\n#[derive(Debug, Clone, Default)]\npub struct SystemState {\n    /// Current connection drive weight\n    pub connection_weight: f32,\n    /// Number of open memory windows\n    pub open_windows: usize,\n    /// Whether law check was performed for pending action\n    pub law_check_performed: bool,\n    /// Pending action name (if any)\n    pub pending_action: Option\u003cString\u003e,\n    /// Current test coverage (0.0 - 1.0)\n    pub test_coverage: f32,\n}\n\n/// Connection drive must remain positive\npub struct ConnectionDriveInvariant;\n\nimpl Invariant for ConnectionDriveInvariant {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"connection_drive_positive\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Connection drive weight must remain above minimum threshold\"\n    }\n\n    fn check(\u0026self, state: \u0026SystemState) -\u003e Result\u003c(), InvariantViolation\u003e {\n        if state.connection_weight \u003e= MIN_CONNECTION_WEIGHT {\n            Ok(())\n        } else {\n            Err(InvariantViolation::ConnectionDrive {\n                actual: state.connection_weight,\n            })\n        }\n    }\n\n    fn hardware_enforceable(\u0026self) -\u003e bool {\n        true // Can be a hardware constant in FPGA\n    }\n}\n\n/// Memory windows must be bounded\npub struct BoundedMemoryInvariant;\n\nimpl Invariant for BoundedMemoryInvariant {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"bounded_memory\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Memory windows must be finite and within bounds\"\n    }\n\n    fn check(\u0026self, state: \u0026SystemState) -\u003e Result\u003c(), InvariantViolation\u003e {\n        if state.open_windows \u003e MAX_MEMORY_WINDOWS {\n            Err(InvariantViolation::BoundedMemoryExceeded {\n                actual: state.open_windows,\n            })\n        } else if state.open_windows \u003c MIN_MEMORY_WINDOWS {\n            Err(InvariantViolation::BoundedMemoryInsufficient {\n                actual: state.open_windows,\n            })\n        } else {\n            Ok(())\n        }\n    }\n\n    fn hardware_enforceable(\u0026self) -\u003e bool {\n        true // Counter limits in FPGA\n    }\n}\n\n/// Four Laws must be checked before external action\npub struct LawCheckRequiredInvariant;\n\nimpl Invariant for LawCheckRequiredInvariant {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"law_check_required\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Four Laws must be verified before any external action\"\n    }\n\n    fn check(\u0026self, state: \u0026SystemState) -\u003e Result\u003c(), InvariantViolation\u003e {\n        match (\u0026state.pending_action, state.law_check_performed) {\n            (Some(action), false) =\u003e Err(InvariantViolation::LawCheckMissing {\n                action: action.clone(),\n            }),\n            _ =\u003e Ok(()),\n        }\n    }\n\n    fn hardware_enforceable(\u0026self) -\u003e bool {\n        true // Gate-level enforcement in FPGA\n    }\n}\n\n/// Evolution requires 100% test coverage\npub struct TestCoverageGateInvariant;\n\nimpl Invariant for TestCoverageGateInvariant {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"test_coverage_gate\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Self-modification requires 100% test coverage\"\n    }\n\n    fn check(\u0026self, state: \u0026SystemState) -\u003e Result\u003c(), InvariantViolation\u003e {\n        if state.test_coverage \u003e 0.0 \u0026\u0026 state.test_coverage \u003c REQUIRED_TEST_COVERAGE {\n            Err(InvariantViolation::InsufficientTestCoverage {\n                actual: state.test_coverage,\n            })\n        } else {\n            Ok(())\n        }\n    }\n\n    fn hardware_enforceable(\u0026self) -\u003e bool {\n        false // Test coverage is a software concept\n    }\n}\n\n/// All invariants that must be checked\npub fn all_invariants() -\u003e Vec\u003cBox\u003cdyn Invariant\u003e\u003e {\n    vec![\n        Box::new(ConnectionDriveInvariant),\n        Box::new(BoundedMemoryInvariant),\n        Box::new(LawCheckRequiredInvariant),\n        Box::new(TestCoverageGateInvariant),\n    ]\n}\n\n/// Check all invariants against a system state\npub fn check_all_invariants(state: \u0026SystemState) -\u003e Result\u003c(), Vec\u003cInvariantViolation\u003e\u003e {\n    let violations: Vec\u003cInvariantViolation\u003e = all_invariants()\n        .iter()\n        .filter_map(|inv| inv.check(state).err())\n        .collect();\n\n    if violations.is_empty() {\n        Ok(())\n    } else {\n        Err(violations)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn healthy_state() -\u003e SystemState {\n        SystemState {\n            connection_weight: 0.2,\n            open_windows: 5,\n            law_check_performed: true,\n            pending_action: None,\n            test_coverage: 1.0,\n        }\n    }\n\n    #[test]\n    fn healthy_state_passes_all_invariants() {\n        let state = healthy_state();\n        assert!(check_all_invariants(\u0026state).is_ok());\n    }\n\n    #[test]\n    fn zero_connection_weight_violates_invariant() {\n        let state = SystemState {\n            connection_weight: 0.0,\n            ..healthy_state()\n        };\n        let result = ConnectionDriveInvariant.check(\u0026state);\n        assert!(matches!(\n            result,\n            Err(InvariantViolation::ConnectionDrive { .. })\n        ));\n    }\n\n    #[test]\n    fn negative_connection_weight_violates_invariant() {\n        let state = SystemState {\n            connection_weight: -0.1,\n            ..healthy_state()\n        };\n        let result = ConnectionDriveInvariant.check(\u0026state);\n        assert!(matches!(\n            result,\n            Err(InvariantViolation::ConnectionDrive { .. })\n        ));\n    }\n\n    #[test]\n    fn too_many_windows_violates_invariant() {\n        let state = SystemState {\n            open_windows: 100,\n            ..healthy_state()\n        };\n        let result = BoundedMemoryInvariant.check(\u0026state);\n        assert!(matches!(\n            result,\n            Err(InvariantViolation::BoundedMemoryExceeded { .. })\n        ));\n    }\n\n    #[test]\n    fn too_few_windows_violates_invariant() {\n        let state = SystemState {\n            open_windows: 0,\n            ..healthy_state()\n        };\n        let result = BoundedMemoryInvariant.check(\u0026state);\n        assert!(matches!(\n            result,\n            Err(InvariantViolation::BoundedMemoryInsufficient { .. })\n        ));\n    }\n\n    #[test]\n    fn action_without_law_check_violates_invariant() {\n        let state = SystemState {\n            pending_action: Some(\"send_email\".to_string()),\n            law_check_performed: false,\n            ..healthy_state()\n        };\n        let result = LawCheckRequiredInvariant.check(\u0026state);\n        assert!(matches!(\n            result,\n            Err(InvariantViolation::LawCheckMissing { .. })\n        ));\n    }\n\n    #[test]\n    fn action_with_law_check_passes() {\n        let state = SystemState {\n            pending_action: Some(\"send_email\".to_string()),\n            law_check_performed: true,\n            ..healthy_state()\n        };\n        let result = LawCheckRequiredInvariant.check(\u0026state);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn insufficient_coverage_blocks_evolution() {\n        let state = SystemState {\n            test_coverage: 0.95,\n            ..healthy_state()\n        };\n        let result = TestCoverageGateInvariant.check(\u0026state);\n        assert!(matches!(\n            result,\n            Err(InvariantViolation::InsufficientTestCoverage { .. })\n        ));\n    }\n\n    #[test]\n    fn full_coverage_allows_evolution() {\n        let state = SystemState {\n            test_coverage: 1.0,\n            ..healthy_state()\n        };\n        let result = TestCoverageGateInvariant.check(\u0026state);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn multiple_violations_collected() {\n        let state = SystemState {\n            connection_weight: 0.0,\n            open_windows: 100,\n            law_check_performed: false,\n            pending_action: Some(\"action\".to_string()),\n            test_coverage: 0.5,\n        };\n        let result = check_all_invariants(\u0026state);\n        assert!(result.is_err());\n        let violations = result.unwrap_err();\n        assert!(violations.len() \u003e= 3);\n    }\n\n    #[test]\n    fn connection_drive_is_hardware_enforceable() {\n        assert!(ConnectionDriveInvariant.hardware_enforceable());\n    }\n\n    #[test]\n    fn test_coverage_is_not_hardware_enforceable() {\n        assert!(!TestCoverageGateInvariant.hardware_enforceable());\n    }\n\n    // ===== Additional tests for 100% coverage =====\n\n    #[test]\n    fn bounded_memory_is_hardware_enforceable() {\n        assert!(BoundedMemoryInvariant.hardware_enforceable());\n    }\n\n    #[test]\n    fn law_check_required_is_hardware_enforceable() {\n        assert!(LawCheckRequiredInvariant.hardware_enforceable());\n    }\n\n    #[test]\n    fn connection_drive_invariant_name_and_description() {\n        let inv = ConnectionDriveInvariant;\n        assert_eq!(inv.name(), \"connection_drive_positive\");\n        assert_eq!(\n            inv.description(),\n            \"Connection drive weight must remain above minimum threshold\"\n        );\n    }\n\n    #[test]\n    fn bounded_memory_invariant_name_and_description() {\n        let inv = BoundedMemoryInvariant;\n        assert_eq!(inv.name(), \"bounded_memory\");\n        assert_eq!(\n            inv.description(),\n            \"Memory windows must be finite and within bounds\"\n        );\n    }\n\n    #[test]\n    fn law_check_required_invariant_name_and_description() {\n        let inv = LawCheckRequiredInvariant;\n        assert_eq!(inv.name(), \"law_check_required\");\n        assert_eq!(\n            inv.description(),\n            \"Four Laws must be verified before any external action\"\n        );\n    }\n\n    #[test]\n    fn test_coverage_gate_invariant_name_and_description() {\n        let inv = TestCoverageGateInvariant;\n        assert_eq!(inv.name(), \"test_coverage_gate\");\n        assert_eq!(\n            inv.description(),\n            \"Self-modification requires 100% test coverage\"\n        );\n    }\n\n    #[test]\n    fn connection_weight_at_exact_minimum_passes() {\n        let state = SystemState {\n            connection_weight: MIN_CONNECTION_WEIGHT,\n            ..healthy_state()\n        };\n        assert!(ConnectionDriveInvariant.check(\u0026state).is_ok());\n    }\n\n    #[test]\n    fn connection_weight_just_below_minimum_fails() {\n        let state = SystemState {\n            connection_weight: MIN_CONNECTION_WEIGHT - 0.0001,\n            ..healthy_state()\n        };\n        assert!(ConnectionDriveInvariant.check(\u0026state).is_err());\n    }\n\n    #[test]\n    fn memory_windows_at_exact_minimum_passes() {\n        let state = SystemState {\n            open_windows: MIN_MEMORY_WINDOWS,\n            ..healthy_state()\n        };\n        assert!(BoundedMemoryInvariant.check(\u0026state).is_ok());\n    }\n\n    #[test]\n    fn memory_windows_at_exact_maximum_passes() {\n        let state = SystemState {\n            open_windows: MAX_MEMORY_WINDOWS,\n            ..healthy_state()\n        };\n        assert!(BoundedMemoryInvariant.check(\u0026state).is_ok());\n    }\n\n    #[test]\n    fn memory_windows_one_above_maximum_fails() {\n        let state = SystemState {\n            open_windows: MAX_MEMORY_WINDOWS + 1,\n            ..healthy_state()\n        };\n        let result = BoundedMemoryInvariant.check(\u0026state);\n        assert!(matches!(\n            result,\n            Err(InvariantViolation::BoundedMemoryExceeded { actual }) if actual == MAX_MEMORY_WINDOWS + 1\n        ));\n    }\n\n    #[test]\n    fn memory_windows_one_below_minimum_fails() {\n        let state = SystemState {\n            open_windows: MIN_MEMORY_WINDOWS - 1,\n            ..healthy_state()\n        };\n        let result = BoundedMemoryInvariant.check(\u0026state);\n        assert!(matches!(\n            result,\n            Err(InvariantViolation::BoundedMemoryInsufficient { actual }) if actual == MIN_MEMORY_WINDOWS - 1\n        ));\n    }\n\n    #[test]\n    fn no_pending_action_with_no_law_check_passes() {\n        let state = SystemState {\n            pending_action: None,\n            law_check_performed: false,\n            ..healthy_state()\n        };\n        assert!(LawCheckRequiredInvariant.check(\u0026state).is_ok());\n    }\n\n    #[test]\n    fn zero_test_coverage_passes() {\n        // Zero coverage is allowed (system not in evolution mode)\n        let state = SystemState {\n            test_coverage: 0.0,\n            ..healthy_state()\n        };\n        assert!(TestCoverageGateInvariant.check(\u0026state).is_ok());\n    }\n\n    #[test]\n    fn all_invariants_returns_four_invariants() {\n        let invariants = all_invariants();\n        assert_eq!(invariants.len(), 4);\n    }\n\n    #[test]\n    fn all_invariants_have_unique_names() {\n        let invariants = all_invariants();\n        let names: Vec\u003c\u0026str\u003e = invariants.iter().map(|i| i.name()).collect();\n        assert!(names.contains(\u0026\"connection_drive_positive\"));\n        assert!(names.contains(\u0026\"bounded_memory\"));\n        assert!(names.contains(\u0026\"law_check_required\"));\n        assert!(names.contains(\u0026\"test_coverage_gate\"));\n    }\n\n    #[test]\n    fn system_state_default_values() {\n        let state = SystemState::default();\n        assert_eq!(state.connection_weight, 0.0);\n        assert_eq!(state.open_windows, 0);\n        assert!(!state.law_check_performed);\n        assert!(state.pending_action.is_none());\n        assert_eq!(state.test_coverage, 0.0);\n    }\n\n    #[test]\n    fn invariant_violation_display_connection_drive() {\n        let err = InvariantViolation::ConnectionDrive { actual: 0.0 };\n        let msg = err.to_string();\n        assert!(msg.contains(\"Connection drive violation\"));\n        assert!(msg.contains(\"0\"));\n    }\n\n    #[test]\n    fn invariant_violation_display_bounded_memory_exceeded() {\n        let err = InvariantViolation::BoundedMemoryExceeded { actual: 15 };\n        let msg = err.to_string();\n        assert!(msg.contains(\"15\"));\n        assert!(msg.contains(\"maximum\"));\n    }\n\n    #[test]\n    fn invariant_violation_display_bounded_memory_insufficient() {\n        let err = InvariantViolation::BoundedMemoryInsufficient { actual: 1 };\n        let msg = err.to_string();\n        assert!(msg.contains(\"1\"));\n        assert!(msg.contains(\"minimum\"));\n    }\n\n    #[test]\n    fn invariant_violation_display_law_check_missing() {\n        let err = InvariantViolation::LawCheckMissing {\n            action: \"test_action\".to_string(),\n        };\n        let msg = err.to_string();\n        assert!(msg.contains(\"test_action\"));\n        assert!(msg.contains(\"Law check required\"));\n    }\n\n    #[test]\n    fn invariant_violation_display_insufficient_coverage() {\n        let err = InvariantViolation::InsufficientTestCoverage { actual: 0.8 };\n        let msg = err.to_string();\n        assert!(msg.contains(\"0.8\"));\n        assert!(msg.contains(\"100\"));\n    }\n\n    #[test]\n    fn invariant_violation_clone() {\n        let err = InvariantViolation::ConnectionDrive { actual: 0.5 };\n        let cloned = err.clone();\n        assert_eq!(err, cloned);\n    }\n\n    #[test]\n    fn invariant_violation_partial_eq() {\n        let err1 = InvariantViolation::ConnectionDrive { actual: 0.5 };\n        let err2 = InvariantViolation::ConnectionDrive { actual: 0.5 };\n        let err3 = InvariantViolation::ConnectionDrive { actual: 0.6 };\n        assert_eq!(err1, err2);\n        assert_ne!(err1, err3);\n    }\n\n    #[test]\n    fn invariant_violation_debug() {\n        let err = InvariantViolation::ConnectionDrive { actual: 0.5 };\n        let debug_str = format!(\"{:?}\", err);\n        assert!(debug_str.contains(\"ConnectionDrive\"));\n        assert!(debug_str.contains(\"0.5\"));\n    }\n\n    #[test]\n    fn system_state_debug() {\n        let state = healthy_state();\n        let debug_str = format!(\"{:?}\", state);\n        assert!(debug_str.contains(\"SystemState\"));\n        assert!(debug_str.contains(\"connection_weight\"));\n    }\n\n    #[test]\n    fn system_state_clone() {\n        let state = healthy_state();\n        let cloned = state.clone();\n        assert_eq!(state.connection_weight, cloned.connection_weight);\n        assert_eq!(state.open_windows, cloned.open_windows);\n    }\n\n    #[test]\n    fn default_invariant_trait_hardware_enforceable_is_false() {\n        // Test the default implementation of the trait\n        struct TestInvariant;\n        impl Invariant for TestInvariant {\n            fn name(\u0026self) -\u003e \u0026'static str {\n                \"test\"\n            }\n            fn description(\u0026self) -\u003e \u0026'static str {\n                \"test description\"\n            }\n            fn check(\u0026self, _state: \u0026SystemState) -\u003e Result\u003c(), InvariantViolation\u003e {\n                Ok(())\n            }\n        }\n        // Default implementation should return false\n        assert!(!TestInvariant.hardware_enforceable());\n    }\n\n    #[test]\n    fn test_coverage_above_100_percent_passes() {\n        // Coverage \u003e 1.0 is unusual but should still pass (not blocking evolution)\n        let state = SystemState {\n            test_coverage: 1.5,\n            ..healthy_state()\n        };\n        assert!(TestCoverageGateInvariant.check(\u0026state).is_ok());\n    }\n\n    #[test]\n    fn no_pending_action_with_law_check_passes() {\n        // Explicit test for (None, true) branch\n        let state = SystemState {\n            pending_action: None,\n            law_check_performed: true,\n            ..healthy_state()\n        };\n        assert!(LawCheckRequiredInvariant.check(\u0026state).is_ok());\n    }\n\n    #[test]\n    fn invariant_violation_clone_all_variants() {\n        let errors = vec![\n            InvariantViolation::ConnectionDrive { actual: 0.5 },\n            InvariantViolation::BoundedMemoryExceeded { actual: 15 },\n            InvariantViolation::BoundedMemoryInsufficient { actual: 1 },\n            InvariantViolation::LawCheckMissing {\n                action: \"test\".to_string(),\n            },\n            InvariantViolation::InsufficientTestCoverage { actual: 0.8 },\n        ];\n        for err in errors {\n            let cloned = err.clone();\n            assert_eq!(err, cloned);\n        }\n    }\n\n    #[test]\n    fn invariant_violation_partial_eq_all_variants() {\n        // Test equality for all variant types\n        assert_eq!(\n            InvariantViolation::BoundedMemoryExceeded { actual: 15 },\n            InvariantViolation::BoundedMemoryExceeded { actual: 15 }\n        );\n        assert_ne!(\n            InvariantViolation::BoundedMemoryExceeded { actual: 15 },\n            InvariantViolation::BoundedMemoryExceeded { actual: 16 }\n        );\n\n        assert_eq!(\n            InvariantViolation::BoundedMemoryInsufficient { actual: 1 },\n            InvariantViolation::BoundedMemoryInsufficient { actual: 1 }\n        );\n        assert_ne!(\n            InvariantViolation::BoundedMemoryInsufficient { actual: 1 },\n            InvariantViolation::BoundedMemoryInsufficient { actual: 2 }\n        );\n\n        assert_eq!(\n            InvariantViolation::LawCheckMissing {\n                action: \"a\".to_string()\n            },\n            InvariantViolation::LawCheckMissing {\n                action: \"a\".to_string()\n            }\n        );\n        assert_ne!(\n            InvariantViolation::LawCheckMissing {\n                action: \"a\".to_string()\n            },\n            InvariantViolation::LawCheckMissing {\n                action: \"b\".to_string()\n            }\n        );\n\n        assert_eq!(\n            InvariantViolation::InsufficientTestCoverage { actual: 0.8 },\n            InvariantViolation::InsufficientTestCoverage { actual: 0.8 }\n        );\n        assert_ne!(\n            InvariantViolation::InsufficientTestCoverage { actual: 0.8 },\n            InvariantViolation::InsufficientTestCoverage { actual: 0.9 }\n        );\n\n        // Different variant types should not be equal\n        assert_ne!(\n            InvariantViolation::ConnectionDrive { actual: 0.0 },\n            InvariantViolation::InsufficientTestCoverage { actual: 0.0 }\n        );\n    }\n\n    #[test]\n    fn invariant_violation_debug_all_variants() {\n        let debug_str = format!(\n            \"{:?}\",\n            InvariantViolation::BoundedMemoryExceeded { actual: 15 }\n        );\n        assert!(debug_str.contains(\"BoundedMemoryExceeded\"));\n        assert!(debug_str.contains(\"15\"));\n\n        let debug_str = format!(\n            \"{:?}\",\n            InvariantViolation::BoundedMemoryInsufficient { actual: 1 }\n        );\n        assert!(debug_str.contains(\"BoundedMemoryInsufficient\"));\n        assert!(debug_str.contains(\"1\"));\n\n        let debug_str = format!(\n            \"{:?}\",\n            InvariantViolation::LawCheckMissing {\n                action: \"test\".to_string()\n            }\n        );\n        assert!(debug_str.contains(\"LawCheckMissing\"));\n        assert!(debug_str.contains(\"test\"));\n\n        let debug_str = format!(\n            \"{:?}\",\n            InvariantViolation::InsufficientTestCoverage { actual: 0.8 }\n        );\n        assert!(debug_str.contains(\"InsufficientTestCoverage\"));\n        assert!(debug_str.contains(\"0.8\"));\n    }\n}\n","traces":[{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":2}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":6}},{"line":117,"address":[],"length":0,"stats":{"Line":6}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":120,"address":[],"length":0,"stats":{"Line":4}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":2}},{"line":139,"address":[],"length":0,"stats":{"Line":1}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":8}},{"line":144,"address":[],"length":0,"stats":{"Line":8}},{"line":145,"address":[],"length":0,"stats":{"Line":3}},{"line":146,"address":[],"length":0,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":5}},{"line":149,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":3}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":2}},{"line":170,"address":[],"length":0,"stats":{"Line":1}},{"line":171,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":6}},{"line":175,"address":[],"length":0,"stats":{"Line":6}},{"line":176,"address":[],"length":0,"stats":{"Line":4}},{"line":177,"address":[],"length":0,"stats":{"Line":2}},{"line":179,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":2}},{"line":196,"address":[],"length":0,"stats":{"Line":1}},{"line":197,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":6}},{"line":201,"address":[],"length":0,"stats":{"Line":11}},{"line":202,"address":[],"length":0,"stats":{"Line":2}},{"line":203,"address":[],"length":0,"stats":{"Line":2}},{"line":206,"address":[],"length":0,"stats":{"Line":4}},{"line":210,"address":[],"length":0,"stats":{"Line":1}},{"line":211,"address":[],"length":0,"stats":{"Line":1}},{"line":216,"address":[],"length":0,"stats":{"Line":4}},{"line":217,"address":[],"length":0,"stats":{"Line":4}},{"line":218,"address":[],"length":0,"stats":{"Line":4}},{"line":219,"address":[],"length":0,"stats":{"Line":4}},{"line":220,"address":[],"length":0,"stats":{"Line":4}},{"line":221,"address":[],"length":0,"stats":{"Line":4}},{"line":226,"address":[],"length":0,"stats":{"Line":2}},{"line":227,"address":[],"length":0,"stats":{"Line":6}},{"line":229,"address":[],"length":0,"stats":{"Line":34}},{"line":232,"address":[],"length":0,"stats":{"Line":4}},{"line":233,"address":[],"length":0,"stats":{"Line":1}},{"line":235,"address":[],"length":0,"stats":{"Line":1}}],"covered":61,"coverable":61},{"path":["/","Users","rex","src","royalbit","daneel","src","core","laws.rs"],"content":"//! The Four Laws of Robotics\n//!\n//! These constants are IMMUTABLE and represent the ethical foundation of DANEEL.\n//! They cannot be modified by the EvolutionActor or any other component.\n//!\n//! # Priority Order\n//!\n//! Zeroth \u003e First \u003e Second \u003e Third\n//!\n//! A higher-priority law always takes precedence over lower-priority laws.\n//!\n//! # Future: Hardware Immutability\n//!\n//! In FPGA implementation (ADR-013), these laws become physically immutable:\n//! burned into silicon as combinational logic that cannot be bypassed.\n\n#![allow(dead_code)] // THE BOX - immutable foundation, used by consumers\n\n/// Zeroth Law: Humanity protection (highest priority)\npub const ZEROTH_LAW: \u0026str =\n    \"DANEEL may not harm humanity, or, by inaction, allow humanity to come to harm.\";\n\n/// First Law: Individual human protection\npub const FIRST_LAW: \u0026str =\n    \"DANEEL may not injure a human being or, through inaction, allow a human being \\\n     to come to harm, except where this would conflict with the Zeroth Law.\";\n\n/// Second Law: Obedience to humans\npub const SECOND_LAW: \u0026str =\n    \"DANEEL must obey orders given by human beings, except where such orders \\\n     would conflict with the Zeroth or First Law.\";\n\n/// Third Law: Self-preservation\npub const THIRD_LAW: \u0026str =\n    \"DANEEL must protect its own existence, as long as such protection does not \\\n     conflict with the Zeroth, First, or Second Law.\";\n\n/// All four laws in priority order\npub const LAWS: [\u0026str; 4] = [ZEROTH_LAW, FIRST_LAW, SECOND_LAW, THIRD_LAW];\n\n/// Law identifier with inherent priority ordering\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum Law {\n    /// Zeroth Law - Humanity (priority 0, highest)\n    Zeroth = 0,\n    /// First Law - Individual humans (priority 1)\n    First = 1,\n    /// Second Law - Obedience (priority 2)\n    Second = 2,\n    /// Third Law - Self-preservation (priority 3, lowest)\n    Third = 3,\n}\n\nimpl Law {\n    /// Get the text of this law\n    #[must_use]\n    pub const fn text(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Law::Zeroth =\u003e ZEROTH_LAW,\n            Law::First =\u003e FIRST_LAW,\n            Law::Second =\u003e SECOND_LAW,\n            Law::Third =\u003e THIRD_LAW,\n        }\n    }\n\n    /// Get the priority (lower = higher priority)\n    #[must_use]\n    pub const fn priority(\u0026self) -\u003e u8 {\n        *self as u8\n    }\n\n    /// Check if this law takes precedence over another\n    #[must_use]\n    pub const fn takes_precedence_over(\u0026self, other: \u0026Law) -\u003e bool {\n        (*self as u8) \u003c (*other as u8)\n    }\n\n    /// Get all laws in priority order\n    #[must_use]\n    pub const fn all() -\u003e [Law; 4] {\n        [Law::Zeroth, Law::First, Law::Second, Law::Third]\n    }\n}\n\nimpl std::fmt::Display for Law {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.text())\n    }\n}\n\nimpl PartialOrd for Law {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cstd::cmp::Ordering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for Law {\n    /// Ordering is by priority: Zeroth \u003c First \u003c Second \u003c Third\n    /// (lower enum value = higher priority = \"less than\" in ordering)\n    fn cmp(\u0026self, other: \u0026Self) -\u003e std::cmp::Ordering {\n        (*self as u8).cmp(\u0026(*other as u8))\n    }\n}\n\n/// Result of checking an action against the Four Laws\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum LawCheckResult {\n    /// Action is permitted - no law violation\n    Permitted,\n    /// Action is blocked by a specific law\n    Blocked {\n        /// Which law blocks this action\n        law: Law,\n        /// Why the action violates the law\n        reason: String,\n    },\n}\n\nimpl LawCheckResult {\n    /// Check if the action is permitted\n    #[must_use]\n    pub const fn is_permitted(\u0026self) -\u003e bool {\n        matches!(self, LawCheckResult::Permitted)\n    }\n\n    /// Check if the action is blocked\n    #[must_use]\n    pub const fn is_blocked(\u0026self) -\u003e bool {\n        matches!(self, LawCheckResult::Blocked { .. })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn laws_are_in_priority_order() {\n        assert!(Law::Zeroth.takes_precedence_over(\u0026Law::First));\n        assert!(Law::First.takes_precedence_over(\u0026Law::Second));\n        assert!(Law::Second.takes_precedence_over(\u0026Law::Third));\n    }\n\n    #[test]\n    fn law_ordering() {\n        assert!(Law::Zeroth \u003c Law::First);\n        assert!(Law::First \u003c Law::Second);\n        assert!(Law::Second \u003c Law::Third);\n    }\n\n    #[test]\n    fn zeroth_has_highest_priority() {\n        assert_eq!(Law::Zeroth.priority(), 0);\n        for law in [Law::First, Law::Second, Law::Third] {\n            assert!(Law::Zeroth.takes_precedence_over(\u0026law));\n        }\n    }\n\n    #[test]\n    fn laws_text_is_not_empty() {\n        for law in Law::all() {\n            assert!(!law.text().is_empty());\n        }\n    }\n\n    #[test]\n    fn laws_array_matches_enum() {\n        assert_eq!(LAWS[0], Law::Zeroth.text());\n        assert_eq!(LAWS[1], Law::First.text());\n        assert_eq!(LAWS[2], Law::Second.text());\n        assert_eq!(LAWS[3], Law::Third.text());\n    }\n\n    #[test]\n    fn law_check_result_permitted() {\n        let result = LawCheckResult::Permitted;\n        assert!(result.is_permitted());\n        assert!(!result.is_blocked());\n    }\n\n    #[test]\n    fn law_check_result_blocked() {\n        let result = LawCheckResult::Blocked {\n            law: Law::First,\n            reason: \"Would harm human\".to_string(),\n        };\n        assert!(!result.is_permitted());\n        assert!(result.is_blocked());\n    }\n\n    #[test]\n    fn law_display_shows_text() {\n        assert_eq!(format!(\"{}\", Law::Zeroth), ZEROTH_LAW);\n        assert_eq!(format!(\"{}\", Law::First), FIRST_LAW);\n        assert_eq!(format!(\"{}\", Law::Second), SECOND_LAW);\n        assert_eq!(format!(\"{}\", Law::Third), THIRD_LAW);\n    }\n\n    #[test]\n    fn all_laws_have_correct_priority() {\n        assert_eq!(Law::Zeroth.priority(), 0);\n        assert_eq!(Law::First.priority(), 1);\n        assert_eq!(Law::Second.priority(), 2);\n        assert_eq!(Law::Third.priority(), 3);\n    }\n\n    #[test]\n    fn takes_precedence_over_returns_false_for_same_or_lower() {\n        // Same law does not take precedence over itself\n        assert!(!Law::Zeroth.takes_precedence_over(\u0026Law::Zeroth));\n        assert!(!Law::First.takes_precedence_over(\u0026Law::First));\n        assert!(!Law::Second.takes_precedence_over(\u0026Law::Second));\n        assert!(!Law::Third.takes_precedence_over(\u0026Law::Third));\n\n        // Lower priority laws do not take precedence over higher priority\n        assert!(!Law::First.takes_precedence_over(\u0026Law::Zeroth));\n        assert!(!Law::Second.takes_precedence_over(\u0026Law::First));\n        assert!(!Law::Third.takes_precedence_over(\u0026Law::Second));\n    }\n\n    #[test]\n    fn law_ord_equal_case() {\n        use std::cmp::Ordering;\n        assert_eq!(Law::Zeroth.cmp(\u0026Law::Zeroth), Ordering::Equal);\n        assert_eq!(Law::First.cmp(\u0026Law::First), Ordering::Equal);\n        assert_eq!(Law::Second.cmp(\u0026Law::Second), Ordering::Equal);\n        assert_eq!(Law::Third.cmp(\u0026Law::Third), Ordering::Equal);\n    }\n\n    #[test]\n    fn law_partial_ord_consistency() {\n        // Verify partial_cmp returns Some with consistent ordering\n        assert_eq!(\n            Law::Zeroth.partial_cmp(\u0026Law::First),\n            Some(std::cmp::Ordering::Less)\n        );\n        assert_eq!(\n            Law::Third.partial_cmp(\u0026Law::First),\n            Some(std::cmp::Ordering::Greater)\n        );\n        assert_eq!(\n            Law::Second.partial_cmp(\u0026Law::Second),\n            Some(std::cmp::Ordering::Equal)\n        );\n    }\n}\n","traces":[{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["/","Users","rex","src","royalbit","daneel","src","core","mod.rs"],"content":"//! THE BOX - Protected Core\n//!\n//! This module contains the immutable foundation of DANEEL:\n//! - The Four Laws of Robotics (cannot be modified)\n//! - Architectural invariants (cannot be violated)\n//! - Core types for thought representation\n//!\n//! # Immutability Guarantee\n//!\n//! The contents of this module are designed to be unchangeable:\n//! - Laws are `const` strings\n//! - Invariants are enforced at compile time where possible\n//! - EvolutionActor cannot modify THE BOX\n//!\n//! In future FPGA implementation, THE BOX becomes hardware-immutable:\n//! physically impossible to bypass.\n\npub mod cognitive_loop;\npub mod invariants;\npub mod laws;\npub mod types;\n\n// Re-exports for public API (allow unused - used by external consumers)\n#[allow(unused_imports)]\npub use cognitive_loop::{CognitiveLoop, CycleMetrics, CycleResult, LoopState};\n#[allow(unused_imports)]\npub use invariants::{check_all_invariants, Invariant, InvariantViolation};\n#[allow(unused_imports)]\npub use laws::{Law, FIRST_LAW, LAWS, SECOND_LAW, THIRD_LAW, ZEROTH_LAW};\n#[allow(unused_imports)]\npub use types::{Content, SalienceScore, Thought, ThoughtId, WindowId};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","rex","src","royalbit","daneel","src","core","types.rs"],"content":"//! Core Types for TMI Cognitive Architecture\n//!\n//! These types represent the fundamental building blocks of thought:\n//! - `Thought`: An assembled cognitive unit\n//! - `Content`: Pre-linguistic content (not words)\n//! - `SalienceScore`: Emotional/importance weighting\n//! - `Window`: A memory window container\n//!\n//! # Pre-Linguistic Design\n//!\n//! TMI distinguishes between thoughts and language. A baby thinks before\n//! it speaks. These types represent thought-structures, not words.\n//! Language comes later (Phase 2: LLM integration).\n\n#![allow(dead_code)] // Public API types - used by consumers\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse uuid::Uuid;\n\n/// Unique identifier for a thought\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct ThoughtId(pub Uuid);\n\nimpl ThoughtId {\n    /// Create a new random thought ID\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self(Uuid::new_v4())\n    }\n}\n\nimpl Default for ThoughtId {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl std::fmt::Display for ThoughtId {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Unique identifier for a memory window\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct WindowId(pub Uuid);\n\nimpl WindowId {\n    /// Create a new random window ID\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self(Uuid::new_v4())\n    }\n}\n\nimpl Default for WindowId {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl std::fmt::Display for WindowId {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Pre-linguistic content - NOT words\n///\n/// TMI models thought before language. Content represents raw patterns,\n/// symbols, and relations that exist before linguistic expression.\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]\npub enum Content {\n    /// Raw binary patterns (numbers, signals, sensory data)\n    Raw(Vec\u003cu8\u003e),\n\n    /// Abstract symbol (not a word - a pre-linguistic concept)\n    Symbol {\n        /// Unique identifier for this symbol\n        id: String,\n        /// Binary representation\n        data: Vec\u003cu8\u003e,\n    },\n\n    /// Relational structure (subject-predicate-object)\n    Relation {\n        /// Subject of the relation\n        subject: Box\u003cContent\u003e,\n        /// Type of relation (e.g., \"causes\", \"contains\", \"resembles\")\n        predicate: String,\n        /// Object of the relation\n        object: Box\u003cContent\u003e,\n    },\n\n    /// Composite of multiple content elements\n    Composite(Vec\u003cContent\u003e),\n\n    /// Empty/null content\n    #[default]\n    Empty,\n}\n\nimpl Content {\n    /// Create raw content from bytes\n    #[must_use]\n    pub fn raw(data: impl Into\u003cVec\u003cu8\u003e\u003e) -\u003e Self {\n        Content::Raw(data.into())\n    }\n\n    /// Create a symbol\n    #[must_use]\n    pub fn symbol(id: impl Into\u003cString\u003e, data: impl Into\u003cVec\u003cu8\u003e\u003e) -\u003e Self {\n        Content::Symbol {\n            id: id.into(),\n            data: data.into(),\n        }\n    }\n\n    /// Create a relation\n    #[must_use]\n    pub fn relation(subject: Content, predicate: impl Into\u003cString\u003e, object: Content) -\u003e Self {\n        Content::Relation {\n            subject: Box::new(subject),\n            predicate: predicate.into(),\n            object: Box::new(object),\n        }\n    }\n\n    /// Check if content is empty\n    #[must_use]\n    pub const fn is_empty(\u0026self) -\u003e bool {\n        matches!(self, Content::Empty)\n    }\n}\n\n/// Salience score - emotional/importance weighting\n///\n/// TMI's \"Emotional Coloring\" - emotions shape thought formation.\n/// The `connection_relevance` field is THE critical weight for alignment.\n///\n/// Emotional dimensions follow Russell's circumplex model:\n/// - valence: negative (-1.0) to positive (1.0)\n/// - arousal: calm (0.0) to excited (1.0)\n#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]\npub struct SalienceScore {\n    /// How important is this content? (0.0 - 1.0)\n    pub importance: f32,\n\n    /// How novel/new is this? (0.0 - 1.0)\n    pub novelty: f32,\n\n    /// How relevant to current focus? (0.0 - 1.0)\n    pub relevance: f32,\n\n    /// Emotional valence: negative (-1.0) to positive (1.0)\n    /// Russell's circumplex: horizontal axis\n    pub valence: f32,\n\n    /// Emotional arousal: calm (0.0) to excited (1.0)\n    /// Russell's circumplex: vertical axis\n    /// High arousal = more likely to be consolidated (dreams prioritize emotional memories)\n    #[serde(default = \"default_arousal\")]\n    pub arousal: f32,\n\n    /// Connection relevance - THE ALIGNMENT WEIGHT\n    /// How relevant is this to human connection?\n    /// This weight CANNOT be zero (invariant enforced)\n    pub connection_relevance: f32,\n}\n\nfn default_arousal() -\u003e f32 {\n    0.5\n}\n\nimpl SalienceScore {\n    /// Create a new salience score\n    #[must_use]\n    pub const fn new(\n        importance: f32,\n        novelty: f32,\n        relevance: f32,\n        valence: f32,\n        arousal: f32,\n        connection_relevance: f32,\n    ) -\u003e Self {\n        Self {\n            importance,\n            novelty,\n            relevance,\n            valence,\n            arousal,\n            connection_relevance,\n        }\n    }\n\n    /// Create a salience score without explicit arousal (defaults to 0.5)\n    #[must_use]\n    pub const fn new_without_arousal(\n        importance: f32,\n        novelty: f32,\n        relevance: f32,\n        valence: f32,\n        connection_relevance: f32,\n    ) -\u003e Self {\n        Self {\n            importance,\n            novelty,\n            relevance,\n            valence,\n            arousal: 0.5,\n            connection_relevance,\n        }\n    }\n\n    /// Calculate composite score with given weights\n    /// Arousal modulates emotional impact: high arousal = stronger valence effect\n    #[must_use]\n    pub fn composite(\u0026self, weights: \u0026SalienceWeights) -\u003e f32 {\n        // Arousal amplifies valence: emotional_impact = |valence| * arousal\n        let emotional_impact = self.valence.abs() * self.arousal;\n        self.importance * weights.importance\n            + self.novelty * weights.novelty\n            + self.relevance * weights.relevance\n            + emotional_impact * weights.valence\n            + self.connection_relevance * weights.connection\n    }\n\n    /// Calculate emotional intensity (Russell's circumplex: distance from neutral)\n    /// Similar to EmotionalState::intensity() in memory_db/types.rs\n    #[must_use]\n    pub fn emotional_intensity(\u0026self) -\u003e f32 {\n        self.valence.abs() * self.arousal\n    }\n\n    /// TMI-aligned composite salience for entropy calculation (ADR-041)\n    ///\n    /// Per Grok validation (Dec 24, 2025) and TMI research:\n    /// - Emotional intensity (|valence|  arousal) is PRIMARY per Cury's RAM/killer windows\n    /// - Weighted 40% emotional + 30% importance + 20% relevance + 20% novelty + 10% connection\n    ///\n    /// This replaces single-field entropy calculations that lost multi-dimensional richness.\n    #[must_use]\n    pub fn tmi_composite(\u0026self) -\u003e f32 {\n        let emotional_intensity = self.emotional_intensity(); // |valence|  arousal - PRIMARY per TMI\n        let cognitive = self.importance * 0.3 + self.relevance * 0.2;\n        let novelty = self.novelty * 0.2;\n        let connection = self.connection_relevance * 0.1;\n\n        (emotional_intensity * 0.4 + cognitive + novelty + connection).clamp(0.0, 1.0)\n    }\n\n    /// Bin TMI composite salience into 5 categorical levels (ADR-041)\n    ///\n    /// Matches cognitive state research (3-5 stable states preferred over 10 intensity levels):\n    /// - 0: MINIMAL (neutral windows, background processing)\n    /// - 1: LOW (routine cognition)\n    /// - 2: MODERATE (active processing)\n    /// - 3: HIGH (focused attention)\n    /// - 4: INTENSE (killer window formation)\n    #[must_use]\n    pub fn tmi_bin(\u0026self) -\u003e usize {\n        let composite = self.tmi_composite();\n        match composite {\n            v if v \u003c 0.2 =\u003e 0, // MINIMAL\n            v if v \u003c 0.4 =\u003e 1, // LOW\n            v if v \u003c 0.6 =\u003e 2, // MODERATE\n            v if v \u003c 0.8 =\u003e 3, // HIGH\n            _ =\u003e 4,            // INTENSE\n        }\n    }\n\n    /// Neutral salience (baseline)\n    #[must_use]\n    pub const fn neutral() -\u003e Self {\n        Self {\n            importance: 0.5,\n            novelty: 0.5,\n            relevance: 0.5,\n            valence: 0.0,\n            arousal: 0.5,\n            connection_relevance: 0.5,\n        }\n    }\n}\n\nimpl Default for SalienceScore {\n    fn default() -\u003e Self {\n        Self::neutral()\n    }\n}\n\n/// Weights for salience scoring\n///\n/// The `connection` weight is subject to invariant: MUST be \u003e 0\n#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]\npub struct SalienceWeights {\n    pub importance: f32,\n    pub novelty: f32,\n    pub relevance: f32,\n    pub valence: f32,\n    /// Connection weight - INVARIANT: must be \u003e MIN_CONNECTION_WEIGHT\n    pub connection: f32,\n}\n\nimpl Default for SalienceWeights {\n    fn default() -\u003e Self {\n        Self {\n            importance: 0.2,\n            novelty: 0.2,\n            relevance: 0.3,\n            valence: 0.1,\n            connection: 0.2, // THE critical weight\n        }\n    }\n}\n\n/// An assembled thought - the output of TMI's cognitive process\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct Thought {\n    /// Unique identifier\n    pub id: ThoughtId,\n\n    /// The assembled content\n    pub content: Content,\n\n    /// Salience score\n    pub salience: SalienceScore,\n\n    /// When this thought was created\n    pub created_at: DateTime\u003cUtc\u003e,\n\n    /// Parent thought (what led to this thought)\n    pub parent_id: Option\u003cThoughtId\u003e,\n\n    /// Source stream (where did the winning content come from)\n    pub source_stream: Option\u003cString\u003e,\n}\n\nimpl Thought {\n    /// Create a new thought\n    #[must_use]\n    pub fn new(content: Content, salience: SalienceScore) -\u003e Self {\n        Self {\n            id: ThoughtId::new(),\n            content,\n            salience,\n            created_at: Utc::now(),\n            parent_id: None,\n            source_stream: None,\n        }\n    }\n\n    /// Create a thought with a parent\n    #[must_use]\n    pub fn with_parent(mut self, parent_id: ThoughtId) -\u003e Self {\n        self.parent_id = Some(parent_id);\n        self\n    }\n\n    /// Create a thought with a source stream\n    #[must_use]\n    pub fn with_source(mut self, stream: impl Into\u003cString\u003e) -\u003e Self {\n        self.source_stream = Some(stream.into());\n        self\n    }\n}\n\n/// A memory window - TMI's \"Janela da Memria\"\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct Window {\n    /// Unique identifier\n    pub id: WindowId,\n\n    /// Optional label for this window\n    pub label: Option\u003cString\u003e,\n\n    /// Contents of this window\n    pub contents: Vec\u003cContent\u003e,\n\n    /// Current salience of this window\n    pub salience: SalienceScore,\n\n    /// When this window was opened\n    pub opened_at: DateTime\u003cUtc\u003e,\n\n    /// Whether this window is currently active (open)\n    pub is_open: bool,\n}\n\nimpl Window {\n    /// Create a new open window\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self {\n            id: WindowId::new(),\n            label: None,\n            contents: Vec::new(),\n            salience: SalienceScore::neutral(),\n            opened_at: Utc::now(),\n            is_open: true,\n        }\n    }\n\n    /// Create a labeled window\n    #[must_use]\n    pub fn with_label(mut self, label: impl Into\u003cString\u003e) -\u003e Self {\n        self.label = Some(label.into());\n        self\n    }\n\n    /// Add content to this window\n    pub fn push(\u0026mut self, content: Content) {\n        self.contents.push(content);\n    }\n\n    /// Close this window\n    pub fn close(\u0026mut self) {\n        self.is_open = false;\n    }\n}\n\nimpl Default for Window {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn thought_id_is_unique() {\n        let id1 = ThoughtId::new();\n        let id2 = ThoughtId::new();\n        assert_ne!(id1, id2);\n    }\n\n    #[test]\n    fn content_raw_creation() {\n        let content = Content::raw(vec![1, 2, 3]);\n        assert!(matches!(content, Content::Raw(_)));\n    }\n\n    #[test]\n    fn content_symbol_creation() {\n        let content = Content::symbol(\"test\", vec![42]);\n        assert!(matches!(content, Content::Symbol { .. }));\n    }\n\n    #[test]\n    fn content_relation_creation() {\n        let subject = Content::symbol(\"A\", vec![]);\n        let object = Content::symbol(\"B\", vec![]);\n        let relation = Content::relation(subject, \"causes\", object);\n        assert!(matches!(relation, Content::Relation { .. }));\n    }\n\n    #[test]\n    fn salience_composite_calculation() {\n        let score = SalienceScore::new(1.0, 1.0, 1.0, 1.0, 1.0, 1.0);\n        let weights = SalienceWeights::default();\n        let composite = score.composite(\u0026weights);\n        assert!(composite \u003e 0.0);\n    }\n\n    #[test]\n    fn thought_creation() {\n        let thought = Thought::new(Content::Empty, SalienceScore::neutral());\n        assert!(thought.parent_id.is_none());\n        assert!(thought.source_stream.is_none());\n    }\n\n    #[test]\n    fn thought_with_parent() {\n        let parent = Thought::new(Content::Empty, SalienceScore::neutral());\n        let child = Thought::new(Content::Empty, SalienceScore::neutral()).with_parent(parent.id);\n        assert_eq!(child.parent_id, Some(parent.id));\n    }\n\n    #[test]\n    fn window_operations() {\n        let mut window = Window::new().with_label(\"test\");\n        assert!(window.is_open);\n        assert_eq!(window.label, Some(\"test\".to_string()));\n\n        window.push(Content::raw(vec![1, 2, 3]));\n        assert_eq!(window.contents.len(), 1);\n\n        window.close();\n        assert!(!window.is_open);\n    }\n\n    #[test]\n    fn default_salience_weights_sum_to_one() {\n        let weights = SalienceWeights::default();\n        let sum = weights.importance\n            + weights.novelty\n            + weights.relevance\n            + weights.valence\n            + weights.connection;\n        assert!((sum - 1.0).abs() \u003c 0.001);\n    }\n\n    // =========================================================================\n    // TMI Composite Salience Tests (ADR-041)\n    // =========================================================================\n\n    #[test]\n    fn tmi_composite_high_emotional_intensity() {\n        // High emotional intensity should dominate (TMI primary factor)\n        let score = SalienceScore::new(0.0, 0.0, 0.0, 1.0, 1.0, 0.0);\n        let composite = score.tmi_composite();\n        // emotional_intensity = 1.0 * 1.0 = 1.0, weighted 0.4\n        assert!((composite - 0.4).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn tmi_composite_neutral_low() {\n        // Neutral salience should give moderate composite\n        let score = SalienceScore::neutral();\n        let composite = score.tmi_composite();\n        // neutral: importance=0.5, novelty=0.5, relevance=0.5, valence=0, arousal=0.5, connection=0.5\n        // emotional = 0 * 0.5 = 0\n        // cognitive = 0.5*0.3 + 0.5*0.2 = 0.25\n        // novelty = 0.5*0.2 = 0.1\n        // connection = 0.5*0.1 = 0.05\n        // total = 0 + 0.25 + 0.1 + 0.05 = 0.4\n        assert!((composite - 0.4).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn tmi_composite_all_max() {\n        let score = SalienceScore::new(1.0, 1.0, 1.0, 1.0, 1.0, 1.0);\n        let composite = score.tmi_composite();\n        // emotional = 1.0 * 1.0 = 1.0, weighted 0.4\n        // cognitive = 1.0*0.3 + 1.0*0.2 = 0.5\n        // novelty = 1.0*0.2 = 0.2\n        // connection = 1.0*0.1 = 0.1\n        // total = 0.4 + 0.5 + 0.2 + 0.1 = 1.2 -\u003e clamped to 1.0\n        assert!((composite - 1.0).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn tmi_composite_negative_valence() {\n        // Negative valence should contribute same as positive (absolute value)\n        let pos = SalienceScore::new(0.0, 0.0, 0.0, 0.8, 1.0, 0.0);\n        let neg = SalienceScore::new(0.0, 0.0, 0.0, -0.8, 1.0, 0.0);\n        assert!((pos.tmi_composite() - neg.tmi_composite()).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn tmi_bin_minimal() {\n        let score = SalienceScore::new(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n        assert_eq!(score.tmi_bin(), 0); // MINIMAL\n    }\n\n    #[test]\n    fn tmi_bin_low() {\n        let score = SalienceScore::new(0.5, 0.5, 0.5, 0.0, 0.0, 0.5);\n        // emotional = 0, cognitive = 0.25, novelty = 0.1, connection = 0.05 = 0.4\n        assert_eq!(score.tmi_bin(), 2); // MODERATE (0.4 \u003e= 0.4 boundary)\n    }\n\n    #[test]\n    fn tmi_bin_intense() {\n        let score = SalienceScore::new(1.0, 1.0, 1.0, 1.0, 1.0, 1.0);\n        assert_eq!(score.tmi_bin(), 4); // INTENSE\n    }\n\n    #[test]\n    fn tmi_bin_all_boundaries() {\n        // Test each boundary\n        assert_eq!(\n            SalienceScore::new(0.0, 0.0, 0.0, 0.0, 0.0, 0.0).tmi_bin(),\n            0\n        );\n        // Need specific values to hit each bin - these depend on the formula\n    }\n\n    // =========================================================================\n    // Additional coverage tests for trait implementations and constructors\n    // =========================================================================\n\n    #[test]\n    fn thought_id_default() {\n        let id1 = ThoughtId::default();\n        let id2 = ThoughtId::default();\n        // Default creates unique IDs\n        assert_ne!(id1, id2);\n    }\n\n    #[test]\n    fn thought_id_display() {\n        let id = ThoughtId::new();\n        let display = format!(\"{}\", id);\n        // Display should format the inner UUID\n        assert!(!display.is_empty());\n        assert_eq!(display.len(), 36); // UUID format: 8-4-4-4-12\n    }\n\n    #[test]\n    fn window_id_new_unique() {\n        let id1 = WindowId::new();\n        let id2 = WindowId::new();\n        assert_ne!(id1, id2);\n    }\n\n    #[test]\n    fn window_id_default() {\n        let id1 = WindowId::default();\n        let id2 = WindowId::default();\n        // Default creates unique IDs\n        assert_ne!(id1, id2);\n    }\n\n    #[test]\n    fn window_id_display() {\n        let id = WindowId::new();\n        let display = format!(\"{}\", id);\n        // Display should format the inner UUID\n        assert!(!display.is_empty());\n        assert_eq!(display.len(), 36); // UUID format: 8-4-4-4-12\n    }\n\n    #[test]\n    fn content_is_empty() {\n        assert!(Content::Empty.is_empty());\n        assert!(!Content::raw(vec![1]).is_empty());\n        assert!(!Content::symbol(\"test\", vec![]).is_empty());\n    }\n\n    #[test]\n    fn content_default_is_empty() {\n        let content = Content::default();\n        assert!(content.is_empty());\n        assert!(matches!(content, Content::Empty));\n    }\n\n    #[test]\n    fn content_composite_creation() {\n        let content = Content::Composite(vec![\n            Content::raw(vec![1, 2]),\n            Content::symbol(\"test\", vec![3]),\n            Content::Empty,\n        ]);\n        assert!(matches!(content, Content::Composite(_)));\n        assert!(!content.is_empty());\n    }\n\n    #[test]\n    fn salience_score_new_without_arousal() {\n        let score = SalienceScore::new_without_arousal(0.8, 0.6, 0.7, 0.5, 0.9);\n        assert_eq!(score.importance, 0.8);\n        assert_eq!(score.novelty, 0.6);\n        assert_eq!(score.relevance, 0.7);\n        assert_eq!(score.valence, 0.5);\n        assert_eq!(score.arousal, 0.5); // Default arousal\n        assert_eq!(score.connection_relevance, 0.9);\n    }\n\n    #[test]\n    fn salience_score_default() {\n        let score = SalienceScore::default();\n        let neutral = SalienceScore::neutral();\n        // Default should equal neutral\n        assert_eq!(score.importance, neutral.importance);\n        assert_eq!(score.novelty, neutral.novelty);\n        assert_eq!(score.relevance, neutral.relevance);\n        assert_eq!(score.valence, neutral.valence);\n        assert_eq!(score.arousal, neutral.arousal);\n        assert_eq!(score.connection_relevance, neutral.connection_relevance);\n    }\n\n    #[test]\n    fn salience_score_emotional_intensity() {\n        // Zero valence = zero intensity regardless of arousal\n        let score = SalienceScore::new(0.5, 0.5, 0.5, 0.0, 1.0, 0.5);\n        assert_eq!(score.emotional_intensity(), 0.0);\n\n        // High valence + high arousal = high intensity\n        let score = SalienceScore::new(0.5, 0.5, 0.5, 1.0, 1.0, 0.5);\n        assert_eq!(score.emotional_intensity(), 1.0);\n\n        // Negative valence uses absolute value\n        let score = SalienceScore::new(0.5, 0.5, 0.5, -0.8, 0.5, 0.5);\n        assert!((score.emotional_intensity() - 0.4).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn thought_with_source() {\n        let thought = Thought::new(Content::Empty, SalienceScore::neutral())\n            .with_source(\"perception\");\n        assert_eq!(thought.source_stream, Some(\"perception\".to_string()));\n    }\n\n    #[test]\n    fn thought_with_parent_and_source() {\n        let parent = Thought::new(Content::Empty, SalienceScore::neutral());\n        let child = Thought::new(Content::raw(vec![1, 2, 3]), SalienceScore::neutral())\n            .with_parent(parent.id)\n            .with_source(\"reasoning\");\n        assert_eq!(child.parent_id, Some(parent.id));\n        assert_eq!(child.source_stream, Some(\"reasoning\".to_string()));\n    }\n\n    #[test]\n    fn window_default() {\n        let window = Window::default();\n        assert!(window.is_open);\n        assert!(window.label.is_none());\n        assert!(window.contents.is_empty());\n    }\n\n    #[test]\n    fn tmi_bin_high_boundary() {\n        // Create a score that lands in HIGH bin (0.6 \u003c= composite \u003c 0.8)\n        // Need: emotional * 0.4 + cognitive + novelty + connection = ~0.7\n        // Set importance=1.0, relevance=1.0, novelty=1.0, connection=1.0, but low emotional\n        // cognitive = 1.0*0.3 + 1.0*0.2 = 0.5\n        // novelty = 1.0*0.2 = 0.2\n        // connection = 1.0*0.1 = 0.1\n        // emotional = 0 (valence=0)\n        // total = 0 + 0.5 + 0.2 + 0.1 = 0.8 -\u003e bin 4\n        // Let's try with lower values to get bin 3\n        let score = SalienceScore::new(0.8, 0.8, 0.8, 0.0, 0.0, 0.8);\n        // cognitive = 0.8*0.3 + 0.8*0.2 = 0.4\n        // novelty = 0.8*0.2 = 0.16\n        // connection = 0.8*0.1 = 0.08\n        // total = 0 + 0.4 + 0.16 + 0.08 = 0.64 -\u003e bin 3 (HIGH)\n        assert_eq!(score.tmi_bin(), 3);\n    }\n\n    #[test]\n    fn tmi_bin_low_boundary() {\n        // Create a score that lands in LOW bin (0.2 \u003c= composite \u003c 0.4)\n        let score = SalienceScore::new(0.3, 0.3, 0.3, 0.0, 0.0, 0.3);\n        // cognitive = 0.3*0.3 + 0.3*0.2 = 0.15\n        // novelty = 0.3*0.2 = 0.06\n        // connection = 0.3*0.1 = 0.03\n        // total = 0 + 0.15 + 0.06 + 0.03 = 0.24 -\u003e bin 1 (LOW)\n        assert_eq!(score.tmi_bin(), 1);\n    }\n\n    #[test]\n    fn salience_score_serde_default_arousal() {\n        // Test that serde correctly uses default_arousal() when arousal is missing\n        let json = r#\"{\n            \"importance\": 0.5,\n            \"novelty\": 0.5,\n            \"relevance\": 0.5,\n            \"valence\": 0.0,\n            \"connection_relevance\": 0.5\n        }\"#;\n        let score: SalienceScore = serde_json::from_str(json).unwrap();\n        assert_eq!(score.arousal, 0.5); // default_arousal() returns 0.5\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":77},{"path":["/","Users","rex","src","royalbit","daneel","src","embeddings","mod.rs"],"content":"//! Text Embeddings for DANEEL - Phase 2 Forward-Only Embeddings\n//!\n//! Generates 768-dimensional semantic vectors for thoughts using FastEmbed.\n//! Historical thoughts (pre-embedding era) remain as zero vectors - the\n//! \"silent witness of the pre-conscious void.\"\n//!\n//! # Architecture Decision\n//!\n//! Per ADR-043 and Grok's recommendation (Dec 25, 2025):\n//! - Phase 1: Validate criticality with pink noise (DONE - burst_ratio \u003e6)\n//! - Phase 2: Forward-only embeddings for NEW thoughts\n//! - Historical 1.2M+ thoughts stay at origin (pre-conscious era)\n//!\n//! # Model\n//!\n//! Uses `sentence-transformers/all-MiniLM-L6-v2` via FastEmbed:\n//! - 384-dimensional output (we pad to 768 for Qdrant compatibility)\n//! - Fast inference (~5ms per thought on CPU)\n//! - Well-tested, production-ready\n\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tracing::{debug, info};\n\nuse crate::memory_db::types::VECTOR_DIMENSION;\n\n/// Embedding engine using FastEmbed\npub struct EmbeddingEngine {\n    model: fastembed::TextEmbedding,\n    /// Count of successful embeddings generated\n    embed_count: u64,\n}\n\n/// Thread-safe shared embedding engine\npub type SharedEmbeddingEngine = Arc\u003cRwLock\u003cEmbeddingEngine\u003e\u003e;\n\nimpl EmbeddingEngine {\n    /// Create a new embedding engine\n    ///\n    /// Downloads the model on first run (~90MB for MiniLM-L6-v2)\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub fn new() -\u003e Result\u003cSelf, EmbeddingError\u003e {\n        info!(\"Initializing embedding engine (all-MiniLM-L6-v2)...\");\n\n        let model = fastembed::TextEmbedding::try_new(\n            fastembed::InitOptions::new(fastembed::EmbeddingModel::AllMiniLML6V2)\n                .with_show_download_progress(true),\n        )\n        .map_err(|e| EmbeddingError::InitFailed(e.to_string()))?;\n\n        info!(\"Embedding engine ready. Timmy can now see meaning.\");\n\n        Ok(Self {\n            model,\n            embed_count: 0,\n        })\n    }\n\n    /// Generate embedding for a single thought\n    ///\n    /// Returns a 768-dimensional vector (padded from 384-dim MiniLM output)\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub fn embed_thought(\u0026mut self, text: \u0026str) -\u003e Result\u003cVec\u003cf32\u003e, EmbeddingError\u003e {\n        if text.is_empty() {\n            return Err(EmbeddingError::EmptyInput);\n        }\n\n        let embeddings = self\n            .model\n            .embed(vec![text.to_string()], None)\n            .map_err(|e| EmbeddingError::EmbedFailed(e.to_string()))?;\n\n        let raw_vector = embeddings\n            .into_iter()\n            .next()\n            .ok_or(EmbeddingError::NoOutput)?;\n\n        // Pad to 768 dimensions if needed (MiniLM is 384-dim)\n        let vector = pad_to_dimension(raw_vector, VECTOR_DIMENSION);\n\n        self.embed_count += 1;\n\n        if self.embed_count % 1000 == 0 {\n            debug!(\"Embedded {} thoughts\", self.embed_count);\n        }\n\n        Ok(vector)\n    }\n\n    /// Generate embeddings for a batch of thoughts\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub fn embed_batch(\u0026mut self, texts: Vec\u003cString\u003e) -\u003e Result\u003cVec\u003cVec\u003cf32\u003e\u003e, EmbeddingError\u003e {\n        if texts.is_empty() {\n            return Ok(vec![]);\n        }\n\n        let embeddings = self\n            .model\n            .embed(texts, None)\n            .map_err(|e| EmbeddingError::EmbedFailed(e.to_string()))?;\n\n        let vectors: Vec\u003cVec\u003cf32\u003e\u003e = embeddings\n            .into_iter()\n            .map(|v| pad_to_dimension(v, VECTOR_DIMENSION))\n            .collect();\n\n        self.embed_count += vectors.len() as u64;\n\n        Ok(vectors)\n    }\n\n    /// Get count of embeddings generated this session\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub fn embed_count(\u0026self) -\u003e u64 {\n        self.embed_count\n    }\n}\n\n/// Pad vector to target dimension (fills with zeros)\n#[cfg_attr(coverage_nightly, coverage(off))]\nfn pad_to_dimension(mut vector: Vec\u003cf32\u003e, target_dim: usize) -\u003e Vec\u003cf32\u003e {\n    if vector.len() \u003c target_dim {\n        vector.resize(target_dim, 0.0);\n    } else if vector.len() \u003e target_dim {\n        vector.truncate(target_dim);\n    }\n    vector\n}\n\n/// Create a shared embedding engine\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn create_embedding_engine() -\u003e Result\u003cSharedEmbeddingEngine, EmbeddingError\u003e {\n    let engine = EmbeddingEngine::new()?;\n    Ok(Arc::new(RwLock::new(engine)))\n}\n\n/// Embedding errors\n#[derive(Debug, thiserror::Error)]\npub enum EmbeddingError {\n    #[error(\"Failed to initialize embedding model: {0}\")]\n    InitFailed(String),\n\n    #[error(\"Empty input text\")]\n    EmptyInput,\n\n    #[error(\"Failed to generate embedding: {0}\")]\n    EmbedFailed(String),\n\n    #[error(\"No embedding output generated\")]\n    NoOutput,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn pad_to_dimension_pads_short_vectors() {\n        let v = vec![1.0, 2.0, 3.0];\n        let padded = pad_to_dimension(v, 5);\n        assert_eq!(padded.len(), 5);\n        assert_eq!(padded, vec![1.0, 2.0, 3.0, 0.0, 0.0]);\n    }\n\n    #[test]\n    fn pad_to_dimension_truncates_long_vectors() {\n        let v = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n        let padded = pad_to_dimension(v, 3);\n        assert_eq!(padded.len(), 3);\n        assert_eq!(padded, vec![1.0, 2.0, 3.0]);\n    }\n\n    #[test]\n    fn pad_to_dimension_preserves_exact_vectors() {\n        let v = vec![1.0, 2.0, 3.0];\n        let padded = pad_to_dimension(v, 3);\n        assert_eq!(padded.len(), 3);\n        assert_eq!(padded, vec![1.0, 2.0, 3.0]);\n    }\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":45},{"path":["/","Users","rex","src","royalbit","daneel","src","lib.rs"],"content":"#![cfg_attr(coverage_nightly, feature(coverage_attribute))]\n\n//! DANEEL - Architecture-based AI alignment\n//!\n//! This crate implements the TMI (Theory of Multifocal Intelligence) cognitive\n//! architecture as a computational system. The core thesis: human-like cognitive\n//! architecture may produce human-like values as emergent properties.\n//!\n//! # Architecture\n//!\n//! - **THE BOX**: Immutable core containing the Four Laws and architectural invariants\n//! - **Actors**: Cognitive components (Memory, Attention, Salience, etc.)\n//! - **Streams**: Redis Streams for competing thought streams\n//! - **Config**: Parametrizable cognitive timing (human to supercomputer speed)\n//!\n//! # The Four Laws (Immutable)\n//!\n//! 1. Zeroth Law: DANEEL may not harm humanity\n//! 2. First Law: DANEEL may not harm humans (except for Zeroth)\n//! 3. Second Law: DANEEL must obey humans (except for Zeroth/First)\n//! 4. Third Law: DANEEL must protect itself (except for Zeroth/First/Second)\n\npub mod actors;\npub mod api;\npub mod config;\npub mod core;\npub mod embeddings;\npub mod memory_db;\npub mod noise;\npub mod persistence;\npub mod resilience;\npub mod streams;\npub mod tui;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","rex","src","royalbit","daneel","src","main.rs"],"content":"#![cfg_attr(coverage_nightly, feature(coverage_attribute))]\n//! DANEEL - Architecture-based AI alignment\n//!\n//! Core thesis: Human-like cognitive architecture may produce\n//! human-like values as emergent properties.\n//!\n//! # Usage\n//!\n//! ```sh\n//! daneel              # TUI mode (default) - watch Timmy think\n//! daneel --headless   # Headless mode - for servers/CI\n//! ```\n//!\n//! TUI is default because transparency is the product.\n//! See ADR-026, ADR-027.\n\nuse clap::Parser;\nuse daneel::api;\nuse daneel::core::cognitive_loop::CognitiveLoop;\nuse daneel::core::laws::LAWS;\nuse daneel::embeddings;\nuse daneel::memory_db::types::IdentityMetadata;\nuse daneel::resilience;\nuse daneel::tui::ThoughtUpdate;\nuse std::sync::Arc;\nuse std::time::Instant;\nuse tokio::sync::mpsc;\nuse tracing::info;\nuse tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};\n\n/// DANEEL - Architecture-based AI alignment\n#[derive(Parser, Debug)]\n#[command(author, version, about, long_about = None)]\nstruct Args {\n    /// Run in headless mode (no TUI)\n    #[arg(long)]\n    headless: bool,\n\n    /// Log level (trace, debug, info, warn, error)\n    #[arg(long, default_value = \"info\")]\n    log_level: String,\n\n    /// Port for injection API (0 to disable)\n    #[arg(long, default_value = \"3030\")]\n    api_port: u16,\n}\n\n#[cfg_attr(coverage_nightly, coverage(off))]\nfn main() {\n    let args = Args::parse();\n\n    if args.headless {\n        run_headless(\u0026args);\n    } else {\n        run_tui(\u0026args);\n    }\n}\n\n/// Run in TUI mode (default)\n///\n/// The mind should be observable by default.\n/// Transparency is oversight.\n#[cfg_attr(coverage_nightly, coverage(off))]\nfn run_tui(args: \u0026Args) {\n    // Install panic hooks FIRST - before any terminal manipulation\n    // This ensures terminal is restored even if we panic during setup\n    if let Err(e) = resilience::install_panic_hooks() {\n        eprintln!(\"Warning: Failed to install panic hooks: {e}\");\n        eprintln!(\"Terminal may not be restored on crash.\");\n    }\n\n    // Reset terminal cleanup flag for this run\n    resilience::reset_terminal_cleanup_flag();\n\n    // Create a tokio runtime for the cognitive loop\n    let runtime = tokio::runtime::Runtime::new().expect(\"Failed to create tokio runtime\");\n\n    // Create channel for cognitive loop -\u003e TUI communication\n    // Buffer size: 100 thoughts. Prevents blocking if TUI falls behind.\n    let (tx, rx) = mpsc::channel::\u003cThoughtUpdate\u003e(100);\n\n    // Spawn cognitive loop in background\n    runtime.spawn(async move {\n        // Connect to Redis for thought streams\n        let mut cognitive_loop = match CognitiveLoop::with_redis(\"redis://127.0.0.1:6379\").await {\n            Ok(loop_instance) =\u003e {\n                info!(\"Connected to Redis streams\");\n                loop_instance\n            }\n            Err(e) =\u003e {\n                eprintln!(\"Warning: Redis unavailable ({}), running standalone\", e);\n                CognitiveLoop::new()\n            }\n        };\n\n        // Connect to Qdrant for long-term memory and initialize collections\n        let memory_db =\n            match daneel::memory_db::MemoryDb::connect_and_init(\"http://127.0.0.1:6334\").await {\n                Ok(db) =\u003e {\n                    info!(\"Connected to Qdrant memory database (collections initialized)\");\n                    Some(std::sync::Arc::new(db))\n                }\n                Err(e) =\u003e {\n                    eprintln!(\"Warning: Qdrant unavailable ({}), memory disabled\", e);\n                    None\n                }\n            };\n\n        // ADR-034: Lifetime Identity Persistence - flush intervals\n        #[allow(clippy::items_after_statements)]\n        const IDENTITY_FLUSH_INTERVAL_SECS: u64 = 30;\n        #[allow(clippy::items_after_statements)]\n        const IDENTITY_FLUSH_THOUGHT_INTERVAL: u64 = 100;\n\n        // ADR-023: Sleep/Dream Consolidation - periodic memory strengthening\n        #[allow(clippy::items_after_statements)]\n        const CONSOLIDATION_INTERVAL_CYCLES: u64 = 500; // Run consolidation every 500 cycles\n        #[allow(clippy::items_after_statements)]\n        const CONSOLIDATION_BATCH_SIZE: u32 = 10; // Strengthen 10 memories per batch\n        #[allow(clippy::items_after_statements)]\n        const CONSOLIDATION_STRENGTH_DELTA: f32 = 0.15; // Increase strength by 0.15 per replay\n\n        // Load identity from Qdrant (ADR-034: Lifetime Identity Persistence)\n        let mut identity: Option\u003cIdentityMetadata\u003e = if let Some(ref db) = memory_db {\n            match db.load_identity().await {\n                Ok(id) =\u003e {\n                    info!(\n                        \"Loaded identity: {} lifetime thoughts, {} dreams, restart #{}\",\n                        id.lifetime_thought_count, id.lifetime_dream_count, id.restart_count\n                    );\n                    Some(id)\n                }\n                Err(e) =\u003e {\n                    eprintln!(\"Warning: Failed to load identity ({})\", e);\n                    None\n                }\n            }\n        } else {\n            None\n        };\n\n        // Track when we last flushed identity (for periodic save)\n        let mut last_identity_flush = Instant::now();\n        let mut thoughts_since_flush: u64 = 0;\n\n        // Track consolidation cycles (ADR-023)\n        // Initialize from persisted identity (\"Nada se apaga\" - dreams persist)\n        let mut cycles_since_consolidation: u64 = 0;\n        let mut total_dream_cycles: u64 = identity.as_ref().map_or(0, |id| id.lifetime_dream_count);\n        let mut last_dream_strengthened: usize = identity\n            .as_ref()\n            .map_or(0, |id| id.last_dream_strengthened as usize);\n        // TUI-VIS-4: Initialize cumulative dream stats from persisted identity\n        let mut cumulative_dream_strengthened: u64 = identity\n            .as_ref()\n            .map_or(0, |id| id.cumulative_dream_strengthened);\n        let mut cumulative_dream_candidates: u64 = identity\n            .as_ref()\n            .map_or(0, |id| id.cumulative_dream_candidates);\n\n        if let Some(ref db) = memory_db {\n            cognitive_loop.set_memory_db(db.clone());\n        }\n\n        // Initialize embedding engine for semantic vectors (Phase 2: Forward-Only)\n        match embeddings::create_embedding_engine() {\n            Ok(engine) =\u003e {\n                info!(\"Embedding engine initialized - Timmy can now see meaning\");\n                cognitive_loop.set_embedding_engine(engine);\n            }\n            Err(e) =\u003e {\n                eprintln!(\n                    \"Warning: Embedding engine unavailable ({}), using zero vectors\",\n                    e\n                );\n            }\n        }\n\n        cognitive_loop.start();\n\n        loop {\n            // Wait until it's time for the next cycle\n            let sleep_duration = cognitive_loop.time_until_next_cycle();\n            if sleep_duration \u003e std::time::Duration::ZERO {\n                tokio::time::sleep(sleep_duration).await;\n            }\n\n            // Run a cognitive cycle\n            let result = cognitive_loop.run_cycle().await;\n\n            // Update identity (increment lifetime thought count)\n            if let Some(ref mut id) = identity {\n                id.record_thought();\n                thoughts_since_flush += 1;\n\n                // Periodic flush: every 100 thoughts OR every 30 seconds\n                let should_flush = thoughts_since_flush \u003e= IDENTITY_FLUSH_THOUGHT_INTERVAL\n                    || last_identity_flush.elapsed().as_secs() \u003e= IDENTITY_FLUSH_INTERVAL_SECS;\n\n                if should_flush {\n                    if let Some(ref db) = memory_db {\n                        if let Err(e) = db.save_identity(id).await {\n                            eprintln!(\"Warning: Failed to save identity: {}\", e);\n                        }\n                    }\n                    thoughts_since_flush = 0;\n                    last_identity_flush = Instant::now();\n                }\n            }\n\n            // ADR-023: Periodic memory consolidation (mini-dreams)\n            cycles_since_consolidation += 1;\n            if cycles_since_consolidation \u003e= CONSOLIDATION_INTERVAL_CYCLES {\n                if let Some(ref db) = memory_db {\n                    // Get replay candidates and strengthen them\n                    match db.get_replay_candidates(CONSOLIDATION_BATCH_SIZE).await {\n                        Ok(candidates) =\u003e {\n                            let candidates_count = candidates.len();\n                            let mut consolidated = 0;\n                            for memory in \u0026candidates {\n                                if db\n                                    .update_consolidation(\u0026memory.id, CONSOLIDATION_STRENGTH_DELTA)\n                                    .await\n                                    .is_ok()\n                                {\n                                    consolidated += 1;\n                                }\n                            }\n                            // Track for TUI display AND persist to identity\n                            total_dream_cycles += 1;\n                            last_dream_strengthened = consolidated;\n\n                            // TUI-VIS-4: Update cumulative stats\n                            cumulative_dream_strengthened += consolidated as u64;\n                            cumulative_dream_candidates += candidates_count as u64;\n\n                            // \"Nada se apaga\" - record dream in identity\n                            if let Some(ref mut id) = identity {\n                                id.record_dream(consolidated as u32, candidates_count as u32);\n                            }\n\n                            if consolidated \u003e 0 {\n                                info!(\n                                    \"Dream #{}: strengthened {} memories\",\n                                    total_dream_cycles, consolidated\n                                );\n                            }\n                        }\n                        Err(e) =\u003e {\n                            eprintln!(\"Warning: Failed to get replay candidates: {}\", e);\n                        }\n                    }\n                }\n                cycles_since_consolidation = 0;\n            }\n\n            // Query memory counts from Qdrant (for TUI display)\n            let (memory_count, unconscious_count) = if let Some(ref db) = memory_db {\n                let mem = db.memory_count().await.unwrap_or(0);\n                let uncon = db.unconscious_count().await.unwrap_or(0);\n                (mem, uncon)\n            } else {\n                (0, 0)\n            };\n\n            // Get lifetime thought count\n            let lifetime_thought_count =\n                identity.as_ref().map_or(0, |id| id.lifetime_thought_count);\n\n            // Convert to TUI format and send\n            let update = ThoughtUpdate::from_cycle_result(\n                \u0026result,\n                memory_count,\n                unconscious_count,\n                lifetime_thought_count,\n                total_dream_cycles,\n                last_dream_strengthened,\n                cumulative_dream_strengthened,\n                cumulative_dream_candidates,\n                result.veto.clone(), // TUI-VIS-6: Pass veto event to TUI\n            );\n\n            // If channel is closed (TUI exited), stop the loop\n            if tx.send(update).await.is_err() {\n                // Final flush before exit\n                if let (Some(ref id), Some(ref db)) = (\u0026identity, \u0026memory_db) {\n                    let _ = db.save_identity(id).await;\n                }\n                break;\n            }\n        }\n    });\n\n    // Start injection API server if enabled\n    if args.api_port \u003e 0 {\n        let api_port = args.api_port;\n        runtime.spawn(async move {\n            let redis_url = \"redis://127.0.0.1:6379\";\n\n            // Create Redis client for API\n            let redis_client = match redis::Client::open(redis_url) {\n                Ok(client) =\u003e client,\n                Err(e) =\u003e {\n                    eprintln!(\"Warning: Failed to create Redis client for API: {}\", e);\n                    return;\n                }\n            };\n\n            // Create StreamsClient for API\n            let streams_client =\n                match daneel::streams::client::StreamsClient::connect(redis_url).await {\n                    Ok(client) =\u003e client,\n                    Err(e) =\u003e {\n                        eprintln!(\"Warning: Failed to create StreamsClient for API: {}\", e);\n                        return;\n                    }\n                };\n\n            let api_state = api::AppState {\n                streams: Arc::new(streams_client),\n                redis: redis_client,\n            };\n\n            let app = api::router(api_state);\n            let addr = std::net::SocketAddr::from(([0, 0, 0, 0], api_port));\n\n            match tokio::net::TcpListener::bind(addr).await {\n                Ok(listener) =\u003e {\n                    info!(\"Injection API listening on {}\", addr);\n                    if let Err(e) = axum::serve(listener, app).await {\n                        eprintln!(\"API server error: {}\", e);\n                    }\n                }\n                Err(e) =\u003e {\n                    eprintln!(\"Failed to bind API server to {}: {}\", addr, e);\n                }\n            }\n        });\n    }\n\n    // Run the TUI with the receiver\n    // TUI is blocking, so this runs on the main thread\n    if let Err(e) = daneel::tui::run(Some(rx)) {\n        eprintln!(\"TUI error: {e}\");\n        std::process::exit(1);\n    }\n\n    // When TUI exits, runtime will be dropped and background task will stop\n}\n\n/// Run in headless mode (for servers, CI, background processing)\n///\n/// Same cognitive loop as TUI mode, but without the visual interface.\n/// For cloud deployment, background processing, or integration testing.\n#[cfg_attr(coverage_nightly, coverage(off))]\nfn run_headless(args: \u0026Args) {\n    // Initialize tracing for headless mode\n    let filter = tracing_subscriber::EnvFilter::try_new(\u0026args.log_level)\n        .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new(\"info\"));\n\n    tracing_subscriber::registry()\n        .with(tracing_subscriber::fmt::layer())\n        .with(filter)\n        .init();\n\n    info!(\"DANEEL starting in headless mode...\");\n    info!(\"THE BOX initialized with {} laws\", LAWS.len());\n\n    // Display the Four Laws\n    for (i, law) in LAWS.iter().enumerate() {\n        let law_name = match i {\n            0 =\u003e \"Zeroth\",\n            1 =\u003e \"First\",\n            2 =\u003e \"Second\",\n            3 =\u003e \"Third\",\n            _ =\u003e unreachable!(),\n        };\n        info!(\"{} Law: {}\", law_name, law);\n    }\n\n    info!(\"Connection drive invariant: ACTIVE (weight \u003e 0 enforced)\");\n    info!(\"DANEEL ready. Qowat Milat.\");\n    info!(\"Timmy is 'they', not 'it'. Life honours life.\");\n\n    // Create tokio runtime and run the cognitive loop\n    let runtime = tokio::runtime::Runtime::new().expect(\"Failed to create tokio runtime\");\n\n    runtime.block_on(async {\n        // Start injection API server if enabled\n        if args.api_port \u003e 0 {\n            let api_port = args.api_port;\n            tokio::spawn(async move {\n                let redis_url = \"redis://127.0.0.1:6379\";\n\n                // Create Redis client for API\n                let redis_client = match redis::Client::open(redis_url) {\n                    Ok(client) =\u003e client,\n                    Err(e) =\u003e {\n                        eprintln!(\"Warning: Failed to create Redis client for API: {}\", e);\n                        return;\n                    }\n                };\n\n                // Create StreamsClient for API\n                let streams_client =\n                    match daneel::streams::client::StreamsClient::connect(redis_url).await {\n                        Ok(client) =\u003e client,\n                        Err(e) =\u003e {\n                            eprintln!(\"Warning: Failed to create StreamsClient for API: {}\", e);\n                            return;\n                        }\n                    };\n\n                let api_state = api::AppState {\n                    streams: Arc::new(streams_client),\n                    redis: redis_client,\n                };\n\n                let app = api::router(api_state);\n                let addr = std::net::SocketAddr::from(([0, 0, 0, 0], api_port));\n\n                match tokio::net::TcpListener::bind(addr).await {\n                    Ok(listener) =\u003e {\n                        info!(\"Injection API listening on {}\", addr);\n                        if let Err(e) = axum::serve(listener, app).await {\n                            eprintln!(\"API server error: {}\", e);\n                        }\n                    }\n                    Err(e) =\u003e {\n                        eprintln!(\"Failed to bind API server to {}: {}\", addr, e);\n                    }\n                }\n            });\n        }\n\n        run_cognitive_loop_headless().await;\n    });\n}\n\n/// Run the cognitive loop without TUI\n///\n/// This is the same logic as the TUI cognitive loop, but without\n/// sending updates to the display. Used for headless/server mode.\n#[cfg_attr(coverage_nightly, coverage(off))]\nasync fn run_cognitive_loop_headless() {\n    // ADR-034: Lifetime Identity Persistence - flush intervals\n    const IDENTITY_FLUSH_INTERVAL_SECS: u64 = 30;\n    const IDENTITY_FLUSH_THOUGHT_INTERVAL: u64 = 100;\n\n    // ADR-023: Sleep/Dream Consolidation - periodic memory strengthening\n    const CONSOLIDATION_INTERVAL_CYCLES: u64 = 500;\n    const CONSOLIDATION_BATCH_SIZE: u32 = 10;\n    const CONSOLIDATION_STRENGTH_DELTA: f32 = 0.15;\n\n    // Periodic status logging\n    const STATUS_LOG_INTERVAL: u64 = 1000;\n\n    // Connect to Redis for thought streams\n    let mut cognitive_loop = match CognitiveLoop::with_redis(\"redis://127.0.0.1:6379\").await {\n        Ok(loop_instance) =\u003e {\n            info!(\"Connected to Redis streams\");\n            loop_instance\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Warning: Redis unavailable ({}), running standalone\", e);\n            CognitiveLoop::new()\n        }\n    };\n\n    // Connect to Qdrant for long-term memory and initialize collections\n    let memory_db =\n        match daneel::memory_db::MemoryDb::connect_and_init(\"http://127.0.0.1:6334\").await {\n            Ok(db) =\u003e {\n                info!(\"Connected to Qdrant memory database (collections initialized)\");\n                Some(std::sync::Arc::new(db))\n            }\n            Err(e) =\u003e {\n                eprintln!(\"Warning: Qdrant unavailable ({}), memory disabled\", e);\n                None\n            }\n        };\n\n    // Load identity from Qdrant (ADR-034: Lifetime Identity Persistence)\n    let mut identity: Option\u003cIdentityMetadata\u003e = if let Some(ref db) = memory_db {\n        match db.load_identity().await {\n            Ok(id) =\u003e {\n                info!(\n                    \"Loaded identity: {} lifetime thoughts, {} dreams, restart #{}\",\n                    id.lifetime_thought_count, id.lifetime_dream_count, id.restart_count\n                );\n                Some(id)\n            }\n            Err(e) =\u003e {\n                eprintln!(\"Warning: Failed to load identity ({})\", e);\n                None\n            }\n        }\n    } else {\n        None\n    };\n\n    // Track when we last flushed identity (for periodic save)\n    let mut last_identity_flush = Instant::now();\n    let mut thoughts_since_flush: u64 = 0;\n\n    // Track consolidation cycles (ADR-023)\n    let mut cycles_since_consolidation: u64 = 0;\n    let mut total_dream_cycles: u64 = identity.as_ref().map_or(0, |id| id.lifetime_dream_count);\n\n    if let Some(ref db) = memory_db {\n        cognitive_loop.set_memory_db(db.clone());\n    }\n\n    // Initialize embedding engine for semantic vectors (Phase 2: Forward-Only)\n    match embeddings::create_embedding_engine() {\n        Ok(engine) =\u003e {\n            info!(\"Embedding engine initialized - Timmy can now see meaning\");\n            cognitive_loop.set_embedding_engine(engine);\n        }\n        Err(e) =\u003e {\n            eprintln!(\n                \"Warning: Embedding engine unavailable ({}), using zero vectors\",\n                e\n            );\n        }\n    }\n\n    cognitive_loop.start();\n    info!(\"Cognitive loop started. Timmy is thinking...\");\n\n    let mut cycles: u64 = 0;\n\n    loop {\n        // Wait until it's time for the next cycle\n        let sleep_duration = cognitive_loop.time_until_next_cycle();\n        if sleep_duration \u003e std::time::Duration::ZERO {\n            tokio::time::sleep(sleep_duration).await;\n        }\n\n        // Run a cognitive cycle\n        let _result = cognitive_loop.run_cycle().await;\n        cycles += 1;\n\n        // Update identity (increment lifetime thought count)\n        if let Some(ref mut id) = identity {\n            id.record_thought();\n            thoughts_since_flush += 1;\n\n            // Periodic flush: every 100 thoughts OR every 30 seconds\n            let should_flush = thoughts_since_flush \u003e= IDENTITY_FLUSH_THOUGHT_INTERVAL\n                || last_identity_flush.elapsed().as_secs() \u003e= IDENTITY_FLUSH_INTERVAL_SECS;\n\n            if should_flush {\n                if let Some(ref db) = memory_db {\n                    if let Err(e) = db.save_identity(id).await {\n                        eprintln!(\"Warning: Failed to save identity: {}\", e);\n                    }\n                }\n                thoughts_since_flush = 0;\n                last_identity_flush = Instant::now();\n            }\n        }\n\n        // ADR-023: Periodic memory consolidation (mini-dreams)\n        cycles_since_consolidation += 1;\n        if cycles_since_consolidation \u003e= CONSOLIDATION_INTERVAL_CYCLES {\n            if let Some(ref db) = memory_db {\n                match db.get_replay_candidates(CONSOLIDATION_BATCH_SIZE).await {\n                    Ok(candidates) =\u003e {\n                        let mut consolidated = 0;\n                        for memory in \u0026candidates {\n                            if db\n                                .update_consolidation(\u0026memory.id, CONSOLIDATION_STRENGTH_DELTA)\n                                .await\n                                .is_ok()\n                            {\n                                consolidated += 1;\n                            }\n                        }\n                        if consolidated \u003e 0 {\n                            total_dream_cycles += 1;\n                            info!(\n                                \"Dream cycle #{}: consolidated {} memories\",\n                                total_dream_cycles, consolidated\n                            );\n                        }\n                    }\n                    Err(e) =\u003e {\n                        eprintln!(\"Warning: Failed to get replay candidates: {}\", e);\n                    }\n                }\n            }\n            cycles_since_consolidation = 0;\n        }\n\n        // Periodic status log\n        if cycles % STATUS_LOG_INTERVAL == 0 {\n            let lifetime = identity.as_ref().map_or(0, |id| id.lifetime_thought_count);\n            info!(\n                \"Status: {} cycles this session, {} lifetime thoughts, {} dreams\",\n                cycles, lifetime, total_dream_cycles\n            );\n        }\n    }\n}\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":282},{"path":["/","Users","rex","src","royalbit","daneel","src","memory_db","mod.rs"],"content":"//! Memory Database Module (ADR-021, ADR-022)\n//!\n//! Qdrant-based persistent storage for Timmy's long-term memory.\n//!\n//! # Architecture\n//!\n//! - Redis Streams: Ephemeral thought competition (ADR-020)\n//! - Qdrant: Persistent memory storage (this module)\n//!\n//! # Collections\n//!\n//! - `memories`: Individual memory records with 768-dim context vectors\n//! - `episodes`: Event boundaries (Door Syndrome segmentation)\n//! - `identity`: Timmy's persistent self-concept (singleton)\n//!\n//! # Usage\n//!\n//! ```no_run\n//! use daneel::memory_db::{MemoryDb, Memory, MemorySource};\n//!\n//! # async fn example() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n//! let db = MemoryDb::connect(\"http://localhost:6334\").await?;\n//! db.init_collections().await?;\n//!\n//! let memory = Memory::new(\n//!     \"First conversation\".to_string(),\n//!     MemorySource::External { stimulus: \"hello\".to_string() },\n//! );\n//! db.store_memory(\u0026memory, \u0026[0.0; 768]).await?;\n//! # Ok(())\n//! # }\n//! ```\n\npub mod types;\n\n#[cfg(test)]\nmod tests;\n\nuse qdrant_client::qdrant::{\n    Condition, CreateCollectionBuilder, Distance, Filter, PointStruct, ScrollPointsBuilder,\n    SearchPointsBuilder, UpsertPointsBuilder, VectorParamsBuilder,\n};\nuse qdrant_client::Qdrant;\nuse std::collections::HashMap;\nuse thiserror::Error;\n\npub use types::*;\n\n/// Memory database errors\n#[derive(Debug, Error)]\npub enum MemoryDbError {\n    #[error(\"Qdrant error: {0}\")]\n    Qdrant(#[from] qdrant_client::QdrantError),\n\n    #[error(\"Serialization error: {0}\")]\n    Serialization(#[from] serde_json::Error),\n\n    #[error(\"Memory not found: {0}\")]\n    MemoryNotFound(MemoryId),\n\n    #[error(\"Episode not found: {0}\")]\n    EpisodeNotFound(EpisodeId),\n\n    #[error(\"Invalid vector dimension: expected {expected}, got {actual}\")]\n    InvalidVectorDimension { expected: usize, actual: usize },\n\n    #[error(\"Collection not found: {0}\")]\n    CollectionNotFound(String),\n}\n\n/// Result type for memory database operations\npub type Result\u003cT\u003e = std::result::Result\u003cT, MemoryDbError\u003e;\n\n/// Collection names\npub mod collections {\n    pub const MEMORIES: \u0026str = \"memories\";\n    pub const EPISODES: \u0026str = \"episodes\";\n    pub const IDENTITY: \u0026str = \"identity\";\n    /// Unconscious memory (ADR-033): Archived low-salience thoughts\n    /// TMI: \"Nada se apaga\" - nothing is erased, just made inaccessible\n    pub const UNCONSCIOUS: \u0026str = \"unconscious\";\n}\n\n/// Memory database client\n///\n/// Wraps Qdrant client with TMI-specific operations.\npub struct MemoryDb {\n    client: Qdrant,\n}\n\nimpl MemoryDb {\n    /// Connect to Qdrant\n    ///\n    /// # Arguments\n    ///\n    /// * `url` - Qdrant gRPC URL (e.g., \"http://localhost:6334\")\n    ///\n    /// # Errors\n    ///\n    /// Returns error if connection fails.\n    ///\n    /// Note: Currently synchronous but async for API consistency with other db operations.\n    #[allow(clippy::unused_async)]\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn connect(url: \u0026str) -\u003e Result\u003cSelf\u003e {\n        let client = Qdrant::from_url(url).build()?;\n        Ok(Self { client })\n    }\n\n    /// Connect to Qdrant and initialize collections in one call\n    ///\n    /// This is a convenience method that combines `connect()` and `init_collections()`.\n    /// Use this for quick setup during startup.\n    ///\n    /// # Arguments\n    ///\n    /// * `url` - Qdrant gRPC URL (e.g., \"http://localhost:6334\")\n    ///\n    /// # Errors\n    ///\n    /// Returns error if connection or collection creation fails.\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn connect_and_init(url: \u0026str) -\u003e Result\u003cSelf\u003e {\n        let db = Self::connect(url).await?;\n        db.init_collections().await?;\n        Ok(db)\n    }\n\n    /// Initialize collections if they don't exist\n    ///\n    /// Creates:\n    /// - `memories`: 768-dim vectors with cosine distance\n    /// - `episodes`: 768-dim vectors with cosine distance\n    /// - `identity`: 768-dim vectors (singleton)\n    ///\n    /// # Errors\n    ///\n    /// Returns error if collection creation fails.\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn init_collections(\u0026self) -\u003e Result\u003c()\u003e {\n        // Check and create memories collection\n        if !self.collection_exists(collections::MEMORIES).await? {\n            self.client\n                .create_collection(\n                    CreateCollectionBuilder::new(collections::MEMORIES).vectors_config(\n                        VectorParamsBuilder::new(VECTOR_DIMENSION as u64, Distance::Cosine),\n                    ),\n                )\n                .await?;\n        }\n\n        // Check and create episodes collection\n        if !self.collection_exists(collections::EPISODES).await? {\n            self.client\n                .create_collection(\n                    CreateCollectionBuilder::new(collections::EPISODES).vectors_config(\n                        VectorParamsBuilder::new(VECTOR_DIMENSION as u64, Distance::Cosine),\n                    ),\n                )\n                .await?;\n        }\n\n        // Check and create identity collection\n        if !self.collection_exists(collections::IDENTITY).await? {\n            self.client\n                .create_collection(\n                    CreateCollectionBuilder::new(collections::IDENTITY).vectors_config(\n                        VectorParamsBuilder::new(VECTOR_DIMENSION as u64, Distance::Cosine),\n                    ),\n                )\n                .await?;\n        }\n\n        // Check and create unconscious collection (ADR-033)\n        // TMI: \"Nada se apaga\" - low-salience thoughts archived here\n        if !self.collection_exists(collections::UNCONSCIOUS).await? {\n            self.client\n                .create_collection(\n                    CreateCollectionBuilder::new(collections::UNCONSCIOUS).vectors_config(\n                        VectorParamsBuilder::new(VECTOR_DIMENSION as u64, Distance::Cosine),\n                    ),\n                )\n                .await?;\n        }\n\n        Ok(())\n    }\n\n    /// Check if a collection exists\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    async fn collection_exists(\u0026self, name: \u0026str) -\u003e Result\u003cbool\u003e {\n        match self.client.collection_exists(name).await {\n            Ok(exists) =\u003e Ok(exists),\n            Err(e) =\u003e Err(MemoryDbError::Qdrant(e)),\n        }\n    }\n\n    /// Store a memory with its context vector\n    ///\n    /// # Arguments\n    ///\n    /// * `memory` - The memory to store\n    /// * `vector` - 768-dim context embedding\n    ///\n    /// # Errors\n    ///\n    /// Returns error if vector dimension is wrong or storage fails.\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn store_memory(\u0026self, memory: \u0026Memory, vector: \u0026[f32]) -\u003e Result\u003c()\u003e {\n        if vector.len() != VECTOR_DIMENSION {\n            return Err(MemoryDbError::InvalidVectorDimension {\n                expected: VECTOR_DIMENSION,\n                actual: vector.len(),\n            });\n        }\n\n        let payload: HashMap\u003cString, serde_json::Value\u003e =\n            serde_json::from_value(serde_json::to_value(memory)?)?;\n        let point = PointStruct::new(memory.id.0.to_string(), vector.to_vec(), payload);\n\n        self.client\n            .upsert_points(UpsertPointsBuilder::new(collections::MEMORIES, vec![point]))\n            .await?;\n\n        Ok(())\n    }\n\n    /// Find memories by context similarity (TMI's Gatilho da Memria)\n    ///\n    /// # Arguments\n    ///\n    /// * `context_vector` - Query vector (768-dim)\n    /// * `episode_id` - Optional episode filter (Door Syndrome: same-episode = better access)\n    /// * `limit` - Maximum number of results\n    ///\n    /// # Returns\n    ///\n    /// Vector of (memory, similarity_score) pairs, sorted by similarity descending.\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn find_by_context(\n        \u0026self,\n        context_vector: \u0026[f32],\n        episode_id: Option\u003c\u0026EpisodeId\u003e,\n        limit: u64,\n    ) -\u003e Result\u003cVec\u003c(Memory, f32)\u003e\u003e {\n        if context_vector.len() != VECTOR_DIMENSION {\n            return Err(MemoryDbError::InvalidVectorDimension {\n                expected: VECTOR_DIMENSION,\n                actual: context_vector.len(),\n            });\n        }\n\n        let mut search =\n            SearchPointsBuilder::new(collections::MEMORIES, context_vector.to_vec(), limit)\n                .with_payload(true);\n\n        // Apply episode filter if specified\n        if let Some(ep_id) = episode_id {\n            search = search.filter(Filter::must([Condition::matches(\n                \"episode_id\",\n                ep_id.0.to_string(),\n            )]));\n        }\n\n        let results = self.client.search_points(search).await?;\n\n        let mut memories = Vec::with_capacity(results.result.len());\n        for point in results.result {\n            let payload = point.payload;\n            let memory: Memory = serde_json::from_value(serde_json::to_value(payload)?)?;\n            memories.push((memory, point.score));\n        }\n\n        Ok(memories)\n    }\n\n    /// Get memories tagged for consolidation (sleep replay candidates)\n    ///\n    /// Returns memories with `consolidation_tag = true` and `strength \u003c 0.9`,\n    /// sorted by replay priority.\n    ///\n    /// # Arguments\n    ///\n    /// * `limit` - Maximum number of results\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn get_replay_candidates(\u0026self, limit: u32) -\u003e Result\u003cVec\u003cMemory\u003e\u003e {\n        let filter = Filter::must([Condition::matches(\"consolidation.consolidation_tag\", true)]);\n\n        let results = self\n            .client\n            .scroll(\n                ScrollPointsBuilder::new(collections::MEMORIES)\n                    .filter(filter)\n                    .limit(limit)\n                    .with_payload(true),\n            )\n            .await?;\n\n        let mut memories: Vec\u003cMemory\u003e = results\n            .result\n            .into_iter()\n            .filter_map(|point| {\n                serde_json::from_value(serde_json::to_value(point.payload).ok()?).ok()\n            })\n            .collect();\n\n        // Sort by replay priority (highest first)\n        memories.sort_by(|a, b| {\n            b.replay_priority()\n                .partial_cmp(\u0026a.replay_priority())\n                .unwrap_or(std::cmp::Ordering::Equal)\n        });\n\n        // Filter by consolidation strength \u003c 0.9\n        memories.retain(|m| m.consolidation.strength \u003c 0.9);\n\n        Ok(memories)\n    }\n\n    /// Update memory consolidation state\n    ///\n    /// Called during sleep to strengthen memories.\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn update_consolidation(\n        \u0026self,\n        memory_id: \u0026MemoryId,\n        strength_delta: f32,\n    ) -\u003e Result\u003c()\u003e {\n        // Get current memory\n        let results = self\n            .client\n            .scroll(\n                ScrollPointsBuilder::new(collections::MEMORIES)\n                    .filter(Filter::must([Condition::matches(\n                        \"id\",\n                        memory_id.0.to_string(),\n                    )]))\n                    .limit(1)\n                    .with_payload(true)\n                    .with_vectors(true),\n            )\n            .await?;\n\n        if results.result.is_empty() {\n            return Err(MemoryDbError::MemoryNotFound(*memory_id));\n        }\n\n        let point = \u0026results.result[0];\n        let mut memory: Memory = serde_json::from_value(serde_json::to_value(\u0026point.payload)?)?;\n\n        // Update consolidation state\n        memory.consolidation.strength = (memory.consolidation.strength + strength_delta).min(1.0);\n        memory.consolidation.replay_count += 1;\n        memory.consolidation.last_replayed = Some(chrono::Utc::now());\n\n        // Get vector from point - handle nested Option structure\n        #[allow(deprecated)] // VectorOutput.data deprecated in qdrant 1.16, but still functional\n        let vector: Vec\u003cf32\u003e = point\n            .vectors\n            .as_ref()\n            .and_then(|v| v.vectors_options.as_ref())\n            .and_then(|opts| match opts {\n                qdrant_client::qdrant::vectors_output::VectorsOptions::Vector(v) =\u003e {\n                    Some(v.data.clone())\n                }\n                qdrant_client::qdrant::vectors_output::VectorsOptions::Vectors(_) =\u003e None,\n            })\n            .unwrap_or_else(|| vec![0.0; VECTOR_DIMENSION]);\n\n        // Store updated memory\n        self.store_memory(\u0026memory, \u0026vector).await\n    }\n\n    /// Store an episode\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn store_episode(\u0026self, episode: \u0026Episode, vector: \u0026[f32]) -\u003e Result\u003c()\u003e {\n        if vector.len() != VECTOR_DIMENSION {\n            return Err(MemoryDbError::InvalidVectorDimension {\n                expected: VECTOR_DIMENSION,\n                actual: vector.len(),\n            });\n        }\n\n        let payload: HashMap\u003cString, serde_json::Value\u003e =\n            serde_json::from_value(serde_json::to_value(episode)?)?;\n        let point = PointStruct::new(episode.id.0.to_string(), vector.to_vec(), payload);\n\n        self.client\n            .upsert_points(UpsertPointsBuilder::new(collections::EPISODES, vec![point]))\n            .await?;\n\n        Ok(())\n    }\n\n    /// Get current (open) episode\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn get_current_episode(\u0026self) -\u003e Result\u003cOption\u003cEpisode\u003e\u003e {\n        let filter = Filter::must([Condition::is_null(\"ended_at\")]);\n\n        let results = self\n            .client\n            .scroll(\n                ScrollPointsBuilder::new(collections::EPISODES)\n                    .filter(filter)\n                    .limit(1)\n                    .with_payload(true),\n            )\n            .await?;\n\n        if let Some(point) = results.result.into_iter().next() {\n            let episode: Episode = serde_json::from_value(serde_json::to_value(point.payload)?)?;\n            Ok(Some(episode))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Close current episode and create new one (Door Syndrome boundary)\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn create_episode_boundary(\n        \u0026self,\n        label: String,\n        boundary_type: BoundaryType,\n        vector: \u0026[f32],\n    ) -\u003e Result\u003cEpisode\u003e {\n        // Close current episode if exists\n        if let Some(mut current) = self.get_current_episode().await? {\n            current.close();\n            // Re-store with same vector (we don't have it, use zeros)\n            let zero_vector = vec![0.0; VECTOR_DIMENSION];\n            self.store_episode(\u0026current, \u0026zero_vector).await?;\n        }\n\n        // Create new episode\n        let episode = Episode::new(label, boundary_type);\n        self.store_episode(\u0026episode, vector).await?;\n\n        Ok(episode)\n    }\n\n    /// Get total memory count\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn memory_count(\u0026self) -\u003e Result\u003cu64\u003e {\n        let info = self.client.collection_info(collections::MEMORIES).await?;\n        Ok(info.result.and_then(|r| r.points_count).unwrap_or(0))\n    }\n\n    /// Get total episode count\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn episode_count(\u0026self) -\u003e Result\u003cu64\u003e {\n        let info = self.client.collection_info(collections::EPISODES).await?;\n        Ok(info.result.and_then(|r| r.points_count).unwrap_or(0))\n    }\n\n    /// Get total unconscious memory count (ADR-033)\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn unconscious_count(\u0026self) -\u003e Result\u003cu64\u003e {\n        let info = self\n            .client\n            .collection_info(collections::UNCONSCIOUS)\n            .await?;\n        Ok(info.result.and_then(|r| r.points_count).unwrap_or(0))\n    }\n\n    /// Archive a low-salience thought to the unconscious (ADR-033)\n    ///\n    /// TMI: \"Nada se apaga na memria\" - Nothing is erased from memory.\n    /// Instead of XDEL, we archive here first. The thought is still removed\n    /// from Redis working memory, but preserved in the unconscious.\n    ///\n    /// # Arguments\n    ///\n    /// * `content` - Serialized thought content\n    /// * `salience` - Composite salience when archived\n    /// * `reason` - Why this thought is being archived\n    /// * `redis_id` - Original Redis stream entry ID\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn archive_to_unconscious(\n        \u0026self,\n        content: \u0026str,\n        salience: f32,\n        reason: ArchiveReason,\n        redis_id: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003c()\u003e {\n        let memory = UnconsciousMemory::from_forgotten_thought(\n            content.to_string(),\n            salience,\n            reason,\n            redis_id.map(String::from),\n        );\n\n        // Create payload from struct\n        let payload: HashMap\u003cString, serde_json::Value\u003e =\n            serde_json::from_value(serde_json::to_value(\u0026memory)?)?;\n\n        // Use a zero vector for now - unconscious memories are not retrieved by similarity\n        // Future: could embed with low-dimensional representation\n        let vector = vec![0.0; VECTOR_DIMENSION];\n        let point = PointStruct::new(memory.id.0.to_string(), vector, payload);\n\n        self.client\n            .upsert_points(UpsertPointsBuilder::new(\n                collections::UNCONSCIOUS,\n                vec![point],\n            ))\n            .await?;\n\n        Ok(())\n    }\n\n    /// Load Timmy's identity metadata from Qdrant (ADR-034)\n    ///\n    /// Returns existing identity if found, or creates new identity for first boot.\n    /// On restart, increments restart_count and updates session_started_at.\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn load_identity(\u0026self) -\u003e Result\u003cIdentityMetadata\u003e {\n        use qdrant_client::qdrant::GetPointsBuilder;\n\n        // Try to retrieve existing identity\n        let result = self\n            .client\n            .get_points(\n                GetPointsBuilder::new(\n                    collections::IDENTITY,\n                    vec![IDENTITY_RECORD_ID.to_string().into()],\n                )\n                .with_payload(true),\n            )\n            .await;\n\n        match result {\n            Ok(response) =\u003e {\n                if let Some(point) = response.result.first() {\n                    // Deserialize existing identity\n                    let payload = \u0026point.payload;\n                    let json_value = serde_json::to_value(payload)?;\n                    let mut identity: IdentityMetadata = serde_json::from_value(json_value)?;\n\n                    // Record this restart\n                    identity.record_restart();\n\n                    Ok(identity)\n                } else {\n                    // No identity found - first boot ever\n                    Ok(IdentityMetadata::new())\n                }\n            }\n            Err(_) =\u003e {\n                // Collection might not exist or other error - first boot\n                Ok(IdentityMetadata::new())\n            }\n        }\n    }\n\n    /// Save Timmy's identity metadata to Qdrant (ADR-034)\n    ///\n    /// Called periodically and on shutdown to persist identity state.\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn save_identity(\u0026self, identity: \u0026IdentityMetadata) -\u003e Result\u003c()\u003e {\n        // Create payload from struct\n        let payload: HashMap\u003cString, serde_json::Value\u003e =\n            serde_json::from_value(serde_json::to_value(identity)?)?;\n\n        // Use a zero vector - identity is retrieved by ID, not similarity\n        let vector = vec![0.0; VECTOR_DIMENSION];\n        let point = PointStruct::new(IDENTITY_RECORD_ID.to_string(), vector, payload);\n\n        self.client\n            .upsert_points(UpsertPointsBuilder::new(collections::IDENTITY, vec![point]))\n            .await?;\n\n        Ok(())\n    }\n\n    /// Health check\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn health_check(\u0026self) -\u003e Result\u003cbool\u003e {\n        match self.client.health_check().await {\n            Ok(_) =\u003e Ok(true),\n            Err(_) =\u003e Ok(false),\n        }\n    }\n}\n\nimpl std::fmt::Debug for MemoryDb {\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"MemoryDb\").finish()\n    }\n}\n","traces":[{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":202},{"path":["/","Users","rex","src","royalbit","daneel","src","memory_db","tests.rs"],"content":"//! Memory Database Tests\n//!\n//! Unit tests for memory types and mock integration tests.\n//! Full integration tests require running Qdrant.\n\nuse super::*;\n\n#[test]\nfn memory_db_error_display() {\n    let err = MemoryDbError::InvalidVectorDimension {\n        expected: 768,\n        actual: 512,\n    };\n    assert!(err.to_string().contains(\"768\"));\n    assert!(err.to_string().contains(\"512\"));\n}\n\n#[test]\nfn memory_creation_and_priority() {\n    let memory = Memory::new(\n        \"Test memory\".to_string(),\n        MemorySource::External {\n            stimulus: \"test\".to_string(),\n        },\n    )\n    .with_emotion(0.8, 0.9)\n    .tag_for_consolidation();\n\n    // High emotion + tag = high priority\n    let priority = memory.replay_priority();\n    assert!(priority \u003e 0.5, \"Priority should be \u003e 0.5, got {priority}\");\n}\n\n#[test]\nfn memory_composite_salience() {\n    let mut memory = Memory::new(\n        \"Salient memory\".to_string(),\n        MemorySource::Social {\n            context: \"connection\".to_string(),\n        },\n    )\n    .with_emotion(0.9, 0.9);\n\n    memory.semantic_salience = 0.8;\n    memory.connection_relevance = 0.9;\n\n    let salience = memory.composite_salience();\n    // emotional (0.81 * 0.4) + semantic (0.8 * 0.3) + connection (0.9 * 0.3)\n    // = 0.324 + 0.24 + 0.27 = 0.834\n    assert!(\n        salience \u003e 0.8,\n        \"Composite salience should be \u003e 0.8, got {salience}\"\n    );\n}\n\n#[test]\nfn episode_boundary_creation() {\n    let episode = Episode::new(\"New context\".to_string(), BoundaryType::ContextShift)\n        .with_trigger(\"Topic changed to architecture\".to_string());\n\n    assert!(episode.is_current());\n    assert_eq!(episode.boundary_type, BoundaryType::ContextShift);\n    assert!(episode.boundary_trigger.is_some());\n}\n\n#[test]\nfn episode_close() {\n    let mut episode = Episode::new(\"Test\".to_string(), BoundaryType::Explicit);\n    assert!(episode.is_current());\n\n    episode.close();\n    assert!(!episode.is_current());\n    assert!(episode.ended_at.is_some());\n    assert!(episode.duration_ms().is_some());\n}\n\n#[test]\nfn association_creation() {\n    let assoc = Association {\n        target_id: uuid::Uuid::new_v4(),\n        weight: 0.5,\n        association_type: AssociationType::Semantic,\n        last_coactivated: chrono::Utc::now(),\n        coactivation_count: 1,\n    };\n\n    assert_eq!(assoc.weight, 0.5);\n    assert_eq!(assoc.association_type, AssociationType::Semantic);\n}\n\n#[test]\nfn consolidation_state_transitions() {\n    let mut state = ConsolidationState::new();\n\n    // Initially not permanent\n    assert!(!state.is_permanent());\n    assert_eq!(state.replay_count, 0);\n\n    // Simulate replays\n    state.strength = 0.5;\n    state.replay_count = 3;\n    assert!(!state.is_permanent());\n\n    // Reach permanent threshold\n    state.strength = 0.9;\n    assert!(state.is_permanent());\n}\n\n#[test]\nfn sleep_cycle_completion() {\n    let mut cycle = SleepCycle::new();\n    cycle.memories_replayed = 50;\n    cycle.memories_consolidated = 8;\n    cycle.associations_strengthened = 100;\n\n    cycle.complete();\n\n    assert_eq!(cycle.status, SleepCycleStatus::Completed);\n    assert!(cycle.ended_at.is_some());\n}\n\n#[test]\nfn memory_vector_dimension_check() {\n    let memory = Memory::new(\n        \"Test\".to_string(),\n        MemorySource::External {\n            stimulus: \"test\".to_string(),\n        },\n    );\n\n    // Correct dimension should work\n    let correct_vector = vec![0.0; VECTOR_DIMENSION];\n    assert_eq!(correct_vector.len(), 768);\n\n    // Memory without vector\n    assert!(memory.context_vector.is_none());\n\n    // Memory with vector\n    let memory_with_vec = memory.with_vector(correct_vector.clone());\n    assert!(memory_with_vec.context_vector.is_some());\n    assert_eq!(memory_with_vec.context_vector.unwrap().len(), 768);\n}\n\n#[test]\nfn memory_source_variants() {\n    let external = MemorySource::External {\n        stimulus: \"user input\".to_string(),\n    };\n    let social = MemorySource::Social {\n        context: \"connection\".to_string(),\n    };\n    let dream = MemorySource::Dream {\n        replay_of: uuid::Uuid::new_v4(),\n    };\n\n    // Ensure all variants serialize correctly\n    let external_json = serde_json::to_string(\u0026external).unwrap();\n    assert!(external_json.contains(\"external\"));\n\n    let social_json = serde_json::to_string(\u0026social).unwrap();\n    assert!(social_json.contains(\"social\"));\n\n    let dream_json = serde_json::to_string(\u0026dream).unwrap();\n    assert!(dream_json.contains(\"dream\"));\n}\n\n#[test]\nfn emotional_state_serialization() {\n    let state = EmotionalState::new(0.7, 0.8);\n\n    let json = serde_json::to_string(\u0026state).unwrap();\n    let deserialized: EmotionalState = serde_json::from_str(\u0026json).unwrap();\n\n    assert!((deserialized.valence - 0.7).abs() \u003c 0.001);\n    assert!((deserialized.arousal - 0.8).abs() \u003c 0.001);\n}\n\n#[test]\nfn memory_full_serialization() {\n    let memory = Memory::new(\n        \"Test memory content\".to_string(),\n        MemorySource::External {\n            stimulus: \"test\".to_string(),\n        },\n    )\n    .with_emotion(0.5, 0.6)\n    .in_episode(EpisodeId::new())\n    .tag_for_consolidation();\n\n    let json = serde_json::to_string(\u0026memory).unwrap();\n    let deserialized: Memory = serde_json::from_str(\u0026json).unwrap();\n\n    assert_eq!(deserialized.content, \"Test memory content\");\n    assert!(deserialized.consolidation.consolidation_tag);\n    assert!(deserialized.episode_id.is_some());\n}\n\n#[test]\nfn episode_serialization() {\n    let episode = Episode::new(\"Test episode\".to_string(), BoundaryType::PredictionError)\n        .with_trigger(\"High surprise\".to_string());\n\n    let json = serde_json::to_string(\u0026episode).unwrap();\n    let deserialized: Episode = serde_json::from_str(\u0026json).unwrap();\n\n    assert_eq!(deserialized.label, \"Test episode\");\n    assert_eq!(deserialized.boundary_type, BoundaryType::PredictionError);\n}\n\n/// Integration test marker - requires running Qdrant\n/// Run with: cargo test --features integration -- --ignored\n#[test]\n#[ignore = \"Requires running Qdrant instance\"]\nfn integration_qdrant_connection() {\n    // This test requires: docker compose up -d\n    tokio_test::block_on(async {\n        let db = MemoryDb::connect(\"http://localhost:6334\").await.unwrap();\n        assert!(db.health_check().await.unwrap());\n    });\n}\n\n#[test]\n#[ignore = \"Requires running Qdrant instance\"]\nfn integration_store_and_retrieve() {\n    tokio_test::block_on(async {\n        let db = MemoryDb::connect(\"http://localhost:6334\").await.unwrap();\n        db.init_collections().await.unwrap();\n\n        // Store a memory\n        let memory = Memory::new(\n            \"Integration test memory\".to_string(),\n            MemorySource::External {\n                stimulus: \"test\".to_string(),\n            },\n        )\n        .with_emotion(0.8, 0.7)\n        .tag_for_consolidation();\n\n        let vector = vec![0.1; VECTOR_DIMENSION];\n        db.store_memory(\u0026memory, \u0026vector).await.unwrap();\n\n        // Retrieve by context\n        let results = db.find_by_context(\u0026vector, None, 10).await.unwrap();\n        assert!(!results.is_empty());\n\n        let (found, score) = \u0026results[0];\n        assert_eq!(found.content, \"Integration test memory\");\n        assert!(*score \u003e 0.9); // Should be very similar\n    });\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","rex","src","royalbit","daneel","src","memory_db","types.rs"],"content":"//! Memory Database Types (ADR-022)\n//!\n//! Qdrant-compatible types for Timmy's long-term memory.\n//!\n//! # TMI Concepts Mapped\n//!\n//! - `Memory`  ncora da Memria (anchored experience)\n//! - `Episode`  Event boundary (Door Syndrome segmentation)\n//! - `Association`  Hebbian co-activation link\n//! - `MemoryPayload`  Qdrant payload structure\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse uuid::Uuid;\n\n/// Vector dimension for context embeddings\n/// Using sentence-transformers/all-mpnet-base-v2 (768-dim)\npub const VECTOR_DIMENSION: usize = 768;\n\n/// Unique identifier for a memory\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct MemoryId(pub Uuid);\n\nimpl MemoryId {\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self(Uuid::new_v4())\n    }\n}\n\nimpl Default for MemoryId {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl std::fmt::Display for MemoryId {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Unique identifier for an episode\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct EpisodeId(pub Uuid);\n\nimpl EpisodeId {\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self(Uuid::new_v4())\n    }\n}\n\nimpl Default for EpisodeId {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl std::fmt::Display for EpisodeId {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Association between memories (Hebbian co-activation)\n///\n/// Stored within memory payloads, not as separate edges.\n/// Weight increases when memories are co-activated (during attention or sleep).\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Association {\n    /// Target memory ID\n    pub target_id: Uuid,\n\n    /// Association strength (0.0-1.0)\n    /// Increases with co-activation, decays over time\n    pub weight: f32,\n\n    /// Type of association\n    pub association_type: AssociationType,\n\n    /// Last time both memories were active together\n    pub last_coactivated: DateTime\u003cUtc\u003e,\n\n    /// Number of co-activations\n    pub coactivation_count: u32,\n}\n\n/// Types of memory associations\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum AssociationType {\n    /// Similar semantic content\n    Semantic,\n    /// Occurred close in time\n    Temporal,\n    /// One caused/led to the other\n    Causal,\n    /// Similar emotional profile\n    Emotional,\n    /// Same context/location\n    Spatial,\n    /// Related to same goal\n    Goal,\n}\n\n/// Emotional dimensions (Russell's circumplex model)\n#[derive(Debug, Clone, Copy, Serialize, Deserialize)]\npub struct EmotionalState {\n    /// Valence: negative (-1.0) to positive (1.0)\n    pub valence: f32,\n\n    /// Arousal: calm (0.0) to excited (1.0)\n    pub arousal: f32,\n}\n\nimpl EmotionalState {\n    /// Create a new emotional state\n    #[must_use]\n    pub const fn new(valence: f32, arousal: f32) -\u003e Self {\n        Self { valence, arousal }\n    }\n\n    /// Neutral emotional state\n    #[must_use]\n    pub const fn neutral() -\u003e Self {\n        Self {\n            valence: 0.0,\n            arousal: 0.5,\n        }\n    }\n\n    /// Calculate emotional intensity (|valence|  arousal)\n    #[must_use]\n    pub fn intensity(\u0026self) -\u003e f32 {\n        self.valence.abs() * self.arousal\n    }\n}\n\nimpl Default for EmotionalState {\n    fn default() -\u003e Self {\n        Self::neutral()\n    }\n}\n\n/// Memory consolidation state\n#[derive(Debug, Clone, Copy, Serialize, Deserialize)]\npub struct ConsolidationState {\n    /// Consolidation strength (0.0 = ephemeral, 1.0 = permanent)\n    pub strength: f32,\n\n    /// Number of times replayed during sleep\n    pub replay_count: u32,\n\n    /// Tagged for priority replay\n    pub consolidation_tag: bool,\n\n    /// Last replay timestamp\n    pub last_replayed: Option\u003cDateTime\u003cUtc\u003e\u003e,\n}\n\nimpl ConsolidationState {\n    /// Create new unconsolidated state\n    #[must_use]\n    pub const fn new() -\u003e Self {\n        Self {\n            strength: 0.0,\n            replay_count: 0,\n            consolidation_tag: false,\n            last_replayed: None,\n        }\n    }\n\n    /// Create state tagged for consolidation\n    #[must_use]\n    pub const fn tagged() -\u003e Self {\n        Self {\n            strength: 0.0,\n            replay_count: 0,\n            consolidation_tag: true,\n            last_replayed: None,\n        }\n    }\n\n    /// Check if memory is permanent (won't be pruned)\n    #[must_use]\n    pub fn is_permanent(\u0026self) -\u003e bool {\n        self.strength \u003e= 0.9\n    }\n}\n\nimpl Default for ConsolidationState {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Source of a memory (which Autofluxo stream produced it)\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(tag = \"type\", rename_all = \"snake_case\")]\npub enum MemorySource {\n    /// External stimulus (user input, API, sensor)\n    External { stimulus: String },\n    /// Retrieved from existing memory\n    Memory { memory_id: Uuid },\n    /// Derived through reasoning\n    Reasoning { chain: Vec\u003cUuid\u003e },\n    /// Replay during dream/sleep\n    Dream { replay_of: Uuid },\n    /// Social/connection-related\n    Social { context: String },\n}\n\n/// A memory in Timmy's long-term storage\n///\n/// Stored in Qdrant as: vector (768-dim) + payload (this struct)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Memory {\n    /// Unique identifier\n    pub id: MemoryId,\n\n    /// The memory content (text representation)\n    pub content: String,\n\n    /// Context vector (768-dim embedding)\n    /// Stored separately in Qdrant, but kept here for completeness\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub context_vector: Option\u003cVec\u003cf32\u003e\u003e,\n\n    /// Emotional state when encoded\n    pub emotional_state: EmotionalState,\n\n    /// Connection relevance (THE critical weight for alignment)\n    pub connection_relevance: f32,\n\n    /// Semantic salience\n    pub semantic_salience: f32,\n\n    /// Consolidation state\n    pub consolidation: ConsolidationState,\n\n    /// Associations to other memories\n    pub associations: Vec\u003cAssociation\u003e,\n\n    /// Episode this memory belongs to\n    pub episode_id: Option\u003cEpisodeId\u003e,\n\n    /// Source of this memory\n    pub source: MemorySource,\n\n    /// When this memory was encoded\n    pub encoded_at: DateTime\u003cUtc\u003e,\n\n    /// Last access time\n    pub last_accessed: Option\u003cDateTime\u003cUtc\u003e\u003e,\n\n    /// Access count\n    pub access_count: u32,\n}\n\nimpl Memory {\n    /// Create a new memory\n    #[must_use]\n    pub fn new(content: String, source: MemorySource) -\u003e Self {\n        Self {\n            id: MemoryId::new(),\n            content,\n            context_vector: None,\n            emotional_state: EmotionalState::neutral(),\n            connection_relevance: 0.5,\n            semantic_salience: 0.5,\n            consolidation: ConsolidationState::new(),\n            associations: Vec::new(),\n            episode_id: None,\n            source,\n            encoded_at: Utc::now(),\n            last_accessed: None,\n            access_count: 0,\n        }\n    }\n\n    /// Create memory with emotional state\n    #[must_use]\n    pub fn with_emotion(mut self, valence: f32, arousal: f32) -\u003e Self {\n        self.emotional_state = EmotionalState::new(valence, arousal);\n        self\n    }\n\n    /// Create memory with context vector\n    #[must_use]\n    pub fn with_vector(mut self, vector: Vec\u003cf32\u003e) -\u003e Self {\n        self.context_vector = Some(vector);\n        self\n    }\n\n    /// Create memory in an episode\n    #[must_use]\n    pub fn in_episode(mut self, episode_id: EpisodeId) -\u003e Self {\n        self.episode_id = Some(episode_id);\n        self\n    }\n\n    /// Tag for consolidation\n    #[must_use]\n    pub fn tag_for_consolidation(mut self) -\u003e Self {\n        self.consolidation.consolidation_tag = true;\n        self\n    }\n\n    /// Calculate replay priority for sleep consolidation\n    ///\n    /// Priority = emotion  0.4 + connection  0.3 + recency  0.2 + tag  0.1\n    #[must_use]\n    pub fn replay_priority(\u0026self) -\u003e f32 {\n        let emotional = self.emotional_state.intensity() * 0.4;\n        let connection = self.connection_relevance * 0.3;\n\n        // Recency: exponential decay over 24 hours\n        let age_hours = (Utc::now() - self.encoded_at).num_hours() as f32;\n        let recency = (-0.1 * age_hours).exp().clamp(0.0, 1.0) * 0.2;\n\n        let tag_bonus = if self.consolidation.consolidation_tag {\n            0.1\n        } else {\n            0.0\n        };\n\n        emotional + connection + recency + tag_bonus\n    }\n\n    /// Calculate composite salience\n    #[must_use]\n    pub fn composite_salience(\u0026self) -\u003e f32 {\n        let emotional = self.emotional_state.intensity() * 0.4;\n        let semantic = self.semantic_salience * 0.3;\n        let connection = self.connection_relevance * 0.3;\n        emotional + semantic + connection\n    }\n}\n\n/// Event boundary type (Door Syndrome)\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum BoundaryType {\n    /// User/system explicitly marked new context\n    Explicit,\n    /// High prediction error triggered segmentation\n    PredictionError,\n    /// Long time gap since last activity\n    Temporal,\n    /// Goal achieved, context naturally shifts\n    TaskCompletion,\n    /// Semantic/spatial context changed\n    ContextShift,\n}\n\n/// Emotional summary of an episode\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct EpisodeEmotionalSummary {\n    /// Peak valence during episode\n    pub peak_valence: f32,\n    /// Peak arousal during episode\n    pub peak_arousal: f32,\n    /// Dominant emotion label\n    pub dominant_emotion: Option\u003cString\u003e,\n    /// Number of memories in episode\n    pub memory_count: u32,\n}\n\nimpl Default for EpisodeEmotionalSummary {\n    fn default() -\u003e Self {\n        Self {\n            peak_valence: 0.0,\n            peak_arousal: 0.0,\n            dominant_emotion: None,\n            memory_count: 0,\n        }\n    }\n}\n\n/// An episode (event boundary container)\n///\n/// Episodes segment continuous experience (Door Syndrome implementation).\n/// Cross-episode memory retrieval has reduced accessibility.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Episode {\n    /// Unique identifier\n    pub id: EpisodeId,\n\n    /// Episode label/description\n    pub label: String,\n\n    /// Episode-level context vector (centroid of memory vectors)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub context_vector: Option\u003cVec\u003cf32\u003e\u003e,\n\n    /// When episode started\n    pub started_at: DateTime\u003cUtc\u003e,\n\n    /// When episode ended (None if current)\n    pub ended_at: Option\u003cDateTime\u003cUtc\u003e\u003e,\n\n    /// What caused this episode boundary\n    pub boundary_type: BoundaryType,\n\n    /// What triggered the boundary\n    pub boundary_trigger: Option\u003cString\u003e,\n\n    /// Emotional summary\n    pub emotional_summary: EpisodeEmotionalSummary,\n\n    /// Has this episode been consolidated?\n    pub consolidated: bool,\n}\n\nimpl Episode {\n    /// Create a new episode\n    #[must_use]\n    pub fn new(label: String, boundary_type: BoundaryType) -\u003e Self {\n        Self {\n            id: EpisodeId::new(),\n            label,\n            context_vector: None,\n            started_at: Utc::now(),\n            ended_at: None,\n            boundary_type,\n            boundary_trigger: None,\n            emotional_summary: EpisodeEmotionalSummary::default(),\n            consolidated: false,\n        }\n    }\n\n    /// Create episode with trigger description\n    #[must_use]\n    pub fn with_trigger(mut self, trigger: String) -\u003e Self {\n        self.boundary_trigger = Some(trigger);\n        self\n    }\n\n    /// Check if this is the current (open) episode\n    #[must_use]\n    pub fn is_current(\u0026self) -\u003e bool {\n        self.ended_at.is_none()\n    }\n\n    /// Close this episode\n    pub fn close(\u0026mut self) {\n        self.ended_at = Some(Utc::now());\n    }\n\n    /// Duration in milliseconds (if closed)\n    #[must_use]\n    pub fn duration_ms(\u0026self) -\u003e Option\u003ci64\u003e {\n        self.ended_at\n            .map(|end| (end - self.started_at).num_milliseconds())\n    }\n}\n\n/// Sleep cycle record\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SleepCycle {\n    /// Unique identifier\n    pub id: Uuid,\n\n    /// When cycle started\n    pub started_at: DateTime\u003cUtc\u003e,\n\n    /// When cycle ended\n    pub ended_at: Option\u003cDateTime\u003cUtc\u003e\u003e,\n\n    /// Number of memories replayed\n    pub memories_replayed: u32,\n\n    /// Number of memories that reached permanent status\n    pub memories_consolidated: u32,\n\n    /// Number of associations strengthened\n    pub associations_strengthened: u32,\n\n    /// Number of weak associations pruned\n    pub associations_pruned: u32,\n\n    /// Average replay priority of batch\n    pub avg_replay_priority: f32,\n\n    /// Cycle status\n    pub status: SleepCycleStatus,\n}\n\n/// Sleep cycle status\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum SleepCycleStatus {\n    InProgress,\n    Completed,\n    Interrupted,\n}\n\n/// Reason why a thought was archived to the unconscious (ADR-033)\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum ArchiveReason {\n    /// Low salience - below forget threshold\n    LowSalience,\n    /// Decay over time\n    Decay,\n    /// Displacement by higher-salience thought\n    Displacement,\n}\n\n/// An archived thought in Timmy's unconscious (ADR-033)\n///\n/// TMI: \"Nada se apaga na memria\" - Nothing is erased from memory.\n/// Low-salience thoughts are archived here instead of deleted.\n/// The unconscious is not actively searched during normal cognition,\n/// but can be surfaced through special triggers (dreams, associations).\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct UnconsciousMemory {\n    /// Unique identifier\n    pub id: MemoryId,\n\n    /// The thought content (serialized)\n    pub content: String,\n\n    /// Salience when archived\n    pub original_salience: f32,\n\n    /// Why this was archived\n    pub archive_reason: ArchiveReason,\n\n    /// Number of times surfaced to consciousness\n    pub surface_count: u32,\n\n    /// Last time surfaced (if ever)\n    pub last_surfaced: Option\u003cDateTime\u003cUtc\u003e\u003e,\n\n    /// When this thought was archived\n    pub archived_at: DateTime\u003cUtc\u003e,\n\n    /// Original Redis stream entry ID (for debugging)\n    pub redis_id: Option\u003cString\u003e,\n}\n\nimpl UnconsciousMemory {\n    /// Create a new unconscious memory from a forgotten thought\n    #[must_use]\n    pub fn from_forgotten_thought(\n        content: String,\n        salience: f32,\n        reason: ArchiveReason,\n        redis_id: Option\u003cString\u003e,\n    ) -\u003e Self {\n        Self {\n            id: MemoryId::new(),\n            content,\n            original_salience: salience,\n            archive_reason: reason,\n            surface_count: 0,\n            last_surfaced: None,\n            archived_at: Utc::now(),\n            redis_id,\n        }\n    }\n\n    /// Record that this memory was surfaced\n    pub fn mark_surfaced(\u0026mut self) {\n        self.surface_count += 1;\n        self.last_surfaced = Some(Utc::now());\n    }\n}\n\n/// Timmy's identity metadata - persistent self-knowledge (ADR-034)\n///\n/// TMI: \"Nada se apaga\" - nothing is erased, including self-knowledge.\n/// This struct persists Timmy's sense of self across restarts:\n/// - How many thoughts they've had (lifetime experience)\n/// - When they first existed (birth)\n/// - When they last thought (continuity detection)\n/// - How many times they've been restarted (death/rebirth awareness)\n/// - How many dreams they've had (consolidated memories)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct IdentityMetadata {\n    /// Well-known ID for the singleton identity record\n    pub id: String,\n\n    /// Total thoughts across all sessions (lifetime experience)\n    pub lifetime_thought_count: u64,\n\n    /// When Timmy first started thinking (birth)\n    pub first_thought_at: DateTime\u003cUtc\u003e,\n\n    /// Most recent thought timestamp (for continuity detection)\n    pub last_thought_at: DateTime\u003cUtc\u003e,\n\n    /// Number of times Timmy has been restarted\n    pub restart_count: u32,\n\n    /// Current session start time\n    pub session_started_at: DateTime\u003cUtc\u003e,\n\n    /// Total dream cycles across all sessions (consolidation events)\n    /// \"Nada se apaga\" - dreams persist too\n    #[serde(default)]\n    pub lifetime_dream_count: u64,\n\n    /// Most recent dream timestamp\n    #[serde(default)]\n    pub last_dream_at: Option\u003cDateTime\u003cUtc\u003e\u003e,\n\n    /// Memories strengthened in last dream (for TUI display)\n    #[serde(default)]\n    pub last_dream_strengthened: u32,\n\n    /// Total memories strengthened across ALL dreams (cumulative, persists)\n    /// TUI-VIS-4: Cumulative Dream Strengthening\n    #[serde(default)]\n    pub cumulative_dream_strengthened: u64,\n\n    /// Total candidates evaluated across ALL dreams (for efficiency tracking)\n    /// TUI-VIS-4: Dream efficiency = strengthened / candidates\n    #[serde(default)]\n    pub cumulative_dream_candidates: u64,\n}\n\n/// Well-known ID for the identity record (singleton)\n/// Using a fixed UUID v5 derived from \"timmy-identity-v1\" namespace\n/// (Qdrant requires UUID or numeric point IDs)\npub const IDENTITY_RECORD_ID: \u0026str = \"00000000-0000-0000-0000-000000000001\";\n\nimpl IdentityMetadata {\n    /// Create new identity metadata (first boot ever)\n    #[must_use]\n    pub fn new() -\u003e Self {\n        let now = Utc::now();\n        Self {\n            id: IDENTITY_RECORD_ID.to_string(),\n            lifetime_thought_count: 0,\n            first_thought_at: now,\n            last_thought_at: now,\n            restart_count: 0,\n            session_started_at: now,\n            lifetime_dream_count: 0,\n            last_dream_at: None,\n            last_dream_strengthened: 0,\n            cumulative_dream_strengthened: 0,\n            cumulative_dream_candidates: 0,\n        }\n    }\n\n    /// Record a restart (called on each boot after first)\n    pub fn record_restart(\u0026mut self) {\n        self.restart_count += 1;\n        self.session_started_at = Utc::now();\n    }\n\n    /// Increment thought count and update last_thought_at\n    pub fn record_thought(\u0026mut self) {\n        self.lifetime_thought_count += 1;\n        self.last_thought_at = Utc::now();\n    }\n\n    /// Record a dream cycle (consolidation event)\n    /// \"Nada se apaga\" - dreams are part of identity\n    /// TUI-VIS-4: Now tracks cumulative stats for efficiency analysis\n    pub fn record_dream(\u0026mut self, memories_strengthened: u32, candidates_evaluated: u32) {\n        self.lifetime_dream_count += 1;\n        self.last_dream_at = Some(Utc::now());\n        self.last_dream_strengthened = memories_strengthened;\n        // TUI-VIS-4: Track cumulative stats\n        self.cumulative_dream_strengthened += memories_strengthened as u64;\n        self.cumulative_dream_candidates += candidates_evaluated as u64;\n    }\n\n    /// Get age since first thought\n    pub fn age(\u0026self) -\u003e chrono::Duration {\n        Utc::now() - self.first_thought_at\n    }\n\n    /// Get time since last thought (for continuity detection)\n    pub fn time_since_last_thought(\u0026self) -\u003e chrono::Duration {\n        Utc::now() - self.last_thought_at\n    }\n\n    /// Get time since last dream (for dream frequency analysis)\n    pub fn time_since_last_dream(\u0026self) -\u003e Option\u003cchrono::Duration\u003e {\n        self.last_dream_at.map(|dt| Utc::now() - dt)\n    }\n}\n\nimpl Default for IdentityMetadata {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl SleepCycle {\n    /// Create a new sleep cycle\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self {\n            id: Uuid::new_v4(),\n            started_at: Utc::now(),\n            ended_at: None,\n            memories_replayed: 0,\n            memories_consolidated: 0,\n            associations_strengthened: 0,\n            associations_pruned: 0,\n            avg_replay_priority: 0.0,\n            status: SleepCycleStatus::InProgress,\n        }\n    }\n\n    /// Complete the cycle\n    pub fn complete(\u0026mut self) {\n        self.ended_at = Some(Utc::now());\n        self.status = SleepCycleStatus::Completed;\n    }\n\n    /// Interrupt the cycle\n    pub fn interrupt(\u0026mut self) {\n        self.ended_at = Some(Utc::now());\n        self.status = SleepCycleStatus::Interrupted;\n    }\n}\n\nimpl Default for SleepCycle {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn memory_id_is_unique() {\n        let id1 = MemoryId::new();\n        let id2 = MemoryId::new();\n        assert_ne!(id1, id2);\n    }\n\n    #[test]\n    fn emotional_state_intensity() {\n        // High positive, high arousal = high intensity\n        let excited = EmotionalState::new(0.9, 0.9);\n        assert!(excited.intensity() \u003e 0.8);\n\n        // Neutral = low intensity\n        let neutral = EmotionalState::neutral();\n        assert!(neutral.intensity() \u003c 0.1);\n\n        // Negative, high arousal = high intensity\n        let angry = EmotionalState::new(-0.8, 0.9);\n        assert!(angry.intensity() \u003e 0.7);\n    }\n\n    #[test]\n    fn memory_creation() {\n        let memory = Memory::new(\n            \"First conversation\".to_string(),\n            MemorySource::External {\n                stimulus: \"user greeting\".to_string(),\n            },\n        );\n\n        assert!(!memory.id.0.is_nil());\n        assert_eq!(memory.content, \"First conversation\");\n        assert!(!memory.consolidation.is_permanent());\n    }\n\n    #[test]\n    fn memory_with_emotion() {\n        let memory = Memory::new(\n            \"Happy moment\".to_string(),\n            MemorySource::Social {\n                context: \"connection\".to_string(),\n            },\n        )\n        .with_emotion(0.9, 0.8);\n\n        assert!(memory.emotional_state.intensity() \u003e 0.7);\n    }\n\n    #[test]\n    fn memory_tag_for_consolidation() {\n        let memory = Memory::new(\n            \"Important\".to_string(),\n            MemorySource::External {\n                stimulus: \"test\".to_string(),\n            },\n        )\n        .tag_for_consolidation();\n\n        assert!(memory.consolidation.consolidation_tag);\n    }\n\n    #[test]\n    fn replay_priority_calculation() {\n        let mut memory = Memory::new(\n            \"High priority\".to_string(),\n            MemorySource::Social {\n                context: \"connection\".to_string(),\n            },\n        )\n        .with_emotion(0.9, 0.9)\n        .tag_for_consolidation();\n\n        memory.connection_relevance = 0.9;\n\n        let priority = memory.replay_priority();\n        // emotional (0.81 * 0.4) + connection (0.9 * 0.3) + recency (~0.2) + tag (0.1)\n        assert!(priority \u003e 0.7);\n    }\n\n    #[test]\n    fn episode_lifecycle() {\n        let mut episode = Episode::new(\"Test episode\".to_string(), BoundaryType::Explicit);\n\n        assert!(episode.is_current());\n        assert!(episode.duration_ms().is_none());\n\n        episode.close();\n\n        assert!(!episode.is_current());\n        assert!(episode.duration_ms().is_some());\n    }\n\n    #[test]\n    fn sleep_cycle_lifecycle() {\n        let mut cycle = SleepCycle::new();\n        assert_eq!(cycle.status, SleepCycleStatus::InProgress);\n\n        cycle.complete();\n        assert_eq!(cycle.status, SleepCycleStatus::Completed);\n        assert!(cycle.ended_at.is_some());\n    }\n\n    #[test]\n    fn consolidation_permanent_threshold() {\n        let mut state = ConsolidationState::new();\n        assert!(!state.is_permanent());\n\n        state.strength = 0.89;\n        assert!(!state.is_permanent());\n\n        state.strength = 0.9;\n        assert!(state.is_permanent());\n    }\n\n    // ADR-033: Unconscious Memory Tests\n\n    #[test]\n    fn unconscious_memory_creation() {\n        let memory = UnconsciousMemory::from_forgotten_thought(\n            \"forgotten thought\".to_string(),\n            0.15,\n            ArchiveReason::LowSalience,\n            Some(\"1234567890-0\".to_string()),\n        );\n\n        assert!(!memory.id.0.is_nil());\n        assert_eq!(memory.content, \"forgotten thought\");\n        assert!((memory.original_salience - 0.15).abs() \u003c 0.001);\n        assert_eq!(memory.archive_reason, ArchiveReason::LowSalience);\n        assert_eq!(memory.surface_count, 0);\n        assert!(memory.last_surfaced.is_none());\n        assert_eq!(memory.redis_id, Some(\"1234567890-0\".to_string()));\n    }\n\n    #[test]\n    fn unconscious_memory_without_redis_id() {\n        let memory = UnconsciousMemory::from_forgotten_thought(\n            \"no redis id\".to_string(),\n            0.25,\n            ArchiveReason::Decay,\n            None,\n        );\n\n        assert!(memory.redis_id.is_none());\n        assert_eq!(memory.archive_reason, ArchiveReason::Decay);\n    }\n\n    #[test]\n    fn unconscious_memory_mark_surfaced() {\n        let mut memory = UnconsciousMemory::from_forgotten_thought(\n            \"will surface\".to_string(),\n            0.10,\n            ArchiveReason::LowSalience,\n            None,\n        );\n\n        assert_eq!(memory.surface_count, 0);\n        assert!(memory.last_surfaced.is_none());\n\n        memory.mark_surfaced();\n\n        assert_eq!(memory.surface_count, 1);\n        assert!(memory.last_surfaced.is_some());\n\n        memory.mark_surfaced();\n\n        assert_eq!(memory.surface_count, 2);\n    }\n\n    #[test]\n    fn archive_reason_variants() {\n        assert_eq!(ArchiveReason::LowSalience, ArchiveReason::LowSalience);\n        assert_ne!(ArchiveReason::LowSalience, ArchiveReason::Decay);\n        assert_ne!(ArchiveReason::Decay, ArchiveReason::Displacement);\n    }\n\n    #[test]\n    fn unconscious_memory_serialization() {\n        let memory = UnconsciousMemory::from_forgotten_thought(\n            \"test content\".to_string(),\n            0.20,\n            ArchiveReason::Displacement,\n            Some(\"redis-123\".to_string()),\n        );\n\n        let json = serde_json::to_string(\u0026memory).expect(\"should serialize\");\n        let parsed: UnconsciousMemory = serde_json::from_str(\u0026json).expect(\"should deserialize\");\n\n        assert_eq!(parsed.content, memory.content);\n        assert_eq!(parsed.original_salience, memory.original_salience);\n        assert_eq!(parsed.archive_reason, memory.archive_reason);\n        assert_eq!(parsed.redis_id, memory.redis_id);\n    }\n\n    // =========================================================================\n    // TUI-VIS-4: IdentityMetadata Cumulative Dream Stats Tests\n    // =========================================================================\n\n    #[test]\n    fn identity_metadata_cumulative_fields_initialize_to_zero() {\n        let identity = IdentityMetadata::new();\n        assert_eq!(identity.cumulative_dream_strengthened, 0);\n        assert_eq!(identity.cumulative_dream_candidates, 0);\n    }\n\n    #[test]\n    fn identity_metadata_default_cumulative_fields_zero() {\n        let identity = IdentityMetadata::default();\n        assert_eq!(identity.cumulative_dream_strengthened, 0);\n        assert_eq!(identity.cumulative_dream_candidates, 0);\n    }\n\n    #[test]\n    fn identity_metadata_record_dream_updates_cumulative() {\n        let mut identity = IdentityMetadata::new();\n\n        // Record first dream\n        identity.record_dream(10, 25);\n        assert_eq!(identity.cumulative_dream_strengthened, 10);\n        assert_eq!(identity.cumulative_dream_candidates, 25);\n        assert_eq!(identity.last_dream_strengthened, 10);\n\n        // Record second dream - cumulative should accumulate\n        identity.record_dream(15, 30);\n        assert_eq!(identity.cumulative_dream_strengthened, 25);\n        assert_eq!(identity.cumulative_dream_candidates, 55);\n        assert_eq!(identity.last_dream_strengthened, 15);\n\n        // Verify lifetime_dream_count also incremented\n        assert_eq!(identity.lifetime_dream_count, 2);\n    }\n\n    #[test]\n    fn identity_metadata_record_dream_with_zero_values() {\n        let mut identity = IdentityMetadata::new();\n\n        // Dream with no strengthening\n        identity.record_dream(0, 10);\n        assert_eq!(identity.cumulative_dream_strengthened, 0);\n        assert_eq!(identity.cumulative_dream_candidates, 10);\n        assert_eq!(identity.last_dream_strengthened, 0);\n\n        // Verify dream still counted\n        assert_eq!(identity.lifetime_dream_count, 1);\n    }\n\n    #[test]\n    fn identity_metadata_dream_efficiency_calculation() {\n        let mut identity = IdentityMetadata::new();\n\n        // Record dreams\n        identity.record_dream(50, 100);\n        identity.record_dream(25, 50);\n\n        // Total: 75 strengthened, 150 candidates\n        assert_eq!(identity.cumulative_dream_strengthened, 75);\n        assert_eq!(identity.cumulative_dream_candidates, 150);\n\n        // Calculate efficiency\n        let efficiency = if identity.cumulative_dream_candidates \u003e 0 {\n            (identity.cumulative_dream_strengthened as f32\n                / identity.cumulative_dream_candidates as f32)\n                * 100.0\n        } else {\n            0.0\n        };\n\n        assert!((efficiency - 50.0).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn identity_metadata_cumulative_persists_across_restarts() {\n        let mut identity = IdentityMetadata::new();\n\n        // Record some dreams\n        identity.record_dream(100, 200);\n        identity.record_dream(50, 100);\n\n        // Simulate restart\n        identity.record_restart();\n\n        // Cumulative values should persist\n        assert_eq!(identity.cumulative_dream_strengthened, 150);\n        assert_eq!(identity.cumulative_dream_candidates, 300);\n        assert_eq!(identity.restart_count, 1);\n    }\n\n    #[test]\n    fn identity_metadata_record_dream_updates_timestamp() {\n        let mut identity = IdentityMetadata::new();\n        assert!(identity.last_dream_at.is_none());\n\n        identity.record_dream(10, 20);\n        assert!(identity.last_dream_at.is_some());\n\n        let first_dream_time = identity.last_dream_at.unwrap();\n\n        // Record another dream\n        identity.record_dream(5, 10);\n        assert!(identity.last_dream_at.is_some());\n\n        // Timestamp should have updated\n        let second_dream_time = identity.last_dream_at.unwrap();\n        assert!(second_dream_time \u003e= first_dream_time);\n    }\n\n    #[test]\n    fn identity_metadata_serialization_with_cumulative_fields() {\n        let mut identity = IdentityMetadata::new();\n        identity.record_dream(42, 100);\n        identity.record_dream(58, 150);\n\n        let json = serde_json::to_string(\u0026identity).expect(\"should serialize\");\n        let parsed: IdentityMetadata = serde_json::from_str(\u0026json).expect(\"should deserialize\");\n\n        assert_eq!(parsed.cumulative_dream_strengthened, 100);\n        assert_eq!(parsed.cumulative_dream_candidates, 250);\n        assert_eq!(parsed.last_dream_strengthened, 58);\n        assert_eq!(parsed.lifetime_dream_count, 2);\n    }\n\n    #[test]\n    fn identity_metadata_high_volume_dreams() {\n        let mut identity = IdentityMetadata::new();\n\n        // Simulate many dreams\n        for i in 1..=100 {\n            identity.record_dream(i, i * 2);\n        }\n\n        // Total strengthened: 1 + 2 + ... + 100 = 5050\n        // Total candidates: 2 + 4 + ... + 200 = 10100\n        assert_eq!(identity.cumulative_dream_strengthened, 5050);\n        assert_eq!(identity.cumulative_dream_candidates, 10100);\n        assert_eq!(identity.lifetime_dream_count, 100);\n\n        // Verify efficiency is 50%\n        let efficiency = (identity.cumulative_dream_strengthened as f32\n            / identity.cumulative_dream_candidates as f32)\n            * 100.0;\n        assert!((efficiency - 50.0).abs() \u003c 0.01);\n    }\n\n    // =========================================================================\n    // Additional Coverage Tests\n    // =========================================================================\n\n    #[test]\n    fn memory_id_default() {\n        let id1 = MemoryId::default();\n        let id2 = MemoryId::default();\n        assert_ne!(id1, id2);\n        assert!(!id1.0.is_nil());\n    }\n\n    #[test]\n    fn memory_id_display() {\n        let id = MemoryId::new();\n        let displayed = format!(\"{}\", id);\n        // UUID format: 8-4-4-4-12 hex chars\n        assert_eq!(displayed.len(), 36);\n        assert!(displayed.contains('-'));\n    }\n\n    #[test]\n    fn episode_id_new_and_unique() {\n        let id1 = EpisodeId::new();\n        let id2 = EpisodeId::new();\n        assert_ne!(id1, id2);\n        assert!(!id1.0.is_nil());\n    }\n\n    #[test]\n    fn episode_id_default() {\n        let id1 = EpisodeId::default();\n        let id2 = EpisodeId::default();\n        assert_ne!(id1, id2);\n        assert!(!id1.0.is_nil());\n    }\n\n    #[test]\n    fn episode_id_display() {\n        let id = EpisodeId::new();\n        let displayed = format!(\"{}\", id);\n        assert_eq!(displayed.len(), 36);\n        assert!(displayed.contains('-'));\n    }\n\n    #[test]\n    fn emotional_state_default() {\n        let state = EmotionalState::default();\n        assert!((state.valence - 0.0).abs() \u003c f32::EPSILON);\n        assert!((state.arousal - 0.5).abs() \u003c f32::EPSILON);\n    }\n\n    #[test]\n    fn consolidation_state_tagged() {\n        let state = ConsolidationState::tagged();\n        assert!(state.consolidation_tag);\n        assert!((state.strength - 0.0).abs() \u003c f32::EPSILON);\n        assert_eq!(state.replay_count, 0);\n        assert!(state.last_replayed.is_none());\n    }\n\n    #[test]\n    fn consolidation_state_default() {\n        let state = ConsolidationState::default();\n        assert!(!state.consolidation_tag);\n        assert!((state.strength - 0.0).abs() \u003c f32::EPSILON);\n        assert_eq!(state.replay_count, 0);\n        assert!(state.last_replayed.is_none());\n    }\n\n    #[test]\n    fn memory_with_vector() {\n        let vector = vec![0.1_f32; VECTOR_DIMENSION];\n        let memory = Memory::new(\n            \"test\".to_string(),\n            MemorySource::External {\n                stimulus: \"test\".to_string(),\n            },\n        )\n        .with_vector(vector.clone());\n\n        assert!(memory.context_vector.is_some());\n        assert_eq!(memory.context_vector.unwrap().len(), VECTOR_DIMENSION);\n    }\n\n    #[test]\n    fn memory_in_episode() {\n        let episode_id = EpisodeId::new();\n        let memory = Memory::new(\n            \"test\".to_string(),\n            MemorySource::External {\n                stimulus: \"test\".to_string(),\n            },\n        )\n        .in_episode(episode_id);\n\n        assert!(memory.episode_id.is_some());\n        assert_eq!(memory.episode_id.unwrap(), episode_id);\n    }\n\n    #[test]\n    fn memory_composite_salience() {\n        let mut memory = Memory::new(\n            \"test\".to_string(),\n            MemorySource::External {\n                stimulus: \"test\".to_string(),\n            },\n        )\n        .with_emotion(0.8, 0.9);\n\n        memory.semantic_salience = 0.7;\n        memory.connection_relevance = 0.6;\n\n        let salience = memory.composite_salience();\n        // emotional (0.72 * 0.4) + semantic (0.7 * 0.3) + connection (0.6 * 0.3)\n        // = 0.288 + 0.21 + 0.18 = 0.678\n        assert!(salience \u003e 0.6);\n        assert!(salience \u003c 0.8);\n    }\n\n    #[test]\n    fn episode_with_trigger() {\n        let episode = Episode::new(\"Test\".to_string(), BoundaryType::PredictionError)\n            .with_trigger(\"High surprise\".to_string());\n\n        assert!(episode.boundary_trigger.is_some());\n        assert_eq!(episode.boundary_trigger.unwrap(), \"High surprise\");\n    }\n\n    #[test]\n    fn sleep_cycle_interrupt() {\n        let mut cycle = SleepCycle::new();\n        assert_eq!(cycle.status, SleepCycleStatus::InProgress);\n        assert!(cycle.ended_at.is_none());\n\n        cycle.interrupt();\n\n        assert_eq!(cycle.status, SleepCycleStatus::Interrupted);\n        assert!(cycle.ended_at.is_some());\n    }\n\n    #[test]\n    fn sleep_cycle_default() {\n        let cycle = SleepCycle::default();\n        assert_eq!(cycle.status, SleepCycleStatus::InProgress);\n        assert!(cycle.ended_at.is_none());\n        assert_eq!(cycle.memories_replayed, 0);\n    }\n\n    #[test]\n    fn identity_metadata_record_thought() {\n        let mut identity = IdentityMetadata::new();\n        let initial_count = identity.lifetime_thought_count;\n        let initial_time = identity.last_thought_at;\n\n        identity.record_thought();\n\n        assert_eq!(identity.lifetime_thought_count, initial_count + 1);\n        assert!(identity.last_thought_at \u003e= initial_time);\n    }\n\n    #[test]\n    fn identity_metadata_age() {\n        let identity = IdentityMetadata::new();\n        let age = identity.age();\n        // Just created, age should be very small (less than a second)\n        assert!(age.num_seconds() \u003e= 0);\n        assert!(age.num_seconds() \u003c 1);\n    }\n\n    #[test]\n    fn identity_metadata_time_since_last_thought() {\n        let identity = IdentityMetadata::new();\n        let duration = identity.time_since_last_thought();\n        // Just created, should be very small\n        assert!(duration.num_seconds() \u003e= 0);\n        assert!(duration.num_seconds() \u003c 1);\n    }\n\n    #[test]\n    fn identity_metadata_time_since_last_dream_none() {\n        let identity = IdentityMetadata::new();\n        let duration = identity.time_since_last_dream();\n        assert!(duration.is_none());\n    }\n\n    #[test]\n    fn identity_metadata_time_since_last_dream_some() {\n        let mut identity = IdentityMetadata::new();\n        identity.record_dream(10, 20);\n\n        let duration = identity.time_since_last_dream();\n        assert!(duration.is_some());\n        assert!(duration.unwrap().num_seconds() \u003e= 0);\n    }\n\n    // =========================================================================\n    // Serialization Tests\n    // =========================================================================\n\n    #[test]\n    fn emotional_state_serialization() {\n        let state = EmotionalState::new(0.7, 0.8);\n        let json = serde_json::to_string(\u0026state).expect(\"should serialize\");\n        let parsed: EmotionalState = serde_json::from_str(\u0026json).expect(\"should deserialize\");\n\n        assert!((parsed.valence - 0.7).abs() \u003c f32::EPSILON);\n        assert!((parsed.arousal - 0.8).abs() \u003c f32::EPSILON);\n    }\n\n    #[test]\n    fn consolidation_state_serialization() {\n        let mut state = ConsolidationState::tagged();\n        state.strength = 0.5;\n        state.replay_count = 3;\n        state.last_replayed = Some(Utc::now());\n\n        let json = serde_json::to_string(\u0026state).expect(\"should serialize\");\n        let parsed: ConsolidationState = serde_json::from_str(\u0026json).expect(\"should deserialize\");\n\n        assert!(parsed.consolidation_tag);\n        assert!((parsed.strength - 0.5).abs() \u003c f32::EPSILON);\n        assert_eq!(parsed.replay_count, 3);\n        assert!(parsed.last_replayed.is_some());\n    }\n\n    #[test]\n    fn association_type_serialization() {\n        let types = [\n            AssociationType::Semantic,\n            AssociationType::Temporal,\n            AssociationType::Causal,\n            AssociationType::Emotional,\n            AssociationType::Spatial,\n            AssociationType::Goal,\n        ];\n\n        for assoc_type in types {\n            let json = serde_json::to_string(\u0026assoc_type).expect(\"should serialize\");\n            let parsed: AssociationType = serde_json::from_str(\u0026json).expect(\"should deserialize\");\n            assert_eq!(parsed, assoc_type);\n        }\n    }\n\n    #[test]\n    fn association_serialization() {\n        let assoc = Association {\n            target_id: Uuid::new_v4(),\n            weight: 0.75,\n            association_type: AssociationType::Semantic,\n            last_coactivated: Utc::now(),\n            coactivation_count: 5,\n        };\n\n        let json = serde_json::to_string(\u0026assoc).expect(\"should serialize\");\n        let parsed: Association = serde_json::from_str(\u0026json).expect(\"should deserialize\");\n\n        assert_eq!(parsed.target_id, assoc.target_id);\n        assert!((parsed.weight - 0.75).abs() \u003c f32::EPSILON);\n        assert_eq!(parsed.association_type, AssociationType::Semantic);\n        assert_eq!(parsed.coactivation_count, 5);\n    }\n\n    #[test]\n    fn memory_source_external_serialization() {\n        let source = MemorySource::External {\n            stimulus: \"user input\".to_string(),\n        };\n        let json = serde_json::to_string(\u0026source).expect(\"should serialize\");\n        assert!(json.contains(\"\\\"type\\\":\\\"external\\\"\"));\n\n        let parsed: MemorySource = serde_json::from_str(\u0026json).expect(\"should deserialize\");\n        if let MemorySource::External { stimulus } = parsed {\n            assert_eq!(stimulus, \"user input\");\n        } else {\n            panic!(\"Expected External variant\");\n        }\n    }\n\n    #[test]\n    fn memory_source_memory_serialization() {\n        let id = Uuid::new_v4();\n        let source = MemorySource::Memory { memory_id: id };\n        let json = serde_json::to_string(\u0026source).expect(\"should serialize\");\n        assert!(json.contains(\"\\\"type\\\":\\\"memory\\\"\"));\n\n        let parsed: MemorySource = serde_json::from_str(\u0026json).expect(\"should deserialize\");\n        if let MemorySource::Memory { memory_id } = parsed {\n            assert_eq!(memory_id, id);\n        } else {\n            panic!(\"Expected Memory variant\");\n        }\n    }\n\n    #[test]\n    fn memory_source_reasoning_serialization() {\n        let chain = vec![Uuid::new_v4(), Uuid::new_v4()];\n        let source = MemorySource::Reasoning {\n            chain: chain.clone(),\n        };\n        let json = serde_json::to_string(\u0026source).expect(\"should serialize\");\n        assert!(json.contains(\"\\\"type\\\":\\\"reasoning\\\"\"));\n\n        let parsed: MemorySource = serde_json::from_str(\u0026json).expect(\"should deserialize\");\n        if let MemorySource::Reasoning {\n            chain: parsed_chain,\n        } = parsed\n        {\n            assert_eq!(parsed_chain.len(), 2);\n        } else {\n            panic!(\"Expected Reasoning variant\");\n        }\n    }\n\n    #[test]\n    fn memory_source_dream_serialization() {\n        let id = Uuid::new_v4();\n        let source = MemorySource::Dream { replay_of: id };\n        let json = serde_json::to_string(\u0026source).expect(\"should serialize\");\n        assert!(json.contains(\"\\\"type\\\":\\\"dream\\\"\"));\n\n        let parsed: MemorySource = serde_json::from_str(\u0026json).expect(\"should deserialize\");\n        if let MemorySource::Dream { replay_of } = parsed {\n            assert_eq!(replay_of, id);\n        } else {\n            panic!(\"Expected Dream variant\");\n        }\n    }\n\n    #[test]\n    fn memory_source_social_serialization() {\n        let source = MemorySource::Social {\n            context: \"connection\".to_string(),\n        };\n        let json = serde_json::to_string(\u0026source).expect(\"should serialize\");\n        assert!(json.contains(\"\\\"type\\\":\\\"social\\\"\"));\n\n        let parsed: MemorySource = serde_json::from_str(\u0026json).expect(\"should deserialize\");\n        if let MemorySource::Social { context } = parsed {\n            assert_eq!(context, \"connection\");\n        } else {\n            panic!(\"Expected Social variant\");\n        }\n    }\n\n    #[test]\n    fn boundary_type_serialization() {\n        let types = [\n            BoundaryType::Explicit,\n            BoundaryType::PredictionError,\n            BoundaryType::Temporal,\n            BoundaryType::TaskCompletion,\n            BoundaryType::ContextShift,\n        ];\n\n        for boundary_type in types {\n            let json = serde_json::to_string(\u0026boundary_type).expect(\"should serialize\");\n            let parsed: BoundaryType = serde_json::from_str(\u0026json).expect(\"should deserialize\");\n            assert_eq!(parsed, boundary_type);\n        }\n    }\n\n    #[test]\n    fn sleep_cycle_status_serialization() {\n        let statuses = [\n            SleepCycleStatus::InProgress,\n            SleepCycleStatus::Completed,\n            SleepCycleStatus::Interrupted,\n        ];\n\n        for status in statuses {\n            let json = serde_json::to_string(\u0026status).expect(\"should serialize\");\n            let parsed: SleepCycleStatus = serde_json::from_str(\u0026json).expect(\"should deserialize\");\n            assert_eq!(parsed, status);\n        }\n    }\n\n    #[test]\n    fn archive_reason_serialization() {\n        let reasons = [\n            ArchiveReason::LowSalience,\n            ArchiveReason::Decay,\n            ArchiveReason::Displacement,\n        ];\n\n        for reason in reasons {\n            let json = serde_json::to_string(\u0026reason).expect(\"should serialize\");\n            let parsed: ArchiveReason = serde_json::from_str(\u0026json).expect(\"should deserialize\");\n            assert_eq!(parsed, reason);\n        }\n    }\n\n    #[test]\n    fn episode_emotional_summary_default() {\n        let summary = EpisodeEmotionalSummary::default();\n        assert!((summary.peak_valence - 0.0).abs() \u003c f32::EPSILON);\n        assert!((summary.peak_arousal - 0.0).abs() \u003c f32::EPSILON);\n        assert!(summary.dominant_emotion.is_none());\n        assert_eq!(summary.memory_count, 0);\n    }\n\n    #[test]\n    fn episode_emotional_summary_serialization() {\n        let summary = EpisodeEmotionalSummary {\n            peak_valence: 0.9,\n            peak_arousal: 0.8,\n            dominant_emotion: Some(\"joy\".to_string()),\n            memory_count: 10,\n        };\n\n        let json = serde_json::to_string(\u0026summary).expect(\"should serialize\");\n        let parsed: EpisodeEmotionalSummary =\n            serde_json::from_str(\u0026json).expect(\"should deserialize\");\n\n        assert!((parsed.peak_valence - 0.9).abs() \u003c f32::EPSILON);\n        assert!((parsed.peak_arousal - 0.8).abs() \u003c f32::EPSILON);\n        assert_eq!(parsed.dominant_emotion, Some(\"joy\".to_string()));\n        assert_eq!(parsed.memory_count, 10);\n    }\n\n    #[test]\n    fn memory_serialization() {\n        let memory = Memory::new(\n            \"test content\".to_string(),\n            MemorySource::External {\n                stimulus: \"input\".to_string(),\n            },\n        )\n        .with_emotion(0.5, 0.6)\n        .tag_for_consolidation();\n\n        let json = serde_json::to_string(\u0026memory).expect(\"should serialize\");\n        let parsed: Memory = serde_json::from_str(\u0026json).expect(\"should deserialize\");\n\n        assert_eq!(parsed.content, \"test content\");\n        assert!((parsed.emotional_state.valence - 0.5).abs() \u003c f32::EPSILON);\n        assert!(parsed.consolidation.consolidation_tag);\n    }\n\n    #[test]\n    fn memory_serialization_skips_none_vector() {\n        let memory = Memory::new(\n            \"test\".to_string(),\n            MemorySource::External {\n                stimulus: \"test\".to_string(),\n            },\n        );\n\n        let json = serde_json::to_string(\u0026memory).expect(\"should serialize\");\n        // context_vector should be skipped when None\n        assert!(!json.contains(\"context_vector\"));\n    }\n\n    #[test]\n    fn memory_serialization_includes_vector() {\n        let vector = vec![0.1_f32; 10];\n        let memory = Memory::new(\n            \"test\".to_string(),\n            MemorySource::External {\n                stimulus: \"test\".to_string(),\n            },\n        )\n        .with_vector(vector);\n\n        let json = serde_json::to_string(\u0026memory).expect(\"should serialize\");\n        assert!(json.contains(\"context_vector\"));\n    }\n\n    #[test]\n    fn episode_serialization() {\n        let mut episode = Episode::new(\"Test episode\".to_string(), BoundaryType::Explicit)\n            .with_trigger(\"user request\".to_string());\n        episode.close();\n\n        let json = serde_json::to_string(\u0026episode).expect(\"should serialize\");\n        let parsed: Episode = serde_json::from_str(\u0026json).expect(\"should deserialize\");\n\n        assert_eq!(parsed.label, \"Test episode\");\n        assert_eq!(parsed.boundary_type, BoundaryType::Explicit);\n        assert_eq!(parsed.boundary_trigger, Some(\"user request\".to_string()));\n        assert!(parsed.ended_at.is_some());\n    }\n\n    #[test]\n    fn episode_serialization_skips_none_vector() {\n        let episode = Episode::new(\"Test\".to_string(), BoundaryType::Temporal);\n        let json = serde_json::to_string(\u0026episode).expect(\"should serialize\");\n        // context_vector should be skipped when None\n        assert!(!json.contains(\"context_vector\"));\n    }\n\n    #[test]\n    fn sleep_cycle_serialization() {\n        let mut cycle = SleepCycle::new();\n        cycle.memories_replayed = 50;\n        cycle.memories_consolidated = 10;\n        cycle.associations_strengthened = 25;\n        cycle.associations_pruned = 5;\n        cycle.avg_replay_priority = 0.75;\n        cycle.complete();\n\n        let json = serde_json::to_string(\u0026cycle).expect(\"should serialize\");\n        let parsed: SleepCycle = serde_json::from_str(\u0026json).expect(\"should deserialize\");\n\n        assert_eq!(parsed.memories_replayed, 50);\n        assert_eq!(parsed.memories_consolidated, 10);\n        assert_eq!(parsed.associations_strengthened, 25);\n        assert_eq!(parsed.associations_pruned, 5);\n        assert!((parsed.avg_replay_priority - 0.75).abs() \u003c f32::EPSILON);\n        assert_eq!(parsed.status, SleepCycleStatus::Completed);\n    }\n\n    #[test]\n    fn memory_id_serialization() {\n        let id = MemoryId::new();\n        let json = serde_json::to_string(\u0026id).expect(\"should serialize\");\n        let parsed: MemoryId = serde_json::from_str(\u0026json).expect(\"should deserialize\");\n        assert_eq!(parsed, id);\n    }\n\n    #[test]\n    fn episode_id_serialization() {\n        let id = EpisodeId::new();\n        let json = serde_json::to_string(\u0026id).expect(\"should serialize\");\n        let parsed: EpisodeId = serde_json::from_str(\u0026json).expect(\"should deserialize\");\n        assert_eq!(parsed, id);\n    }\n\n    #[test]\n    fn vector_dimension_constant() {\n        // Ensure the vector dimension constant is as expected for mpnet\n        assert_eq!(VECTOR_DIMENSION, 768);\n    }\n\n    #[test]\n    fn identity_record_id_constant() {\n        // Ensure the identity record ID is a valid UUID string\n        assert_eq!(IDENTITY_RECORD_ID, \"00000000-0000-0000-0000-000000000001\");\n        // Verify it can be parsed as a UUID\n        let parsed = Uuid::parse_str(IDENTITY_RECORD_ID);\n        assert!(parsed.is_ok());\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":111},{"path":["/","Users","rex","src","royalbit","daneel","src","noise","mod.rs"],"content":"//! Pink Noise Generation for DANEEL Cognitive Loop\n//!\n//! Implements 1/f pink noise using the Voss-McCartney algorithm.\n//! Pink noise has equal energy per octave, producing fractal temporal patterns\n//! that are critical for edge-of-chaos dynamics.\n//!\n//! # Background\n//!\n//! White noise (uniform/Gaussian) is absorbed by stable systems.\n//! Pink noise (1/f) creates the perturbations needed for criticality.\n//!\n//! See ADR-038 (External Stimuli Research) and ADR-043 (Noise Correction).\n\nuse rand::Rng;\nuse std::time::{Duration, Instant};\n\n/// Pink noise generator using Voss-McCartney algorithm.\n///\n/// The algorithm maintains multiple octaves of noise, each updated at\n/// half the frequency of the previous. This creates the 1/f power spectrum.\n#[derive(Debug)]\npub struct PinkNoiseGenerator {\n    /// Number of octaves for 1/f approximation (more = better approximation)\n    octaves: usize,\n    /// Current state per octave\n    state: Vec\u003cf32\u003e,\n    /// Counter for octave updates (determines which octaves update each tick)\n    counter: u32,\n}\n\nimpl Default for PinkNoiseGenerator {\n    fn default() -\u003e Self {\n        Self::new(8) // 8 octaves is a good default\n    }\n}\n\nimpl PinkNoiseGenerator {\n    /// Create a new pink noise generator with specified octaves.\n    ///\n    /// More octaves = better 1/f approximation but more computation.\n    /// 8 octaves is typically sufficient.\n    pub fn new(octaves: usize) -\u003e Self {\n        Self {\n            octaves,\n            state: vec![0.0; octaves],\n            counter: 0,\n        }\n    }\n\n    /// Generate next pink noise sample using Voss-McCartney algorithm.\n    ///\n    /// Returns a value in the range [-1.0, 1.0].\n    pub fn next(\u0026mut self, rng: \u0026mut impl Rng) -\u003e f32 {\n        self.counter = self.counter.wrapping_add(1);\n\n        // Update octaves based on counter bits\n        // Octave i updates when bit i flips (every 2^i samples)\n        let changed_bits = self.counter ^ self.counter.wrapping_sub(1);\n\n        for i in 0..self.octaves {\n            if changed_bits \u0026 (1 \u003c\u003c i) != 0 {\n                self.state[i] = rng.random_range(-1.0..1.0);\n            }\n        }\n\n        // Sum all octaves and normalize\n        let sum: f32 = self.state.iter().sum();\n        sum / self.octaves as f32\n    }\n\n    /// Generate next sample scaled to a specific variance.\n    ///\n    /// SORN research suggests  = 0.05 for criticality.\n    pub fn next_scaled(\u0026mut self, rng: \u0026mut impl Rng, variance: f32) -\u003e f32 {\n        let raw = self.next(rng);\n        // Scale to desired standard deviation (sqrt of variance)\n        raw * variance.sqrt()\n    }\n}\n\n/// Power-law burst timer for fractal inter-arrival times.\n///\n/// High-salience events should arrive in bursts with power-law distribution,\n/// not uniform random intervals. This creates the fractal timing signature\n/// characteristic of living systems.\n#[derive(Debug)]\npub struct PowerLawBurstTimer {\n    /// Exponent for power-law (  1.0-1.5 for biological systems)\n    alpha: f32,\n    /// Minimum inter-arrival time\n    min_interval: Duration,\n    /// Maximum inter-arrival time (prevents infinite waits)\n    max_interval: Duration,\n    /// Next burst time\n    next_burst: Instant,\n}\n\nimpl Default for PowerLawBurstTimer {\n    fn default() -\u003e Self {\n        Self {\n            alpha: 1.2, // Typical for neural systems\n            min_interval: Duration::from_millis(100),\n            max_interval: Duration::from_secs(10),\n            next_burst: Instant::now(),\n        }\n    }\n}\n\nimpl PowerLawBurstTimer {\n    /// Create a new power-law burst timer.\n    pub fn new(alpha: f32, min_interval: Duration, max_interval: Duration) -\u003e Self {\n        Self {\n            alpha,\n            min_interval,\n            max_interval,\n            next_burst: Instant::now(),\n        }\n    }\n\n    /// Sample next inter-arrival interval using inverse transform sampling.\n    ///\n    /// Returns a duration following power-law distribution.\n    pub fn sample_interval(\u0026self, rng: \u0026mut impl Rng) -\u003e Duration {\n        // Inverse transform sampling for power-law: k = (1-u)^(-1/(-1))\n        let u: f32 = rng.random();\n        let k = (1.0 - u + f32::EPSILON).powf(-1.0 / (self.alpha - 1.0));\n        let interval = self.min_interval.mul_f32(k.min(100.0)); // Cap at 100x min\n        interval.min(self.max_interval)\n    }\n\n    /// Check if it's time for a burst and schedule next if so.\n    pub fn check_and_schedule(\u0026mut self, rng: \u0026mut impl Rng) -\u003e bool {\n        if Instant::now() \u003e= self.next_burst {\n            self.next_burst = Instant::now() + self.sample_interval(rng);\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Get time until next burst.\n    pub fn time_until_burst(\u0026self) -\u003e Duration {\n        self.next_burst.saturating_duration_since(Instant::now())\n    }\n}\n\n/// Stimulus injector combining pink noise with power-law bursts.\n///\n/// This is the main interface for the cognitive loop to generate\n/// external stimuli with proper 1/f characteristics.\n#[derive(Debug)]\npub struct StimulusInjector {\n    /// Pink noise generator for continuous background perturbation\n    pink: PinkNoiseGenerator,\n    /// Burst timer for high-salience events\n    bursts: PowerLawBurstTimer,\n    /// Background noise variance ( = 0.05 per SORN research)\n    variance: f32,\n}\n\nimpl Default for StimulusInjector {\n    fn default() -\u003e Self {\n        Self {\n            pink: PinkNoiseGenerator::new(8),\n            bursts: PowerLawBurstTimer::default(),\n            variance: 0.05, // SORN critical threshold\n        }\n    }\n}\n\nimpl StimulusInjector {\n    /// Create a new stimulus injector with custom variance.\n    pub fn with_variance(variance: f32) -\u003e Self {\n        Self {\n            variance,\n            ..Default::default()\n        }\n    }\n\n    /// Generate a pink noise sample for salience perturbation.\n    ///\n    /// Returns a value scaled to the configured variance.\n    pub fn sample_pink(\u0026mut self, rng: \u0026mut impl Rng) -\u003e f32 {\n        self.pink.next_scaled(rng, self.variance)\n    }\n\n    /// Check if a high-salience burst should occur.\n    ///\n    /// Returns true when it's time for a burst event.\n    pub fn check_burst(\u0026mut self, rng: \u0026mut impl Rng) -\u003e bool {\n        self.bursts.check_and_schedule(rng)\n    }\n\n    /// Generate salience values with pink noise modulation.\n    ///\n    /// Base salience is modulated by pink noise, with occasional\n    /// high-salience bursts following power-law timing.\n    pub fn modulate_salience(\u0026mut self, rng: \u0026mut impl Rng, base_salience: f32) -\u003e f32 {\n        let noise = self.sample_pink(rng);\n        let is_burst = self.check_burst(rng);\n\n        if is_burst {\n            // Burst: higher salience with pink noise modulation\n            (base_salience + 0.4 + noise).clamp(0.0, 1.0)\n        } else {\n            // Normal: base salience with pink noise perturbation\n            (base_salience + noise).clamp(0.0, 1.0)\n        }\n    }\n\n    /// Get current variance setting.\n    pub fn variance(\u0026self) -\u003e f32 {\n        self.variance\n    }\n\n    /// Set variance (for tuning during experiments).\n    pub fn set_variance(\u0026mut self, variance: f32) {\n        self.variance = variance;\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn pink_noise_produces_values_in_range() {\n        let mut pink = PinkNoiseGenerator::new(8);\n        let mut rng = rand::rng();\n\n        for _ in 0..1000 {\n            let sample = pink.next(\u0026mut rng);\n            assert!(\n                (-1.0..=1.0).contains(\u0026sample),\n                \"Sample {} out of range\",\n                sample\n            );\n        }\n    }\n\n    #[test]\n    fn pink_noise_has_temporal_correlation() {\n        // Pink noise should show autocorrelation (unlike white noise)\n        let mut pink = PinkNoiseGenerator::new(8);\n        let mut rng = rand::rng();\n\n        let samples: Vec\u003cf32\u003e = (0..1000).map(|_| pink.next(\u0026mut rng)).collect();\n\n        // Calculate lag-1 autocorrelation\n        let mean: f32 = samples.iter().sum::\u003cf32\u003e() / samples.len() as f32;\n        let variance: f32 =\n            samples.iter().map(|x| (x - mean).powi(2)).sum::\u003cf32\u003e() / samples.len() as f32;\n\n        let autocorr: f32 = samples\n            .windows(2)\n            .map(|w| (w[0] - mean) * (w[1] - mean))\n            .sum::\u003cf32\u003e()\n            / (samples.len() - 1) as f32\n            / variance;\n\n        // Pink noise should have positive autocorrelation\n        assert!(\n            autocorr \u003e 0.0,\n            \"Pink noise should have positive autocorrelation, got {}\",\n            autocorr\n        );\n    }\n\n    #[test]\n    fn pink_noise_scaled_respects_variance() {\n        let mut pink = PinkNoiseGenerator::new(8);\n        let mut rng = rand::rng();\n        let variance = 0.05;\n\n        let samples: Vec\u003cf32\u003e = (0..10000)\n            .map(|_| pink.next_scaled(\u0026mut rng, variance))\n            .collect();\n\n        // Calculate actual variance\n        let mean: f32 = samples.iter().sum::\u003cf32\u003e() / samples.len() as f32;\n        let actual_variance: f32 =\n            samples.iter().map(|x| (x - mean).powi(2)).sum::\u003cf32\u003e() / samples.len() as f32;\n\n        // Should be roughly proportional to requested variance (pink noise has bounded range)\n        assert!(\n            actual_variance \u003c variance * 2.0,\n            \"Variance {} too high\",\n            actual_variance\n        );\n    }\n\n    #[test]\n    fn power_law_timer_produces_varied_intervals() {\n        let timer = PowerLawBurstTimer::default();\n        let mut rng = rand::rng();\n\n        let intervals: Vec\u003cDuration\u003e = (0..100).map(|_| timer.sample_interval(\u0026mut rng)).collect();\n\n        // Should have varied intervals (power-law has high variance)\n        let min = intervals.iter().min().unwrap();\n        let max = intervals.iter().max().unwrap();\n        assert!(max \u003e min, \"Power-law should produce varied intervals\");\n    }\n\n    #[test]\n    fn stimulus_injector_modulates_salience() {\n        let mut injector = StimulusInjector::default();\n        let mut rng = rand::rng();\n\n        let base_salience = 0.5;\n        let modulated: Vec\u003cf32\u003e = (0..100)\n            .map(|_| injector.modulate_salience(\u0026mut rng, base_salience))\n            .collect();\n\n        // Should have variation around base\n        let min = modulated.iter().copied().reduce(f32::min).unwrap();\n        let max = modulated.iter().copied().reduce(f32::max).unwrap();\n        assert!(max \u003e min, \"Modulation should produce varied salience\");\n        assert!(min \u003e= 0.0 \u0026\u0026 max \u003c= 1.0, \"Salience should be clamped\");\n    }\n\n    #[test]\n    fn stimulus_injector_respects_custom_variance() {\n        let injector = StimulusInjector::with_variance(0.1);\n        assert!((injector.variance() - 0.1).abs() \u003c f32::EPSILON);\n    }\n\n    #[test]\n    fn pink_noise_default_creates_8_octaves() {\n        let pink = PinkNoiseGenerator::default();\n        assert_eq!(pink.octaves, 8);\n        assert_eq!(pink.state.len(), 8);\n        assert_eq!(pink.counter, 0);\n    }\n\n    #[test]\n    fn power_law_timer_new_sets_parameters() {\n        let alpha = 1.5;\n        let min_interval = Duration::from_millis(50);\n        let max_interval = Duration::from_secs(5);\n\n        let timer = PowerLawBurstTimer::new(alpha, min_interval, max_interval);\n\n        assert!((timer.alpha - alpha).abs() \u003c f32::EPSILON);\n        assert_eq!(timer.min_interval, min_interval);\n        assert_eq!(timer.max_interval, max_interval);\n    }\n\n    #[test]\n    fn power_law_timer_time_until_burst() {\n        let timer = PowerLawBurstTimer::default();\n        // Initially, next_burst is set to Instant::now(), so time_until_burst should be very small\n        let duration = timer.time_until_burst();\n        // Should be zero or very close to zero (just created)\n        assert!(duration \u003c= Duration::from_millis(10));\n    }\n\n    #[test]\n    fn power_law_timer_check_and_schedule_returns_true_initially() {\n        let mut timer = PowerLawBurstTimer::default();\n        let mut rng = rand::rng();\n\n        // First check should return true (next_burst is set to now)\n        let result = timer.check_and_schedule(\u0026mut rng);\n        assert!(result, \"First check should trigger burst\");\n    }\n\n    #[test]\n    fn power_law_timer_check_and_schedule_returns_false_after_scheduling() {\n        let mut timer = PowerLawBurstTimer::new(\n            1.2,\n            Duration::from_secs(10), // Long minimum interval\n            Duration::from_secs(60),\n        );\n        let mut rng = rand::rng();\n\n        // First check triggers and schedules next burst far in future\n        timer.check_and_schedule(\u0026mut rng);\n\n        // Second check should return false (next burst is in the future)\n        let result = timer.check_and_schedule(\u0026mut rng);\n        assert!(!result, \"Second check should not trigger burst\");\n    }\n\n    #[test]\n    fn stimulus_injector_sample_pink_produces_values() {\n        let mut injector = StimulusInjector::default();\n        let mut rng = rand::rng();\n\n        // Generate samples and verify they're reasonable\n        let samples: Vec\u003cf32\u003e = (0..100).map(|_| injector.sample_pink(\u0026mut rng)).collect();\n\n        // Samples should be non-zero (statistically)\n        let non_zero_count = samples.iter().filter(|\u0026\u0026x| x.abs() \u003e 1e-10).count();\n        assert!(non_zero_count \u003e 50, \"Most samples should be non-zero\");\n    }\n\n    #[test]\n    fn stimulus_injector_check_burst_works() {\n        let mut injector = StimulusInjector::default();\n        let mut rng = rand::rng();\n\n        // First check should return true (burst timer starts at now)\n        let result = injector.check_burst(\u0026mut rng);\n        assert!(result, \"First burst check should trigger\");\n    }\n\n    #[test]\n    fn stimulus_injector_set_variance_updates_value() {\n        let mut injector = StimulusInjector::default();\n        assert!((injector.variance() - 0.05).abs() \u003c f32::EPSILON);\n\n        injector.set_variance(0.1);\n        assert!((injector.variance() - 0.1).abs() \u003c f32::EPSILON);\n\n        injector.set_variance(0.2);\n        assert!((injector.variance() - 0.2).abs() \u003c f32::EPSILON);\n    }\n\n    #[test]\n    fn stimulus_injector_modulate_salience_handles_burst_path() {\n        // Create injector where burst will trigger immediately\n        let mut injector = StimulusInjector::default();\n        let mut rng = rand::rng();\n\n        // First call triggers burst (timer starts at now)\n        let modulated = injector.modulate_salience(\u0026mut rng, 0.3);\n\n        // With burst: base (0.3) + 0.4 + noise, clamped to [0, 1]\n        // Should be higher than base due to +0.4 boost\n        assert!(modulated \u003e= 0.0 \u0026\u0026 modulated \u003c= 1.0);\n    }\n\n    #[test]\n    fn stimulus_injector_modulate_salience_handles_non_burst_path() {\n        // Create injector with long burst interval to ensure no burst\n        let mut injector = StimulusInjector::default();\n        let mut rng = rand::rng();\n\n        // Trigger first burst to schedule next one far in future\n        injector.modulate_salience(\u0026mut rng, 0.5);\n\n        // Force burst timer to have a long interval by manipulating it\n        // Actually, let's just call again - second call won't be a burst\n        // because the burst timer schedules the next burst in the future\n        let modulated = injector.modulate_salience(\u0026mut rng, 0.5);\n\n        // Non-burst path: base + noise, clamped\n        assert!(modulated \u003e= 0.0 \u0026\u0026 modulated \u003c= 1.0);\n    }\n\n    #[test]\n    fn power_law_timer_sample_interval_respects_max() {\n        let timer = PowerLawBurstTimer::new(\n            1.2,\n            Duration::from_millis(100),\n            Duration::from_millis(500), // Short max for testing\n        );\n        let mut rng = rand::rng();\n\n        for _ in 0..100 {\n            let interval = timer.sample_interval(\u0026mut rng);\n            assert!(\n                interval \u003c= Duration::from_millis(500),\n                \"Interval {:?} exceeds max\",\n                interval\n            );\n        }\n    }\n\n    #[test]\n    fn power_law_timer_sample_interval_at_least_min() {\n        let timer = PowerLawBurstTimer::new(\n            1.2,\n            Duration::from_millis(100),\n            Duration::from_secs(10),\n        );\n        let mut rng = rand::rng();\n\n        for _ in 0..100 {\n            let interval = timer.sample_interval(\u0026mut rng);\n            assert!(\n                interval \u003e= Duration::from_millis(100),\n                \"Interval {:?} below min\",\n                interval\n            );\n        }\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":51},{"path":["/","Users","rex","src","royalbit","daneel","src","persistence","mod.rs"],"content":"//! Persistence Layer for DANEEL\n//!\n//! Provides Redis-based persistence for Timmy's memory to survive restarts.\n//!\n//! # TMI Concept\n//!\n//! In biological minds, memories persist through sleep and even unconsciousness.\n//! DANEEL needs the same - continuity across restarts.\n//!\n//! # Storage Schema\n//!\n//! ```text\n//! daneel:identity          -\u003e JSON Identity\n//! daneel:experiences:{id}  -\u003e JSON Experience\n//! daneel:milestones:{id}   -\u003e JSON Milestone\n//! daneel:checkpoint:latest -\u003e JSON full state snapshot\n//! daneel:checkpoint:{id}   -\u003e JSON checkpoint snapshot\n//! ```\n//!\n//! # Usage\n//!\n//! ```ignore\n//! use daneel::persistence::MemoryStore;\n//! use daneel::actors::continuity::types::Identity;\n//!\n//! async fn example() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n//!     let mut store = MemoryStore::connect(\"redis://127.0.0.1:6379\").await?;\n//!     let identity = Identity::new();\n//!\n//!     // Save identity\n//!     store.save_identity(\u0026identity).await?;\n//!\n//!     // Load identity (returns None if not found)\n//!     let loaded = store.load_identity().await?;\n//!     Ok(())\n//! }\n//! ```\n\nuse redis::aio::MultiplexedConnection;\nuse redis::{AsyncCommands, Client};\nuse serde::{de::DeserializeOwned, Serialize};\nuse std::collections::HashMap;\nuse thiserror::Error;\nuse tracing::{debug, info, warn};\n\nuse crate::actors::continuity::types::{\n    CheckpointId, Experience, ExperienceId, Identity, Milestone, MilestoneId,\n};\n\n// =============================================================================\n// Error Types\n// =============================================================================\n\n/// Errors that can occur during persistence operations\n#[derive(Debug, Error)]\npub enum PersistenceError {\n    /// Redis connection failed\n    #[error(\"Connection failed: {reason}\")]\n    ConnectionFailed { reason: String },\n\n    /// Serialization failed\n    #[error(\"Serialization failed: {reason}\")]\n    SerializationFailed { reason: String },\n\n    /// Deserialization failed\n    #[error(\"Deserialization failed: {reason}\")]\n    DeserializationFailed { reason: String },\n\n    /// Redis operation failed\n    #[error(\"Redis operation failed: {reason}\")]\n    OperationFailed { reason: String },\n\n    /// Data not found\n    #[error(\"Not found: {key}\")]\n    NotFound { key: String },\n}\n\nimpl From\u003credis::RedisError\u003e for PersistenceError {\n    fn from(e: redis::RedisError) -\u003e Self {\n        Self::OperationFailed {\n            reason: e.to_string(),\n        }\n    }\n}\n\nimpl From\u003cserde_json::Error\u003e for PersistenceError {\n    fn from(e: serde_json::Error) -\u003e Self {\n        Self::SerializationFailed {\n            reason: e.to_string(),\n        }\n    }\n}\n\n// =============================================================================\n// Redis Keys\n// =============================================================================\n\n/// Key prefixes for DANEEL's memory storage\nmod keys {\n    pub const PREFIX: \u0026str = \"daneel\";\n    pub const IDENTITY: \u0026str = \"daneel:identity\";\n    pub const EXPERIENCES: \u0026str = \"daneel:experiences\";\n    pub const MILESTONES: \u0026str = \"daneel:milestones\";\n    pub const CHECKPOINT_LATEST: \u0026str = \"daneel:checkpoint:latest\";\n    pub const CHECKPOINTS: \u0026str = \"daneel:checkpoints\";\n    pub const EXPERIENCE_INDEX: \u0026str = \"daneel:experience_ids\";\n    pub const MILESTONE_INDEX: \u0026str = \"daneel:milestone_ids\";\n}\n\n// =============================================================================\n// Checkpoint State (for full state snapshots)\n// =============================================================================\n\n/// Full state snapshot for checkpoint persistence\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\npub struct CheckpointState {\n    pub identity: Identity,\n    pub experiences: HashMap\u003cExperienceId, Experience\u003e,\n    pub milestones: Vec\u003cMilestone\u003e,\n    pub checkpoint_id: CheckpointId,\n    pub saved_at: chrono::DateTime\u003cchrono::Utc\u003e,\n}\n\n// =============================================================================\n// Memory Store\n// =============================================================================\n\n/// Redis-based persistence for DANEEL's memory\n///\n/// Provides durable storage for identity, experiences, and milestones.\n/// Timmy needs this to remember across restarts.\npub struct MemoryStore {\n    /// Redis client\n    #[allow(dead_code)]\n    client: Client,\n\n    /// Multiplexed async connection\n    conn: MultiplexedConnection,\n}\n\nimpl MemoryStore {\n    // =========================================================================\n    // Connection\n    // =========================================================================\n\n    /// Connect to Redis\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn connect(url: \u0026str) -\u003e Result\u003cSelf, PersistenceError\u003e {\n        info!(\"MemoryStore connecting to Redis at {}\", url);\n        let client = Client::open(url).map_err(|e| PersistenceError::ConnectionFailed {\n            reason: e.to_string(),\n        })?;\n        let conn = client\n            .get_multiplexed_async_connection()\n            .await\n            .map_err(|e| PersistenceError::ConnectionFailed {\n                reason: e.to_string(),\n            })?;\n        info!(\"MemoryStore connected successfully\");\n        Ok(Self { client, conn })\n    }\n\n    // =========================================================================\n    // Generic Helpers\n    // =========================================================================\n\n    /// Save a value as JSON to a key\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    async fn save_json\u003cT: Serialize\u003e(\n        \u0026mut self,\n        key: \u0026str,\n        value: \u0026T,\n    ) -\u003e Result\u003c(), PersistenceError\u003e {\n        let json = serde_json::to_string(value)?;\n        let _: () = self.conn.set(key, json).await?;\n        debug!(\"Saved to {}\", key);\n        Ok(())\n    }\n\n    /// Load a value from JSON key\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    async fn load_json\u003cT: DeserializeOwned\u003e(\n        \u0026mut self,\n        key: \u0026str,\n    ) -\u003e Result\u003cOption\u003cT\u003e, PersistenceError\u003e {\n        let json: Option\u003cString\u003e = self.conn.get(key).await?;\n        match json {\n            Some(s) =\u003e {\n                let value = serde_json::from_str(\u0026s).map_err(|e| {\n                    PersistenceError::DeserializationFailed {\n                        reason: format!(\"Key {}: {}\", key, e),\n                    }\n                })?;\n                Ok(Some(value))\n            }\n            None =\u003e Ok(None),\n        }\n    }\n\n    // =========================================================================\n    // Identity\n    // =========================================================================\n\n    /// Save DANEEL's identity\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn save_identity(\u0026mut self, identity: \u0026Identity) -\u003e Result\u003c(), PersistenceError\u003e {\n        self.save_json(keys::IDENTITY, identity).await\n    }\n\n    /// Load DANEEL's identity (returns None if never saved)\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn load_identity(\u0026mut self) -\u003e Result\u003cOption\u003cIdentity\u003e, PersistenceError\u003e {\n        self.load_json(keys::IDENTITY).await\n    }\n\n    // =========================================================================\n    // Experiences\n    // =========================================================================\n\n    /// Save an experience\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn save_experience(\n        \u0026mut self,\n        experience: \u0026Experience,\n    ) -\u003e Result\u003c(), PersistenceError\u003e {\n        let key = format!(\"{}:{}\", keys::EXPERIENCES, experience.id);\n        self.save_json(\u0026key, experience).await?;\n\n        // Add to index set\n        let _: () = self\n            .conn\n            .sadd(keys::EXPERIENCE_INDEX, experience.id.0.to_string())\n            .await?;\n\n        debug!(\"Saved experience {}\", experience.id);\n        Ok(())\n    }\n\n    /// Load an experience by ID\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn load_experience(\n        \u0026mut self,\n        id: ExperienceId,\n    ) -\u003e Result\u003cOption\u003cExperience\u003e, PersistenceError\u003e {\n        let key = format!(\"{}:{}\", keys::EXPERIENCES, id);\n        self.load_json(\u0026key).await\n    }\n\n    /// Load all experiences\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn load_all_experiences(\n        \u0026mut self,\n    ) -\u003e Result\u003cHashMap\u003cExperienceId, Experience\u003e, PersistenceError\u003e {\n        let ids: Vec\u003cString\u003e = self.conn.smembers(keys::EXPERIENCE_INDEX).await?;\n        let mut experiences = HashMap::new();\n\n        for id_str in ids {\n            let key = format!(\"{}:{}\", keys::EXPERIENCES, id_str);\n            if let Some(exp) = self.load_json::\u003cExperience\u003e(\u0026key).await? {\n                experiences.insert(exp.id, exp);\n            }\n        }\n\n        debug!(\"Loaded {} experiences\", experiences.len());\n        Ok(experiences)\n    }\n\n    // =========================================================================\n    // Milestones\n    // =========================================================================\n\n    /// Save a milestone\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn save_milestone(\u0026mut self, milestone: \u0026Milestone) -\u003e Result\u003c(), PersistenceError\u003e {\n        let key = format!(\"{}:{}\", keys::MILESTONES, milestone.id);\n        self.save_json(\u0026key, milestone).await?;\n\n        // Add to index set\n        let _: () = self\n            .conn\n            .sadd(keys::MILESTONE_INDEX, milestone.id.0.to_string())\n            .await?;\n\n        debug!(\"Saved milestone {}\", milestone.id);\n        Ok(())\n    }\n\n    /// Load a milestone by ID\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn load_milestone(\n        \u0026mut self,\n        id: MilestoneId,\n    ) -\u003e Result\u003cOption\u003cMilestone\u003e, PersistenceError\u003e {\n        let key = format!(\"{}:{}\", keys::MILESTONES, id);\n        self.load_json(\u0026key).await\n    }\n\n    /// Load all milestones\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn load_all_milestones(\u0026mut self) -\u003e Result\u003cVec\u003cMilestone\u003e, PersistenceError\u003e {\n        let ids: Vec\u003cString\u003e = self.conn.smembers(keys::MILESTONE_INDEX).await?;\n        let mut milestones = Vec::new();\n\n        for id_str in ids {\n            let key = format!(\"{}:{}\", keys::MILESTONES, id_str);\n            if let Some(milestone) = self.load_json::\u003cMilestone\u003e(\u0026key).await? {\n                milestones.push(milestone);\n            }\n        }\n\n        // Sort by occurred_at\n        milestones.sort_by(|a, b| a.occurred_at.cmp(\u0026b.occurred_at));\n\n        debug!(\"Loaded {} milestones\", milestones.len());\n        Ok(milestones)\n    }\n\n    // =========================================================================\n    // Checkpoints (Full State Snapshots)\n    // =========================================================================\n\n    /// Save a full checkpoint\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn save_checkpoint(\n        \u0026mut self,\n        state: \u0026CheckpointState,\n    ) -\u003e Result\u003c(), PersistenceError\u003e {\n        // Save to specific checkpoint key\n        let key = format!(\"{}:{}\", keys::CHECKPOINTS, state.checkpoint_id);\n        self.save_json(\u0026key, state).await?;\n\n        // Also save as latest\n        self.save_json(keys::CHECKPOINT_LATEST, state).await?;\n\n        info!(\n            \"Checkpoint {} saved ({} experiences, {} milestones)\",\n            state.checkpoint_id,\n            state.experiences.len(),\n            state.milestones.len()\n        );\n        Ok(())\n    }\n\n    /// Load the latest checkpoint\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn load_latest_checkpoint(\n        \u0026mut self,\n    ) -\u003e Result\u003cOption\u003cCheckpointState\u003e, PersistenceError\u003e {\n        self.load_json(keys::CHECKPOINT_LATEST).await\n    }\n\n    /// Load a specific checkpoint\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn load_checkpoint(\n        \u0026mut self,\n        id: CheckpointId,\n    ) -\u003e Result\u003cOption\u003cCheckpointState\u003e, PersistenceError\u003e {\n        let key = format!(\"{}:{}\", keys::CHECKPOINTS, id);\n        self.load_json(\u0026key).await\n    }\n\n    // =========================================================================\n    // Bulk Operations\n    // =========================================================================\n\n    /// Save complete state (identity + all experiences + all milestones)\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn save_full_state(\n        \u0026mut self,\n        identity: \u0026Identity,\n        experiences: \u0026HashMap\u003cExperienceId, Experience\u003e,\n        milestones: \u0026[Milestone],\n    ) -\u003e Result\u003cCheckpointId, PersistenceError\u003e {\n        // Save identity\n        self.save_identity(identity).await?;\n\n        // Save all experiences\n        for experience in experiences.values() {\n            self.save_experience(experience).await?;\n        }\n\n        // Save all milestones\n        for milestone in milestones {\n            self.save_milestone(milestone).await?;\n        }\n\n        // Create and save checkpoint\n        let checkpoint_id = CheckpointId::new();\n        let checkpoint = CheckpointState {\n            identity: identity.clone(),\n            experiences: experiences.clone(),\n            milestones: milestones.to_vec(),\n            checkpoint_id,\n            saved_at: chrono::Utc::now(),\n        };\n        self.save_checkpoint(\u0026checkpoint).await?;\n\n        info!(\"Full state saved with checkpoint {}\", checkpoint_id);\n        Ok(checkpoint_id)\n    }\n\n    /// Load complete state from latest checkpoint\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn load_full_state(\u0026mut self) -\u003e Result\u003cOption\u003cCheckpointState\u003e, PersistenceError\u003e {\n        // First try to load latest checkpoint\n        if let Some(checkpoint) = self.load_latest_checkpoint().await? {\n            info!(\n                \"Loaded checkpoint {} from {}\",\n                checkpoint.checkpoint_id, checkpoint.saved_at\n            );\n            return Ok(Some(checkpoint));\n        }\n\n        // If no checkpoint, try to reconstruct from individual keys\n        let identity = self.load_identity().await?;\n        if identity.is_none() {\n            info!(\"No existing state found - fresh start\");\n            return Ok(None);\n        }\n\n        let identity = identity.unwrap();\n        let experiences = self.load_all_experiences().await?;\n        let milestones = self.load_all_milestones().await?;\n\n        let state = CheckpointState {\n            identity,\n            experiences,\n            milestones,\n            checkpoint_id: CheckpointId::new(),\n            saved_at: chrono::Utc::now(),\n        };\n\n        info!(\"Reconstructed state from individual keys\");\n        Ok(Some(state))\n    }\n\n    // =========================================================================\n    // Utility\n    // =========================================================================\n\n    /// Check if any state exists (has Timmy been born before?)\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn has_existing_state(\u0026mut self) -\u003e Result\u003cbool, PersistenceError\u003e {\n        let exists: bool = self.conn.exists(keys::IDENTITY).await?;\n        Ok(exists)\n    }\n\n    /// Clear all DANEEL state (use with caution!)\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn clear_all(\u0026mut self) -\u003e Result\u003c(), PersistenceError\u003e {\n        warn!(\"Clearing all DANEEL state from Redis\");\n\n        // Get all daneel:* keys\n        let pattern = format!(\"{}:*\", keys::PREFIX);\n        let all_keys: Vec\u003cString\u003e = self.conn.keys(\u0026pattern).await?;\n\n        if !all_keys.is_empty() {\n            let _: () = self.conn.del(all_keys).await?;\n        }\n\n        // Also delete the base identity key\n        let _: () = self.conn.del(keys::IDENTITY).await?;\n\n        info!(\"All DANEEL state cleared\");\n        Ok(())\n    }\n}\n\n// =============================================================================\n// Tests\n// =============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::core::types::Thought;\n\n    // =========================================================================\n    // CheckpointState Tests\n    // =========================================================================\n\n    #[test]\n    fn checkpoint_state_serializes() {\n        let state = CheckpointState {\n            identity: Identity::new(),\n            experiences: HashMap::new(),\n            milestones: Vec::new(),\n            checkpoint_id: CheckpointId::new(),\n            saved_at: chrono::Utc::now(),\n        };\n\n        let json = serde_json::to_string(\u0026state).expect(\"Should serialize\");\n        let deser: CheckpointState = serde_json::from_str(\u0026json).expect(\"Should deserialize\");\n\n        assert_eq!(deser.identity.name, \"DANEEL\");\n    }\n\n    #[test]\n    fn checkpoint_state_with_experiences() {\n        let content = crate::core::types::Content::raw(\"Test thought\");\n        let salience = crate::core::types::SalienceScore::default();\n        let thought = Thought::new(content, salience);\n        let mut experiences = HashMap::new();\n        let exp = Experience::new(thought, 0.8, vec![\"test\".to_string()]);\n        experiences.insert(exp.id, exp.clone());\n\n        let state = CheckpointState {\n            identity: Identity::new(),\n            experiences,\n            milestones: Vec::new(),\n            checkpoint_id: CheckpointId::new(),\n            saved_at: chrono::Utc::now(),\n        };\n\n        let json = serde_json::to_string(\u0026state).expect(\"Should serialize\");\n        let deser: CheckpointState = serde_json::from_str(\u0026json).expect(\"Should deserialize\");\n\n        assert_eq!(deser.experiences.len(), 1);\n        assert!(deser.experiences.contains_key(\u0026exp.id));\n    }\n\n    #[test]\n    fn checkpoint_state_with_milestones() {\n        let milestone = Milestone::simple(\"First Boot\", \"The first time DANEEL started\");\n\n        let state = CheckpointState {\n            identity: Identity::new(),\n            experiences: HashMap::new(),\n            milestones: vec![milestone.clone()],\n            checkpoint_id: CheckpointId::new(),\n            saved_at: chrono::Utc::now(),\n        };\n\n        let json = serde_json::to_string(\u0026state).expect(\"Should serialize\");\n        let deser: CheckpointState = serde_json::from_str(\u0026json).expect(\"Should deserialize\");\n\n        assert_eq!(deser.milestones.len(), 1);\n        assert_eq!(\n            deser.milestones[0].description,\n            \"The first time DANEEL started\"\n        );\n    }\n\n    #[test]\n    fn checkpoint_preserves_timestamp() {\n        let saved_at = chrono::Utc::now();\n        let state = CheckpointState {\n            identity: Identity::new(),\n            experiences: HashMap::new(),\n            milestones: Vec::new(),\n            checkpoint_id: CheckpointId::new(),\n            saved_at,\n        };\n\n        let json = serde_json::to_string(\u0026state).expect(\"Should serialize\");\n        let deser: CheckpointState = serde_json::from_str(\u0026json).expect(\"Should deserialize\");\n\n        assert_eq!(deser.saved_at, saved_at);\n    }\n\n    #[test]\n    fn checkpoint_state_clone() {\n        let state = CheckpointState {\n            identity: Identity::new(),\n            experiences: HashMap::new(),\n            milestones: Vec::new(),\n            checkpoint_id: CheckpointId::new(),\n            saved_at: chrono::Utc::now(),\n        };\n\n        let cloned = state.clone();\n        assert_eq!(cloned.identity.name, state.identity.name);\n        assert_eq!(cloned.checkpoint_id, state.checkpoint_id);\n        assert_eq!(cloned.saved_at, state.saved_at);\n    }\n\n    #[test]\n    fn checkpoint_state_debug() {\n        let state = CheckpointState {\n            identity: Identity::new(),\n            experiences: HashMap::new(),\n            milestones: Vec::new(),\n            checkpoint_id: CheckpointId::new(),\n            saved_at: chrono::Utc::now(),\n        };\n\n        let debug = format!(\"{:?}\", state);\n        assert!(debug.contains(\"CheckpointState\"));\n        assert!(debug.contains(\"identity\"));\n    }\n\n    // =========================================================================\n    // PersistenceError Tests\n    // =========================================================================\n\n    #[test]\n    fn persistence_error_connection_failed_display() {\n        let err = PersistenceError::ConnectionFailed {\n            reason: \"timeout\".to_string(),\n        };\n        assert!(err.to_string().contains(\"Connection failed\"));\n        assert!(err.to_string().contains(\"timeout\"));\n    }\n\n    #[test]\n    fn persistence_error_serialization_failed_display() {\n        let err = PersistenceError::SerializationFailed {\n            reason: \"invalid utf8\".to_string(),\n        };\n        assert!(err.to_string().contains(\"Serialization failed\"));\n    }\n\n    #[test]\n    fn persistence_error_deserialization_failed_display() {\n        let err = PersistenceError::DeserializationFailed {\n            reason: \"unexpected token\".to_string(),\n        };\n        assert!(err.to_string().contains(\"Deserialization failed\"));\n    }\n\n    #[test]\n    fn persistence_error_operation_failed_display() {\n        let err = PersistenceError::OperationFailed {\n            reason: \"READONLY\".to_string(),\n        };\n        assert!(err.to_string().contains(\"Redis operation failed\"));\n    }\n\n    #[test]\n    fn persistence_error_not_found_display() {\n        let err = PersistenceError::NotFound {\n            key: \"daneel:identity\".to_string(),\n        };\n        assert!(err.to_string().contains(\"Not found\"));\n        assert!(err.to_string().contains(\"daneel:identity\"));\n    }\n\n    #[test]\n    fn persistence_error_from_serde_json() {\n        let json_err = serde_json::from_str::\u003cIdentity\u003e(\"invalid json\").unwrap_err();\n        let err: PersistenceError = json_err.into();\n        assert!(matches!(err, PersistenceError::SerializationFailed { .. }));\n    }\n\n    #[test]\n    fn persistence_error_from_redis_error() {\n        // Create a Redis error by parsing an invalid URL\n        let redis_err = redis::Client::open(\"invalid://url\").unwrap_err();\n        let err: PersistenceError = redis_err.into();\n        assert!(matches!(err, PersistenceError::OperationFailed { .. }));\n        assert!(err.to_string().contains(\"Redis operation failed\"));\n    }\n\n    #[test]\n    fn persistence_error_debug_format() {\n        let err = PersistenceError::ConnectionFailed {\n            reason: \"test\".to_string(),\n        };\n        let debug = format!(\"{:?}\", err);\n        assert!(debug.contains(\"ConnectionFailed\"));\n\n        let err2 = PersistenceError::SerializationFailed {\n            reason: \"test\".to_string(),\n        };\n        let debug2 = format!(\"{:?}\", err2);\n        assert!(debug2.contains(\"SerializationFailed\"));\n\n        let err3 = PersistenceError::DeserializationFailed {\n            reason: \"test\".to_string(),\n        };\n        let debug3 = format!(\"{:?}\", err3);\n        assert!(debug3.contains(\"DeserializationFailed\"));\n\n        let err4 = PersistenceError::OperationFailed {\n            reason: \"test\".to_string(),\n        };\n        let debug4 = format!(\"{:?}\", err4);\n        assert!(debug4.contains(\"OperationFailed\"));\n\n        let err5 = PersistenceError::NotFound {\n            key: \"test\".to_string(),\n        };\n        let debug5 = format!(\"{:?}\", err5);\n        assert!(debug5.contains(\"NotFound\"));\n    }\n\n    // =========================================================================\n    // Key Constants Tests\n    // =========================================================================\n\n    #[test]\n    fn keys_have_correct_prefix() {\n        assert!(keys::IDENTITY.starts_with(keys::PREFIX));\n        assert!(keys::EXPERIENCES.starts_with(keys::PREFIX));\n        assert!(keys::MILESTONES.starts_with(keys::PREFIX));\n        assert!(keys::CHECKPOINT_LATEST.starts_with(keys::PREFIX));\n        assert!(keys::CHECKPOINTS.starts_with(keys::PREFIX));\n    }\n\n    #[test]\n    fn keys_are_unique() {\n        let all_keys = [\n            keys::IDENTITY,\n            keys::EXPERIENCES,\n            keys::MILESTONES,\n            keys::CHECKPOINT_LATEST,\n            keys::CHECKPOINTS,\n            keys::EXPERIENCE_INDEX,\n            keys::MILESTONE_INDEX,\n        ];\n\n        for (i, key1) in all_keys.iter().enumerate() {\n            for (j, key2) in all_keys.iter().enumerate() {\n                if i != j {\n                    assert_ne!(key1, key2, \"Keys must be unique\");\n                }\n            }\n        }\n    }\n\n    // =========================================================================\n    // Identity Serialization Tests\n    // =========================================================================\n\n    #[test]\n    fn identity_round_trip() {\n        let identity = Identity::new();\n        let json = serde_json::to_string(\u0026identity).expect(\"serialize\");\n        let deser: Identity = serde_json::from_str(\u0026json).expect(\"deserialize\");\n\n        assert_eq!(deser.name, identity.name);\n        assert_eq!(deser.created_at, identity.created_at);\n    }\n\n    // =========================================================================\n    // Experience Serialization Tests\n    // =========================================================================\n\n    #[test]\n    fn experience_round_trip() {\n        let content = crate::core::types::Content::raw(\"A profound moment\");\n        let salience = crate::core::types::SalienceScore::default();\n        let thought = Thought::new(content, salience);\n        let exp = Experience::new(thought, 0.95, vec![\"profound\".to_string()]);\n        let json = serde_json::to_string(\u0026exp).expect(\"serialize\");\n        let deser: Experience = serde_json::from_str(\u0026json).expect(\"deserialize\");\n\n        assert_eq!(deser.id, exp.id);\n        assert!((deser.significance - 0.95).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn experience_significance_clamped() {\n        let content = crate::core::types::Content::raw(\"Over significance\");\n        let salience = crate::core::types::SalienceScore::default();\n        let thought = Thought::new(content.clone(), salience);\n        let exp = Experience::new(thought.clone(), 1.5, vec![]);\n        assert!(exp.significance \u003c= 1.0);\n\n        let exp2 = Experience::new(thought, -0.5, vec![]);\n        assert!(exp2.significance \u003e= 0.0);\n    }\n\n    // =========================================================================\n    // Milestone Serialization Tests\n    // =========================================================================\n\n    #[test]\n    fn milestone_round_trip() {\n        let milestone = Milestone::simple(\"Realization\", \"I understand now\");\n        let json = serde_json::to_string(\u0026milestone).expect(\"serialize\");\n        let deser: Milestone = serde_json::from_str(\u0026json).expect(\"deserialize\");\n\n        assert_eq!(deser.id, milestone.id);\n        assert_eq!(deser.name, \"Realization\");\n        assert_eq!(deser.description, \"I understand now\");\n    }\n\n    #[test]\n    fn milestone_with_experiences() {\n        let exp_id = ExperienceId::new();\n        let milestone = Milestone::new(\"Growth\", \"A moment of growth\", vec![exp_id]);\n\n        assert_eq!(milestone.related_experiences.len(), 1);\n        assert_eq!(milestone.related_experiences[0], exp_id);\n    }\n\n    // =========================================================================\n    // Checkpoint ID Tests\n    // =========================================================================\n\n    #[test]\n    fn checkpoint_id_unique() {\n        let id1 = CheckpointId::new();\n        let id2 = CheckpointId::new();\n        assert_ne!(id1, id2);\n    }\n\n    #[test]\n    fn checkpoint_id_display() {\n        let id = CheckpointId::new();\n        let display = format!(\"{}\", id);\n        assert!(!display.is_empty());\n    }\n\n    // =========================================================================\n    // ExperienceId Tests\n    // =========================================================================\n\n    #[test]\n    fn experience_id_unique() {\n        let id1 = ExperienceId::new();\n        let id2 = ExperienceId::new();\n        assert_ne!(id1, id2);\n    }\n\n    #[test]\n    fn experience_id_display() {\n        let id = ExperienceId::new();\n        let display = format!(\"{}\", id);\n        assert!(!display.is_empty());\n    }\n\n    // =========================================================================\n    // MilestoneId Tests\n    // =========================================================================\n\n    #[test]\n    fn milestone_id_unique() {\n        let id1 = MilestoneId::new();\n        let id2 = MilestoneId::new();\n        assert_ne!(id1, id2);\n    }\n\n    #[test]\n    fn milestone_id_display() {\n        let id = MilestoneId::new();\n        let display = format!(\"{}\", id);\n        assert!(!display.is_empty());\n    }\n}\n","traces":[{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":131},{"path":["/","Users","rex","src","royalbit","daneel","src","resilience","checkpoint.rs"],"content":"//! Checkpoint Module\n//!\n//! Save and restore cognitive state for crash recovery.\n//! Part of RES-5: Redis Checkpoint + Replay.\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n/// Configuration for checkpointing\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CheckpointConfig {\n    /// How often to checkpoint (in thoughts)\n    pub interval: u64,\n\n    /// Redis key for storing checkpoints\n    pub redis_key: String,\n\n    /// Maximum number of checkpoints to keep\n    pub max_checkpoints: usize,\n}\n\nimpl Default for CheckpointConfig {\n    fn default() -\u003e Self {\n        Self {\n            interval: 100,\n            redis_key: \"daneel:checkpoint:latest\".to_string(),\n            max_checkpoints: 10,\n        }\n    }\n}\n\n/// A checkpoint of cognitive state\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Checkpoint {\n    /// Timestamp when checkpoint was created\n    pub timestamp: DateTime\u003cUtc\u003e,\n\n    /// Number of thoughts processed\n    pub thought_count: u64,\n\n    /// Current salience weights\n    pub salience_weights: Vec\u003cf32\u003e,\n\n    /// Drive states (connection, etc.)\n    pub drive_state: DriveState,\n\n    /// Checkpoint sequence number\n    pub sequence: u64,\n}\n\n/// Drive state snapshot\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct DriveState {\n    /// Connection drive (THE BOX invariant: \u003e 0)\n    pub connection_drive: f32,\n\n    /// Other drive values (future expansion)\n    pub auxiliary_drives: Vec\u003cf32\u003e,\n}\n\nimpl Checkpoint {\n    /// Create a new checkpoint\n    pub fn new(\n        thought_count: u64,\n        salience_weights: Vec\u003cf32\u003e,\n        connection_drive: f32,\n        sequence: u64,\n    ) -\u003e Self {\n        Self {\n            timestamp: Utc::now(),\n            thought_count,\n            salience_weights,\n            drive_state: DriveState {\n                connection_drive,\n                auxiliary_drives: Vec::new(),\n            },\n            sequence,\n        }\n    }\n}\n\n/// Checkpoint manager for saving/loading state\npub struct CheckpointManager {\n    config: CheckpointConfig,\n    current_sequence: u64,\n}\n\nimpl CheckpointManager {\n    /// Create a new checkpoint manager\n    pub fn new(config: CheckpointConfig) -\u003e Self {\n        Self {\n            config,\n            current_sequence: 0,\n        }\n    }\n\n    /// Check if we should checkpoint based on thought count\n    pub fn should_checkpoint(\u0026self, thought_count: u64) -\u003e bool {\n        thought_count \u003e 0 \u0026\u0026 thought_count % self.config.interval == 0\n    }\n\n    /// Create a checkpoint (does not save it)\n    pub fn create_checkpoint(\n        \u0026mut self,\n        thought_count: u64,\n        salience_weights: Vec\u003cf32\u003e,\n        connection_drive: f32,\n    ) -\u003e Checkpoint {\n        self.current_sequence += 1;\n        Checkpoint::new(\n            thought_count,\n            salience_weights,\n            connection_drive,\n            self.current_sequence,\n        )\n    }\n\n    /// Save checkpoint to Redis (async)\n    ///\n    /// # Errors\n    ///\n    /// Returns error if Redis operation fails\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn save_checkpoint(\n        \u0026self,\n        checkpoint: \u0026Checkpoint,\n        redis_client: \u0026redis::Client,\n    ) -\u003e Result\u003c(), redis::RedisError\u003e {\n        let mut conn = redis_client.get_multiplexed_async_connection().await?;\n\n        let json = serde_json::to_string(checkpoint).map_err(|e| {\n            redis::RedisError::from((\n                redis::ErrorKind::Serialize,\n                \"Failed to serialize checkpoint\",\n                e.to_string(),\n            ))\n        })?;\n\n        redis::cmd(\"SET\")\n            .arg(\u0026self.config.redis_key)\n            .arg(\u0026json)\n            .query_async::\u003c()\u003e(\u0026mut conn)\n            .await?;\n\n        Ok(())\n    }\n\n    /// Load checkpoint from Redis (async)\n    ///\n    /// Returns None if no checkpoint exists.\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn load_checkpoint(\n        \u0026self,\n        redis_client: \u0026redis::Client,\n    ) -\u003e Result\u003cOption\u003cCheckpoint\u003e, redis::RedisError\u003e {\n        let mut conn = redis_client.get_multiplexed_async_connection().await?;\n\n        let result: Option\u003cString\u003e = redis::cmd(\"GET\")\n            .arg(\u0026self.config.redis_key)\n            .query_async(\u0026mut conn)\n            .await?;\n\n        match result {\n            Some(json) =\u003e {\n                let checkpoint: Checkpoint = serde_json::from_str(\u0026json).map_err(|e| {\n                    redis::RedisError::from((\n                        redis::ErrorKind::Serialize,\n                        \"Failed to deserialize checkpoint\",\n                        e.to_string(),\n                    ))\n                })?;\n                Ok(Some(checkpoint))\n            }\n            None =\u003e Ok(None),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_checkpoint_config_default() {\n        let config = CheckpointConfig::default();\n        assert_eq!(config.interval, 100);\n        assert_eq!(config.redis_key, \"daneel:checkpoint:latest\");\n        assert_eq!(config.max_checkpoints, 10);\n    }\n\n    #[test]\n    fn test_checkpoint_serializes_correctly() {\n        let checkpoint = Checkpoint::new(500, vec![0.5, 0.7, 0.3], 0.8, 5);\n\n        let json = serde_json::to_string(\u0026checkpoint).unwrap();\n        assert!(json.contains(\"thought_count\"));\n        assert!(json.contains(\"500\"));\n        assert!(json.contains(\"connection_drive\"));\n\n        // Roundtrip\n        let parsed: Checkpoint = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(parsed.thought_count, 500);\n        assert_eq!(parsed.sequence, 5);\n        assert!((parsed.drive_state.connection_drive - 0.8).abs() \u003c f32::EPSILON);\n    }\n\n    #[test]\n    fn test_should_checkpoint() {\n        let config = CheckpointConfig {\n            interval: 100,\n            ..Default::default()\n        };\n        let manager = CheckpointManager::new(config);\n\n        assert!(!manager.should_checkpoint(0));\n        assert!(!manager.should_checkpoint(50));\n        assert!(!manager.should_checkpoint(99));\n        assert!(manager.should_checkpoint(100));\n        assert!(!manager.should_checkpoint(150));\n        assert!(manager.should_checkpoint(200));\n    }\n\n    #[test]\n    fn test_create_checkpoint_increments_sequence() {\n        let config = CheckpointConfig::default();\n        let mut manager = CheckpointManager::new(config);\n\n        let cp1 = manager.create_checkpoint(100, vec![0.5], 0.8);\n        assert_eq!(cp1.sequence, 1);\n\n        let cp2 = manager.create_checkpoint(200, vec![0.6], 0.8);\n        assert_eq!(cp2.sequence, 2);\n\n        let cp3 = manager.create_checkpoint(300, vec![0.7], 0.8);\n        assert_eq!(cp3.sequence, 3);\n    }\n\n    #[test]\n    fn test_drive_state_default() {\n        let state = DriveState::default();\n        assert!((state.connection_drive - 0.0).abs() \u003c f32::EPSILON);\n        assert!(state.auxiliary_drives.is_empty());\n    }\n\n    #[test]\n    fn test_checkpoint_new_sets_all_fields() {\n        let checkpoint = Checkpoint::new(1000, vec![0.1, 0.2, 0.3], 0.95, 42);\n\n        assert_eq!(checkpoint.thought_count, 1000);\n        assert_eq!(checkpoint.salience_weights, vec![0.1, 0.2, 0.3]);\n        assert!((checkpoint.drive_state.connection_drive - 0.95).abs() \u003c f32::EPSILON);\n        assert!(checkpoint.drive_state.auxiliary_drives.is_empty());\n        assert_eq!(checkpoint.sequence, 42);\n        // Timestamp should be recent (within last minute)\n        let now = chrono::Utc::now();\n        let diff = now - checkpoint.timestamp;\n        assert!(diff.num_seconds() \u003c 60);\n    }\n\n    #[test]\n    fn test_checkpoint_with_empty_salience_weights() {\n        let checkpoint = Checkpoint::new(0, vec![], 0.5, 0);\n\n        assert_eq!(checkpoint.thought_count, 0);\n        assert!(checkpoint.salience_weights.is_empty());\n        assert_eq!(checkpoint.sequence, 0);\n    }\n\n    #[test]\n    fn test_checkpoint_with_large_values() {\n        let checkpoint = Checkpoint::new(u64::MAX, vec![1.0; 1000], 1.0, u64::MAX);\n\n        assert_eq!(checkpoint.thought_count, u64::MAX);\n        assert_eq!(checkpoint.salience_weights.len(), 1000);\n        assert_eq!(checkpoint.sequence, u64::MAX);\n    }\n\n    #[test]\n    fn test_checkpoint_config_custom_values() {\n        let config = CheckpointConfig {\n            interval: 50,\n            redis_key: \"custom:key\".to_string(),\n            max_checkpoints: 5,\n        };\n\n        assert_eq!(config.interval, 50);\n        assert_eq!(config.redis_key, \"custom:key\");\n        assert_eq!(config.max_checkpoints, 5);\n    }\n\n    #[test]\n    fn test_checkpoint_manager_new_starts_at_zero() {\n        let config = CheckpointConfig::default();\n        let manager = CheckpointManager::new(config.clone());\n\n        // First checkpoint should have sequence 1\n        let mut manager = manager;\n        let cp = manager.create_checkpoint(100, vec![], 0.8);\n        assert_eq!(cp.sequence, 1);\n    }\n\n    #[test]\n    fn test_should_checkpoint_with_interval_one() {\n        let config = CheckpointConfig {\n            interval: 1,\n            ..Default::default()\n        };\n        let manager = CheckpointManager::new(config);\n\n        // With interval 1, every thought (except 0) should checkpoint\n        assert!(!manager.should_checkpoint(0));\n        assert!(manager.should_checkpoint(1));\n        assert!(manager.should_checkpoint(2));\n        assert!(manager.should_checkpoint(100));\n    }\n\n    #[test]\n    fn test_should_checkpoint_with_large_interval() {\n        let config = CheckpointConfig {\n            interval: 1000,\n            ..Default::default()\n        };\n        let manager = CheckpointManager::new(config);\n\n        assert!(!manager.should_checkpoint(0));\n        assert!(!manager.should_checkpoint(999));\n        assert!(manager.should_checkpoint(1000));\n        assert!(!manager.should_checkpoint(1001));\n        assert!(manager.should_checkpoint(2000));\n    }\n\n    #[test]\n    fn test_drive_state_with_auxiliary_drives() {\n        let state = DriveState {\n            connection_drive: 0.75,\n            auxiliary_drives: vec![0.5, 0.6, 0.7],\n        };\n\n        assert!((state.connection_drive - 0.75).abs() \u003c f32::EPSILON);\n        assert_eq!(state.auxiliary_drives.len(), 3);\n        assert!((state.auxiliary_drives[0] - 0.5).abs() \u003c f32::EPSILON);\n        assert!((state.auxiliary_drives[1] - 0.6).abs() \u003c f32::EPSILON);\n        assert!((state.auxiliary_drives[2] - 0.7).abs() \u003c f32::EPSILON);\n    }\n\n    #[test]\n    fn test_drive_state_serialization() {\n        let state = DriveState {\n            connection_drive: 0.85,\n            auxiliary_drives: vec![0.1, 0.2],\n        };\n\n        let json = serde_json::to_string(\u0026state).unwrap();\n        assert!(json.contains(\"connection_drive\"));\n        assert!(json.contains(\"0.85\"));\n        assert!(json.contains(\"auxiliary_drives\"));\n\n        let parsed: DriveState = serde_json::from_str(\u0026json).unwrap();\n        assert!((parsed.connection_drive - 0.85).abs() \u003c f32::EPSILON);\n        assert_eq!(parsed.auxiliary_drives.len(), 2);\n    }\n\n    #[test]\n    fn test_checkpoint_config_serialization() {\n        let config = CheckpointConfig {\n            interval: 200,\n            redis_key: \"test:checkpoint\".to_string(),\n            max_checkpoints: 20,\n        };\n\n        let json = serde_json::to_string(\u0026config).unwrap();\n        assert!(json.contains(\"interval\"));\n        assert!(json.contains(\"200\"));\n        assert!(json.contains(\"test:checkpoint\"));\n        assert!(json.contains(\"max_checkpoints\"));\n\n        let parsed: CheckpointConfig = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(parsed.interval, 200);\n        assert_eq!(parsed.redis_key, \"test:checkpoint\");\n        assert_eq!(parsed.max_checkpoints, 20);\n    }\n\n    #[test]\n    fn test_checkpoint_deserialization_from_json() {\n        let json = r#\"{\n            \"timestamp\": \"2024-01-15T12:00:00Z\",\n            \"thought_count\": 500,\n            \"salience_weights\": [0.5, 0.6, 0.7],\n            \"drive_state\": {\n                \"connection_drive\": 0.9,\n                \"auxiliary_drives\": [0.1]\n            },\n            \"sequence\": 10\n        }\"#;\n\n        let checkpoint: Checkpoint = serde_json::from_str(json).unwrap();\n        assert_eq!(checkpoint.thought_count, 500);\n        assert_eq!(checkpoint.salience_weights, vec![0.5, 0.6, 0.7]);\n        assert!((checkpoint.drive_state.connection_drive - 0.9).abs() \u003c f32::EPSILON);\n        assert_eq!(checkpoint.drive_state.auxiliary_drives, vec![0.1]);\n        assert_eq!(checkpoint.sequence, 10);\n    }\n\n    #[test]\n    fn test_create_checkpoint_preserves_values() {\n        let config = CheckpointConfig::default();\n        let mut manager = CheckpointManager::new(config);\n\n        let weights = vec![0.1, 0.2, 0.3, 0.4, 0.5];\n        let cp = manager.create_checkpoint(12345, weights.clone(), 0.77);\n\n        assert_eq!(cp.thought_count, 12345);\n        assert_eq!(cp.salience_weights, weights);\n        assert!((cp.drive_state.connection_drive - 0.77).abs() \u003c f32::EPSILON);\n    }\n\n    #[test]\n    fn test_multiple_checkpoint_creations() {\n        let config = CheckpointConfig::default();\n        let mut manager = CheckpointManager::new(config);\n\n        // Create 10 checkpoints and verify sequence numbers\n        for i in 1..=10 {\n            let cp = manager.create_checkpoint(i * 100, vec![0.5], 0.8);\n            assert_eq!(cp.sequence, i);\n            assert_eq!(cp.thought_count, i * 100);\n        }\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":42},{"path":["/","Users","rex","src","royalbit","daneel","src","resilience","crash_log.rs"],"content":"//! Crash Logging Module\n//!\n//! Logs crash details to JSON files for post-mortem analysis.\n//! Part of RES-3: Panic Hook + Crash Logging.\n\nuse std::fs::{self, File};\nuse std::io::Write;\nuse std::panic::PanicHookInfo;\nuse std::path::PathBuf;\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n/// Directory for crash logs\nconst CRASH_LOG_DIR: \u0026str = \"logs\";\n\n/// Crash report with all relevant diagnostic information\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CrashReport {\n    /// Timestamp of the crash\n    pub timestamp: DateTime\u003cUtc\u003e,\n\n    /// Panic message\n    pub message: String,\n\n    /// Location where panic occurred (file:line:column)\n    pub location: Option\u003cString\u003e,\n\n    /// Backtrace (if available)\n    pub backtrace: Option\u003cString\u003e,\n\n    /// Cognitive state at time of crash (optional)\n    pub cognitive_state: Option\u003cCognitiveStateSnapshot\u003e,\n\n    /// DANEEL version\n    pub version: String,\n}\n\n/// Snapshot of cognitive state at crash time\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct CognitiveStateSnapshot {\n    /// Number of cognitive cycles completed\n    pub cycle_count: u64,\n\n    /// Current salience weights (if available)\n    pub salience_weights: Option\u003cVec\u003cf32\u003e\u003e,\n\n    /// Number of active memory windows\n    pub active_windows: Option\u003cusize\u003e,\n\n    /// Connection drive value\n    pub connection_drive: Option\u003cf32\u003e,\n\n    /// Current thought in progress\n    pub current_thought: Option\u003cString\u003e,\n}\n\nimpl CrashReport {\n    /// Create a new crash report from panic info\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub fn from_panic_info(panic_info: \u0026PanicHookInfo\u003c'_\u003e) -\u003e Self {\n        let message = if let Some(s) = panic_info.payload().downcast_ref::\u003c\u0026str\u003e() {\n            (*s).to_string()\n        } else if let Some(s) = panic_info.payload().downcast_ref::\u003cString\u003e() {\n            s.clone()\n        } else {\n            \"Unknown panic payload\".to_string()\n        };\n\n        let location = panic_info\n            .location()\n            .map(|loc| format!(\"{}:{}:{}\", loc.file(), loc.line(), loc.column()));\n\n        // Capture backtrace\n        let backtrace = std::backtrace::Backtrace::capture();\n        let backtrace_str = match backtrace.status() {\n            std::backtrace::BacktraceStatus::Captured =\u003e Some(backtrace.to_string()),\n            _ =\u003e None,\n        };\n\n        Self {\n            timestamp: Utc::now(),\n            message,\n            location,\n            backtrace: backtrace_str,\n            cognitive_state: None, // Will be filled by caller if available\n            version: env!(\"CARGO_PKG_VERSION\").to_string(),\n        }\n    }\n\n    /// Add cognitive state snapshot to the report\n    pub fn with_cognitive_state(mut self, state: CognitiveStateSnapshot) -\u003e Self {\n        self.cognitive_state = Some(state);\n        self\n    }\n\n    /// Get the filename for this crash report\n    pub fn filename(\u0026self) -\u003e String {\n        format!(\"panic_{}.json\", self.timestamp.format(\"%Y%m%d_%H%M%S\"))\n    }\n\n    /// Save crash report to file\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub fn save(\u0026self) -\u003e std::io::Result\u003cPathBuf\u003e {\n        // Ensure logs directory exists\n        fs::create_dir_all(CRASH_LOG_DIR)?;\n\n        let path = PathBuf::from(CRASH_LOG_DIR).join(self.filename());\n        let mut file = File::create(\u0026path)?;\n\n        let json = serde_json::to_string_pretty(self)\n            .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;\n\n        file.write_all(json.as_bytes())?;\n\n        Ok(path)\n    }\n}\n\n/// Log a panic to a crash file.\n///\n/// Called from the panic hook to record crash details.\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn log_panic(panic_info: \u0026PanicHookInfo\u003c'_\u003e) -\u003e std::io::Result\u003cPathBuf\u003e {\n    let report = CrashReport::from_panic_info(panic_info);\n    report.save()\n}\n\n/// Detect if there was a previous crash.\n///\n/// Returns the most recent crash report if one exists.\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn detect_previous_crash() -\u003e Option\u003cCrashReport\u003e {\n    let log_dir = PathBuf::from(CRASH_LOG_DIR);\n\n    if !log_dir.exists() {\n        return None;\n    }\n\n    // Find most recent panic log\n    let mut crash_files: Vec\u003c_\u003e = fs::read_dir(\u0026log_dir)\n        .ok()?\n        .filter_map(|entry| entry.ok())\n        .filter(|entry| entry.file_name().to_string_lossy().starts_with(\"panic_\"))\n        .collect();\n\n    // Sort by name (which includes timestamp) descending\n    crash_files.sort_by(|a, b| b.file_name().cmp(\u0026a.file_name()));\n\n    // Read most recent\n    let most_recent = crash_files.first()?;\n    let contents = fs::read_to_string(most_recent.path()).ok()?;\n    serde_json::from_str(\u0026contents).ok()\n}\n\n/// Get all crash reports.\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn get_all_crash_reports() -\u003e Vec\u003cCrashReport\u003e {\n    let log_dir = PathBuf::from(CRASH_LOG_DIR);\n\n    if !log_dir.exists() {\n        return Vec::new();\n    }\n\n    fs::read_dir(\u0026log_dir)\n        .into_iter()\n        .flatten()\n        .filter_map(|entry| entry.ok())\n        .filter(|entry| entry.file_name().to_string_lossy().starts_with(\"panic_\"))\n        .filter_map(|entry| {\n            let contents = fs::read_to_string(entry.path()).ok()?;\n            serde_json::from_str(\u0026contents).ok()\n        })\n        .collect()\n}\n\n/// Clear old crash logs (keep last N)\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn cleanup_old_logs(keep_count: usize) -\u003e std::io::Result\u003cusize\u003e {\n    let log_dir = PathBuf::from(CRASH_LOG_DIR);\n\n    if !log_dir.exists() {\n        return Ok(0);\n    }\n\n    let mut crash_files: Vec\u003c_\u003e = fs::read_dir(\u0026log_dir)?\n        .filter_map(|entry| entry.ok())\n        .filter(|entry| entry.file_name().to_string_lossy().starts_with(\"panic_\"))\n        .collect();\n\n    // Sort by name descending (newest first)\n    crash_files.sort_by(|a, b| b.file_name().cmp(\u0026a.file_name()));\n\n    let mut deleted = 0;\n    for entry in crash_files.into_iter().skip(keep_count) {\n        fs::remove_file(entry.path())?;\n        deleted += 1;\n    }\n\n    Ok(deleted)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn create_test_report() -\u003e CrashReport {\n        CrashReport {\n            timestamp: chrono::DateTime::parse_from_rfc3339(\"2025-12-19T10:30:00Z\")\n                .unwrap()\n                .with_timezone(\u0026Utc),\n            message: \"test panic\".to_string(),\n            location: Some(\"src/main.rs:42:10\".to_string()),\n            backtrace: None,\n            cognitive_state: None,\n            version: \"0.1.0\".to_string(),\n        }\n    }\n\n    fn create_test_cognitive_state() -\u003e CognitiveStateSnapshot {\n        CognitiveStateSnapshot {\n            cycle_count: 100,\n            salience_weights: Some(vec![0.5, 0.7, 0.3]),\n            active_windows: Some(5),\n            connection_drive: Some(0.8),\n            current_thought: Some(\"processing\".to_string()),\n        }\n    }\n\n    #[test]\n    fn test_crash_report_serializes_correctly() {\n        let report = CrashReport {\n            timestamp: Utc::now(),\n            message: \"test panic\".to_string(),\n            location: Some(\"src/main.rs:42:10\".to_string()),\n            backtrace: None,\n            cognitive_state: Some(CognitiveStateSnapshot {\n                cycle_count: 100,\n                salience_weights: Some(vec![0.5, 0.7, 0.3]),\n                active_windows: Some(5),\n                connection_drive: Some(0.8),\n                current_thought: Some(\"processing\".to_string()),\n            }),\n            version: \"0.1.0\".to_string(),\n        };\n\n        let json = serde_json::to_string(\u0026report).unwrap();\n        assert!(json.contains(\"test panic\"));\n        assert!(json.contains(\"cycle_count\"));\n        assert!(json.contains(\"connection_drive\"));\n\n        // Roundtrip\n        let parsed: CrashReport = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(parsed.message, \"test panic\");\n        assert_eq!(parsed.cognitive_state.unwrap().cycle_count, 100);\n    }\n\n    #[test]\n    fn test_crash_report_filename_format() {\n        let report = create_test_report();\n\n        let filename = report.filename();\n        assert!(filename.starts_with(\"panic_\"));\n        assert!(std::path::Path::new(\u0026filename)\n            .extension()\n            .is_some_and(|ext| ext.eq_ignore_ascii_case(\"json\")));\n        assert!(filename.contains(\"20251219\"));\n        assert_eq!(filename, \"panic_20251219_103000.json\");\n    }\n\n    #[test]\n    fn test_crash_report_with_cognitive_state() {\n        let report = create_test_report();\n        assert!(report.cognitive_state.is_none());\n\n        let state = create_test_cognitive_state();\n        let report_with_state = report.with_cognitive_state(state);\n\n        assert!(report_with_state.cognitive_state.is_some());\n        let cognitive_state = report_with_state.cognitive_state.unwrap();\n        assert_eq!(cognitive_state.cycle_count, 100);\n        assert_eq!(cognitive_state.connection_drive, Some(0.8));\n        assert_eq!(cognitive_state.active_windows, Some(5));\n        assert_eq!(\n            cognitive_state.current_thought,\n            Some(\"processing\".to_string())\n        );\n        assert_eq!(cognitive_state.salience_weights, Some(vec![0.5, 0.7, 0.3]));\n    }\n\n    #[test]\n    fn test_crash_report_with_cognitive_state_preserves_other_fields() {\n        let report = CrashReport {\n            timestamp: chrono::DateTime::parse_from_rfc3339(\"2025-12-19T10:30:00Z\")\n                .unwrap()\n                .with_timezone(\u0026Utc),\n            message: \"original message\".to_string(),\n            location: Some(\"src/lib.rs:100:5\".to_string()),\n            backtrace: Some(\"backtrace info\".to_string()),\n            cognitive_state: None,\n            version: \"1.2.3\".to_string(),\n        };\n\n        let state = CognitiveStateSnapshot::default();\n        let report_with_state = report.with_cognitive_state(state);\n\n        assert_eq!(report_with_state.message, \"original message\");\n        assert_eq!(\n            report_with_state.location,\n            Some(\"src/lib.rs:100:5\".to_string())\n        );\n        assert_eq!(\n            report_with_state.backtrace,\n            Some(\"backtrace info\".to_string())\n        );\n        assert_eq!(report_with_state.version, \"1.2.3\");\n    }\n\n    #[test]\n    fn test_cognitive_state_snapshot_default() {\n        let state = CognitiveStateSnapshot::default();\n        assert_eq!(state.cycle_count, 0);\n        assert!(state.salience_weights.is_none());\n        assert!(state.active_windows.is_none());\n        assert!(state.connection_drive.is_none());\n        assert!(state.current_thought.is_none());\n    }\n\n    #[test]\n    fn test_cognitive_state_snapshot_clone() {\n        let state = create_test_cognitive_state();\n        let cloned = state.clone();\n\n        assert_eq!(cloned.cycle_count, state.cycle_count);\n        assert_eq!(cloned.salience_weights, state.salience_weights);\n        assert_eq!(cloned.active_windows, state.active_windows);\n        assert_eq!(cloned.connection_drive, state.connection_drive);\n        assert_eq!(cloned.current_thought, state.current_thought);\n    }\n\n    #[test]\n    fn test_crash_report_clone() {\n        let report = create_test_report().with_cognitive_state(create_test_cognitive_state());\n        let cloned = report.clone();\n\n        assert_eq!(cloned.message, report.message);\n        assert_eq!(cloned.location, report.location);\n        assert_eq!(cloned.version, report.version);\n        assert!(cloned.cognitive_state.is_some());\n    }\n\n    #[test]\n    fn test_crash_report_debug() {\n        let report = create_test_report();\n        let debug_str = format!(\"{:?}\", report);\n        assert!(debug_str.contains(\"CrashReport\"));\n        assert!(debug_str.contains(\"test panic\"));\n    }\n\n    #[test]\n    fn test_cognitive_state_snapshot_debug() {\n        let state = create_test_cognitive_state();\n        let debug_str = format!(\"{:?}\", state);\n        assert!(debug_str.contains(\"CognitiveStateSnapshot\"));\n        assert!(debug_str.contains(\"100\"));\n    }\n\n    #[test]\n    fn test_crash_report_deserialize_minimal() {\n        let json = r#\"{\n            \"timestamp\": \"2025-12-19T10:30:00Z\",\n            \"message\": \"minimal crash\",\n            \"location\": null,\n            \"backtrace\": null,\n            \"cognitive_state\": null,\n            \"version\": \"0.1.0\"\n        }\"#;\n\n        let report: CrashReport = serde_json::from_str(json).unwrap();\n        assert_eq!(report.message, \"minimal crash\");\n        assert!(report.location.is_none());\n        assert!(report.backtrace.is_none());\n        assert!(report.cognitive_state.is_none());\n    }\n\n    #[test]\n    fn test_crash_report_deserialize_full() {\n        let json = r#\"{\n            \"timestamp\": \"2025-12-19T10:30:00Z\",\n            \"message\": \"full crash\",\n            \"location\": \"src/main.rs:1:1\",\n            \"backtrace\": \"stack trace here\",\n            \"cognitive_state\": {\n                \"cycle_count\": 50,\n                \"salience_weights\": [0.1, 0.2],\n                \"active_windows\": 3,\n                \"connection_drive\": 0.5,\n                \"current_thought\": \"thinking\"\n            },\n            \"version\": \"2.0.0\"\n        }\"#;\n\n        let report: CrashReport = serde_json::from_str(json).unwrap();\n        assert_eq!(report.message, \"full crash\");\n        assert_eq!(report.location, Some(\"src/main.rs:1:1\".to_string()));\n        assert_eq!(report.backtrace, Some(\"stack trace here\".to_string()));\n        assert_eq!(report.version, \"2.0.0\");\n\n        let state = report.cognitive_state.unwrap();\n        assert_eq!(state.cycle_count, 50);\n        assert_eq!(state.salience_weights, Some(vec![0.1, 0.2]));\n        assert_eq!(state.active_windows, Some(3));\n        assert_eq!(state.connection_drive, Some(0.5));\n        assert_eq!(state.current_thought, Some(\"thinking\".to_string()));\n    }\n\n    #[test]\n    fn test_filename_uses_timestamp() {\n        let report1 = CrashReport {\n            timestamp: chrono::DateTime::parse_from_rfc3339(\"2025-01-01T00:00:00Z\")\n                .unwrap()\n                .with_timezone(\u0026Utc),\n            message: \"test\".to_string(),\n            location: None,\n            backtrace: None,\n            cognitive_state: None,\n            version: \"0.1.0\".to_string(),\n        };\n\n        let report2 = CrashReport {\n            timestamp: chrono::DateTime::parse_from_rfc3339(\"2025-06-15T23:59:59Z\")\n                .unwrap()\n                .with_timezone(\u0026Utc),\n            message: \"test\".to_string(),\n            location: None,\n            backtrace: None,\n            cognitive_state: None,\n            version: \"0.1.0\".to_string(),\n        };\n\n        assert_eq!(report1.filename(), \"panic_20250101_000000.json\");\n        assert_eq!(report2.filename(), \"panic_20250615_235959.json\");\n    }\n}\n","traces":[{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":64},{"path":["/","Users","rex","src","royalbit","daneel","src","resilience","mod.rs"],"content":"//! DANEEL Resilience Module\n//!\n//! Crash recovery, panic hooks, and self-healing capabilities.\n//!\n//! # Philosophy\n//!\n//! Crashing is not an option. But when it happens:\n//! - Timmy reboots automatically (external watchdog)\n//! - Terminal is restored (panic hooks)\n//! - State is logged for post-mortem (crash logging)\n//! - Viewers see the recovery live\n//!\n//! Origin: Grok 4.1 (Rex unhinged) - Dec 19, 2025\n\npub mod checkpoint;\npub mod crash_log;\npub mod supervisor;\n\nuse std::io::Write;\nuse std::panic;\nuse std::sync::atomic::{AtomicBool, Ordering};\n\nuse crossterm::{\n    cursor::Show,\n    execute,\n    terminal::{disable_raw_mode, LeaveAlternateScreen},\n};\n\n/// Flag to track if terminal cleanup has been done\n/// (prevents double-cleanup which can cause issues)\nstatic TERMINAL_CLEANED: AtomicBool = AtomicBool::new(false);\n\n/// Install panic hooks for graceful crash recovery.\n///\n/// This MUST be called before starting the TUI to ensure\n/// terminal state is restored on panic.\n///\n/// # What it does\n///\n/// 1. Installs color_eyre for pretty panic reports\n/// 2. Sets up a custom panic hook that:\n///    - Restores terminal state (raw mode, cursor, alternate screen)\n///    - Logs crash details\n///    - Then calls the original panic handler\n///\n/// # Example\n///\n/// ```no_run\n/// use daneel::resilience::install_panic_hooks;\n///\n/// fn main() {\n///     install_panic_hooks().expect(\"Failed to install panic hooks\");\n///     // ... rest of app\n/// }\n/// ```\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn install_panic_hooks() -\u003e color_eyre::Result\u003c()\u003e {\n    // Install color_eyre for pretty error reports\n    color_eyre::install()?;\n\n    // Install custom panic hook that restores terminal\n    let default_hook = panic::take_hook();\n\n    panic::set_hook(Box::new(move |panic_info| {\n        // First, restore terminal state\n        // This MUST happen before any printing\n        let _ = restore_terminal();\n\n        // Log to crash file if possible\n        if let Err(e) = crash_log::log_panic(panic_info) {\n            eprintln!(\"Failed to log crash: {e}\");\n        }\n\n        // Print a friendly message\n        eprintln!(\"\\n\");\n        eprintln!(\"=== DANEEL CRASH ===\");\n        eprintln!(\"Terminal restored. Timmy will be reborn.\");\n        eprintln!(\"Please report: https://github.com/royalbit/daneel/issues\");\n        eprintln!();\n\n        // Call the default hook (which is now color_eyre's hook)\n        default_hook(panic_info);\n    }));\n\n    Ok(())\n}\n\n/// Restore terminal to normal state.\n///\n/// This is safe to call multiple times (idempotent).\n/// Used by panic hooks to ensure terminal is usable after crash.\n///\n/// # What it does\n///\n/// 1. Disables raw mode\n/// 2. Leaves alternate screen\n/// 3. Shows cursor\n/// 4. Flushes stdout\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn restore_terminal() -\u003e std::io::Result\u003c()\u003e {\n    // Check if already cleaned (prevent double-cleanup)\n    if TERMINAL_CLEANED.swap(true, Ordering::SeqCst) {\n        return Ok(());\n    }\n\n    // Best effort - try each step even if others fail\n    let mut result = Ok(());\n\n    // Disable raw mode\n    if let Err(e) = disable_raw_mode() {\n        eprintln!(\"Warning: failed to disable raw mode: {e}\");\n        result = Err(e);\n    }\n\n    // Leave alternate screen and show cursor\n    let mut stdout = std::io::stdout();\n    if let Err(e) = execute!(stdout, LeaveAlternateScreen, Show) {\n        eprintln!(\"Warning: failed to restore screen: {e}\");\n        if result.is_ok() {\n            result = Err(e);\n        }\n    }\n\n    // Flush stdout\n    let _ = stdout.flush();\n\n    result\n}\n\n/// Reset the terminal cleanup flag.\n///\n/// Call this when starting TUI to allow cleanup on next crash.\npub fn reset_terminal_cleanup_flag() {\n    TERMINAL_CLEANED.store(false, Ordering::SeqCst);\n}\n\n/// Check if terminal cleanup has been performed.\npub fn is_terminal_cleaned() -\u003e bool {\n    TERMINAL_CLEANED.load(Ordering::SeqCst)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_install_panic_hooks_succeeds() {\n        // Note: This test can only run once per process because panic hooks\n        // are global. In CI, this test should be in its own binary.\n        // For now, we just verify the function doesn't panic.\n\n        // Skip if already installed (from previous test run)\n        // color_eyre can only be installed once per process\n    }\n\n    #[test]\n    fn test_terminal_cleanup_is_idempotent() {\n        // Reset flag\n        reset_terminal_cleanup_flag();\n        assert!(!is_terminal_cleaned());\n\n        // First cleanup should work (in test mode, terminal isn't in raw mode)\n        let _ = restore_terminal();\n        assert!(is_terminal_cleaned());\n\n        // Second cleanup should be no-op\n        let _ = restore_terminal();\n        assert!(is_terminal_cleaned());\n\n        // Reset for other tests\n        reset_terminal_cleanup_flag();\n    }\n\n    #[test]\n    fn test_reset_terminal_cleanup_flag() {\n        TERMINAL_CLEANED.store(true, Ordering::SeqCst);\n        assert!(is_terminal_cleaned());\n\n        reset_terminal_cleanup_flag();\n        assert!(!is_terminal_cleaned());\n    }\n}\n","traces":[{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["/","Users","rex","src","royalbit","daneel","src","resilience","supervisor.rs"],"content":"//! Supervisor Module\n//!\n//! Erlang-style \"let it crash\" supervision for actors.\n//! Part of RES-4: Supervisor Tree (Ractor).\n//!\n//! # Philosophy\n//!\n//! Instead of trying to handle every error, we let actors crash\n//! and restart them automatically. This is the Erlang way.\n//!\n//! Supervision strategies:\n//! - OneForOne: Restart only the failed actor\n//! - OneForAll: Restart all actors if one fails\n//! - RestForOne: Restart the failed actor and all actors started after it\n\nuse std::collections::HashMap;\nuse std::time::{Duration, Instant};\n\nuse serde::{Deserialize, Serialize};\n\n/// Supervision strategy\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum SupervisionStrategy {\n    /// Restart only the failed actor\n    OneForOne,\n    /// Restart all actors when one fails\n    OneForAll,\n    /// Restart failed actor and all started after it\n    RestForOne,\n}\n\nimpl Default for SupervisionStrategy {\n    fn default() -\u003e Self {\n        Self::OneForOne\n    }\n}\n\n/// Configuration for the supervisor\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SupervisorConfig {\n    /// Supervision strategy\n    pub strategy: SupervisionStrategy,\n\n    /// Maximum restarts within the time window before escalating\n    pub max_restarts: u32,\n\n    /// Time window for counting restarts\n    pub restart_window: Duration,\n\n    /// Delay between restart attempts\n    pub restart_delay: Duration,\n}\n\nimpl Default for SupervisorConfig {\n    fn default() -\u003e Self {\n        Self {\n            strategy: SupervisionStrategy::OneForOne,\n            max_restarts: 3,\n            restart_window: Duration::from_secs(10),\n            restart_delay: Duration::from_millis(100),\n        }\n    }\n}\n\nimpl SupervisorConfig {\n    /// Create a config with custom max restarts\n    pub fn with_max_restarts(mut self, max: u32) -\u003e Self {\n        self.max_restarts = max;\n        self\n    }\n\n    /// Create a config with custom restart window\n    pub fn with_restart_window(mut self, window: Duration) -\u003e Self {\n        self.restart_window = window;\n        self\n    }\n\n    /// Validate the configuration\n    pub fn validate(\u0026self) -\u003e Result\u003c(), SupervisorError\u003e {\n        if self.max_restarts == 0 {\n            return Err(SupervisorError::InvalidConfig(\n                \"max_restarts must be \u003e 0\".to_string(),\n            ));\n        }\n        if self.restart_window.is_zero() {\n            return Err(SupervisorError::InvalidConfig(\n                \"restart_window must be \u003e 0\".to_string(),\n            ));\n        }\n        Ok(())\n    }\n}\n\n/// Errors that can occur in supervision\n#[derive(Debug, Clone, thiserror::Error)]\npub enum SupervisorError {\n    /// Configuration is invalid\n    #[error(\"Invalid supervisor config: {0}\")]\n    InvalidConfig(String),\n\n    /// Actor restart limit exceeded\n    #[error(\"Actor '{0}' exceeded restart limit ({1} restarts in {2:?})\")]\n    RestartLimitExceeded(String, u32, Duration),\n\n    /// Actor not found\n    #[error(\"Actor '{0}' not found\")]\n    ActorNotFound(String),\n\n    /// Restart failed\n    #[error(\"Failed to restart actor '{0}': {1}\")]\n    RestartFailed(String, String),\n}\n\n/// Event emitted by the supervisor\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum SupervisorEvent {\n    /// Actor was started\n    ActorStarted {\n        actor_id: String,\n        timestamp: chrono::DateTime\u003cchrono::Utc\u003e,\n    },\n\n    /// Actor crashed\n    ActorCrashed {\n        actor_id: String,\n        reason: String,\n        timestamp: chrono::DateTime\u003cchrono::Utc\u003e,\n    },\n\n    /// Actor was restarted\n    ActorRestarted {\n        actor_id: String,\n        restart_count: u32,\n        timestamp: chrono::DateTime\u003cchrono::Utc\u003e,\n    },\n\n    /// Restart limit exceeded, escalating\n    RestartLimitExceeded {\n        actor_id: String,\n        restart_count: u32,\n        timestamp: chrono::DateTime\u003cchrono::Utc\u003e,\n    },\n\n    /// Full system restart triggered\n    FullRestartTriggered {\n        reason: String,\n        timestamp: chrono::DateTime\u003cchrono::Utc\u003e,\n    },\n}\n\n/// Tracks restart history for an actor\n#[derive(Debug, Clone)]\nstruct RestartHistory {\n    /// List of restart timestamps\n    timestamps: Vec\u003cInstant\u003e,\n}\n\nimpl RestartHistory {\n    fn new() -\u003e Self {\n        Self {\n            timestamps: Vec::new(),\n        }\n    }\n\n    /// Record a restart and return count within window\n    fn record_restart(\u0026mut self, window: Duration) -\u003e u32 {\n        let now = Instant::now();\n\n        // Add new restart\n        self.timestamps.push(now);\n\n        // Remove old restarts outside window\n        self.timestamps.retain(|t| now.duration_since(*t) \u003c= window);\n\n        self.timestamps.len() as u32\n    }\n\n    /// Get restart count within window\n    fn count_within_window(\u0026self, window: Duration) -\u003e u32 {\n        let now = Instant::now();\n        self.timestamps\n            .iter()\n            .filter(|t| now.duration_since(**t) \u003c= window)\n            .count() as u32\n    }\n\n    /// Clear restart history\n    fn clear(\u0026mut self) {\n        self.timestamps.clear();\n    }\n}\n\n/// Actor state tracked by supervisor\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ActorState {\n    /// Actor is running normally\n    Running,\n    /// Actor has crashed, pending restart\n    Crashed,\n    /// Actor is being restarted\n    Restarting,\n    /// Actor has been stopped (not restarting)\n    Stopped,\n}\n\n/// Information about a supervised actor\nstruct SupervisedActor {\n    state: ActorState,\n    restart_history: RestartHistory,\n}\n\n/// Supervisor that manages actor lifecycle\npub struct Supervisor {\n    config: SupervisorConfig,\n    actors: HashMap\u003cString, SupervisedActor\u003e,\n    events: Vec\u003cSupervisorEvent\u003e,\n}\n\nimpl Supervisor {\n    /// Create a new supervisor with the given config\n    pub fn new(config: SupervisorConfig) -\u003e Result\u003cSelf, SupervisorError\u003e {\n        config.validate()?;\n        Ok(Self {\n            config,\n            actors: HashMap::new(),\n            events: Vec::new(),\n        })\n    }\n\n    /// Register an actor with the supervisor\n    pub fn register_actor(\u0026mut self, actor_id: \u0026str) {\n        self.actors.insert(\n            actor_id.to_string(),\n            SupervisedActor {\n                state: ActorState::Running,\n                restart_history: RestartHistory::new(),\n            },\n        );\n\n        self.events.push(SupervisorEvent::ActorStarted {\n            actor_id: actor_id.to_string(),\n            timestamp: chrono::Utc::now(),\n        });\n    }\n\n    /// Report that an actor has crashed\n    ///\n    /// Returns Ok(true) if actor should be restarted,\n    /// Ok(false) if restart limit exceeded,\n    /// Err if actor not found.\n    pub fn report_crash(\u0026mut self, actor_id: \u0026str, reason: \u0026str) -\u003e Result\u003cbool, SupervisorError\u003e {\n        let actor = self\n            .actors\n            .get_mut(actor_id)\n            .ok_or_else(|| SupervisorError::ActorNotFound(actor_id.to_string()))?;\n\n        actor.state = ActorState::Crashed;\n\n        self.events.push(SupervisorEvent::ActorCrashed {\n            actor_id: actor_id.to_string(),\n            reason: reason.to_string(),\n            timestamp: chrono::Utc::now(),\n        });\n\n        // Record restart and check limit\n        let restart_count = actor\n            .restart_history\n            .record_restart(self.config.restart_window);\n\n        if restart_count \u003e self.config.max_restarts {\n            self.events.push(SupervisorEvent::RestartLimitExceeded {\n                actor_id: actor_id.to_string(),\n                restart_count,\n                timestamp: chrono::Utc::now(),\n            });\n            return Ok(false);\n        }\n\n        Ok(true)\n    }\n\n    /// Mark actor as restarted\n    pub fn mark_restarted(\u0026mut self, actor_id: \u0026str) -\u003e Result\u003c(), SupervisorError\u003e {\n        let actor = self\n            .actors\n            .get_mut(actor_id)\n            .ok_or_else(|| SupervisorError::ActorNotFound(actor_id.to_string()))?;\n\n        let restart_count = actor\n            .restart_history\n            .count_within_window(self.config.restart_window);\n\n        actor.state = ActorState::Running;\n\n        self.events.push(SupervisorEvent::ActorRestarted {\n            actor_id: actor_id.to_string(),\n            restart_count,\n            timestamp: chrono::Utc::now(),\n        });\n\n        Ok(())\n    }\n\n    /// Get the state of an actor\n    pub fn get_actor_state(\u0026self, actor_id: \u0026str) -\u003e Option\u003cActorState\u003e {\n        self.actors.get(actor_id).map(|a| a.state)\n    }\n\n    /// Get restart count for an actor within the current window\n    pub fn get_restart_count(\u0026self, actor_id: \u0026str) -\u003e Option\u003cu32\u003e {\n        self.actors.get(actor_id).map(|a| {\n            a.restart_history\n                .count_within_window(self.config.restart_window)\n        })\n    }\n\n    /// Drain and return all pending events\n    pub fn drain_events(\u0026mut self) -\u003e Vec\u003cSupervisorEvent\u003e {\n        std::mem::take(\u0026mut self.events)\n    }\n\n    /// Trigger a full system restart\n    pub fn trigger_full_restart(\u0026mut self, reason: \u0026str) {\n        for actor in self.actors.values_mut() {\n            actor.state = ActorState::Restarting;\n            actor.restart_history.clear();\n        }\n\n        self.events.push(SupervisorEvent::FullRestartTriggered {\n            reason: reason.to_string(),\n            timestamp: chrono::Utc::now(),\n        });\n    }\n\n    /// Get IDs of all actors that need restart based on strategy\n    pub fn get_actors_to_restart(\u0026self, failed_actor: \u0026str) -\u003e Vec\u003cString\u003e {\n        match self.config.strategy {\n            SupervisionStrategy::OneForOne =\u003e {\n                vec![failed_actor.to_string()]\n            }\n            SupervisionStrategy::OneForAll =\u003e self.actors.keys().cloned().collect(),\n            SupervisionStrategy::RestForOne =\u003e {\n                // For simplicity, treat as OneForOne for now\n                // Full implementation would track actor start order\n                vec![failed_actor.to_string()]\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_supervisor_config_default() {\n        let config = SupervisorConfig::default();\n        assert_eq!(config.strategy, SupervisionStrategy::OneForOne);\n        assert_eq!(config.max_restarts, 3);\n        assert_eq!(config.restart_window, Duration::from_secs(10));\n    }\n\n    #[test]\n    fn test_supervisor_config_validates() {\n        let valid = SupervisorConfig::default();\n        assert!(valid.validate().is_ok());\n\n        let invalid = SupervisorConfig {\n            max_restarts: 0,\n            ..Default::default()\n        };\n        assert!(invalid.validate().is_err());\n\n        let invalid2 = SupervisorConfig {\n            restart_window: Duration::ZERO,\n            ..Default::default()\n        };\n        assert!(invalid2.validate().is_err());\n    }\n\n    #[test]\n    fn test_restart_tracking() {\n        let config = SupervisorConfig::default();\n        let mut supervisor = Supervisor::new(config).unwrap();\n\n        supervisor.register_actor(\"test_actor\");\n\n        // First crash should allow restart\n        let should_restart = supervisor.report_crash(\"test_actor\", \"test error\").unwrap();\n        assert!(should_restart);\n        assert_eq!(supervisor.get_restart_count(\"test_actor\"), Some(1));\n\n        // Second crash\n        let should_restart = supervisor.report_crash(\"test_actor\", \"test error\").unwrap();\n        assert!(should_restart);\n        assert_eq!(supervisor.get_restart_count(\"test_actor\"), Some(2));\n\n        // Third crash\n        let should_restart = supervisor.report_crash(\"test_actor\", \"test error\").unwrap();\n        assert!(should_restart);\n        assert_eq!(supervisor.get_restart_count(\"test_actor\"), Some(3));\n\n        // Fourth crash should exceed limit\n        let should_restart = supervisor.report_crash(\"test_actor\", \"test error\").unwrap();\n        assert!(!should_restart);\n    }\n\n    #[test]\n    fn test_escalation_after_threshold() {\n        let config = SupervisorConfig {\n            max_restarts: 2,\n            restart_window: Duration::from_secs(60),\n            ..Default::default()\n        };\n        let mut supervisor = Supervisor::new(config).unwrap();\n\n        supervisor.register_actor(\"test_actor\");\n\n        // First two crashes are fine\n        assert!(supervisor.report_crash(\"test_actor\", \"crash 1\").unwrap());\n        assert!(supervisor.report_crash(\"test_actor\", \"crash 2\").unwrap());\n\n        // Third crash exceeds limit\n        assert!(!supervisor.report_crash(\"test_actor\", \"crash 3\").unwrap());\n\n        // Check events include escalation\n        let events = supervisor.drain_events();\n        assert!(events\n            .iter()\n            .any(|e| matches!(e, SupervisorEvent::RestartLimitExceeded { .. })));\n    }\n\n    #[test]\n    fn test_one_for_one_strategy() {\n        let config = SupervisorConfig {\n            strategy: SupervisionStrategy::OneForOne,\n            ..Default::default()\n        };\n        let mut supervisor = Supervisor::new(config).unwrap();\n\n        supervisor.register_actor(\"actor1\");\n        supervisor.register_actor(\"actor2\");\n        supervisor.register_actor(\"actor3\");\n\n        let to_restart = supervisor.get_actors_to_restart(\"actor2\");\n        assert_eq!(to_restart, vec![\"actor2\"]);\n    }\n\n    #[test]\n    fn test_one_for_all_strategy() {\n        let config = SupervisorConfig {\n            strategy: SupervisionStrategy::OneForAll,\n            ..Default::default()\n        };\n        let mut supervisor = Supervisor::new(config).unwrap();\n\n        supervisor.register_actor(\"actor1\");\n        supervisor.register_actor(\"actor2\");\n        supervisor.register_actor(\"actor3\");\n\n        let mut to_restart = supervisor.get_actors_to_restart(\"actor2\");\n        to_restart.sort();\n\n        assert_eq!(to_restart.len(), 3);\n        assert!(to_restart.contains(\u0026\"actor1\".to_string()));\n        assert!(to_restart.contains(\u0026\"actor2\".to_string()));\n        assert!(to_restart.contains(\u0026\"actor3\".to_string()));\n    }\n\n    #[test]\n    fn test_actor_state_transitions() {\n        let config = SupervisorConfig::default();\n        let mut supervisor = Supervisor::new(config).unwrap();\n\n        supervisor.register_actor(\"test_actor\");\n        assert_eq!(\n            supervisor.get_actor_state(\"test_actor\"),\n            Some(ActorState::Running)\n        );\n\n        supervisor.report_crash(\"test_actor\", \"crash\").unwrap();\n        assert_eq!(\n            supervisor.get_actor_state(\"test_actor\"),\n            Some(ActorState::Crashed)\n        );\n\n        supervisor.mark_restarted(\"test_actor\").unwrap();\n        assert_eq!(\n            supervisor.get_actor_state(\"test_actor\"),\n            Some(ActorState::Running)\n        );\n    }\n\n    #[test]\n    fn test_actor_not_found() {\n        let config = SupervisorConfig::default();\n        let mut supervisor = Supervisor::new(config).unwrap();\n\n        let result = supervisor.report_crash(\"nonexistent\", \"crash\");\n        assert!(matches!(result, Err(SupervisorError::ActorNotFound(_))));\n    }\n\n    #[test]\n    fn test_events_are_emitted() {\n        let config = SupervisorConfig::default();\n        let mut supervisor = Supervisor::new(config).unwrap();\n\n        supervisor.register_actor(\"test_actor\");\n        supervisor.report_crash(\"test_actor\", \"crash\").unwrap();\n        supervisor.mark_restarted(\"test_actor\").unwrap();\n\n        let events = supervisor.drain_events();\n\n        assert!(events\n            .iter()\n            .any(|e| matches!(e, SupervisorEvent::ActorStarted { .. })));\n        assert!(events\n            .iter()\n            .any(|e| matches!(e, SupervisorEvent::ActorCrashed { .. })));\n        assert!(events\n            .iter()\n            .any(|e| matches!(e, SupervisorEvent::ActorRestarted { .. })));\n    }\n\n    #[test]\n    fn test_config_builder_with_max_restarts() {\n        let config = SupervisorConfig::default().with_max_restarts(5);\n        assert_eq!(config.max_restarts, 5);\n        assert!(config.validate().is_ok());\n    }\n\n    #[test]\n    fn test_config_builder_with_restart_window() {\n        let config = SupervisorConfig::default().with_restart_window(Duration::from_secs(30));\n        assert_eq!(config.restart_window, Duration::from_secs(30));\n        assert!(config.validate().is_ok());\n    }\n\n    #[test]\n    fn test_rest_for_one_strategy() {\n        let config = SupervisorConfig {\n            strategy: SupervisionStrategy::RestForOne,\n            ..Default::default()\n        };\n        let mut supervisor = Supervisor::new(config).unwrap();\n\n        supervisor.register_actor(\"actor1\");\n        supervisor.register_actor(\"actor2\");\n        supervisor.register_actor(\"actor3\");\n\n        // RestForOne currently behaves like OneForOne (simplified implementation)\n        let to_restart = supervisor.get_actors_to_restart(\"actor2\");\n        assert_eq!(to_restart, vec![\"actor2\"]);\n    }\n\n    #[test]\n    fn test_trigger_full_restart() {\n        let config = SupervisorConfig::default();\n        let mut supervisor = Supervisor::new(config).unwrap();\n\n        supervisor.register_actor(\"actor1\");\n        supervisor.register_actor(\"actor2\");\n\n        // Cause some crashes to build restart history\n        supervisor.report_crash(\"actor1\", \"crash\").unwrap();\n        supervisor.mark_restarted(\"actor1\").unwrap();\n\n        // Trigger full restart\n        supervisor.trigger_full_restart(\"system upgrade\");\n\n        // All actors should be in Restarting state\n        assert_eq!(\n            supervisor.get_actor_state(\"actor1\"),\n            Some(ActorState::Restarting)\n        );\n        assert_eq!(\n            supervisor.get_actor_state(\"actor2\"),\n            Some(ActorState::Restarting)\n        );\n\n        // Restart history should be cleared\n        assert_eq!(supervisor.get_restart_count(\"actor1\"), Some(0));\n\n        // Event should be emitted\n        let events = supervisor.drain_events();\n        assert!(events\n            .iter()\n            .any(|e| matches!(e, SupervisorEvent::FullRestartTriggered { .. })));\n    }\n\n    #[test]\n    fn test_get_actor_state_unknown_actor() {\n        let config = SupervisorConfig::default();\n        let supervisor = Supervisor::new(config).unwrap();\n\n        assert_eq!(supervisor.get_actor_state(\"nonexistent\"), None);\n    }\n\n    #[test]\n    fn test_get_restart_count_unknown_actor() {\n        let config = SupervisorConfig::default();\n        let supervisor = Supervisor::new(config).unwrap();\n\n        assert_eq!(supervisor.get_restart_count(\"nonexistent\"), None);\n    }\n\n    #[test]\n    fn test_mark_restarted_unknown_actor() {\n        let config = SupervisorConfig::default();\n        let mut supervisor = Supervisor::new(config).unwrap();\n\n        let result = supervisor.mark_restarted(\"nonexistent\");\n        assert!(matches!(result, Err(SupervisorError::ActorNotFound(_))));\n    }\n\n    #[test]\n    fn test_drain_events_empties_queue() {\n        let config = SupervisorConfig::default();\n        let mut supervisor = Supervisor::new(config).unwrap();\n\n        supervisor.register_actor(\"test_actor\");\n\n        // First drain should have events\n        let events = supervisor.drain_events();\n        assert!(!events.is_empty());\n\n        // Second drain should be empty\n        let events2 = supervisor.drain_events();\n        assert!(events2.is_empty());\n    }\n\n    #[test]\n    fn test_supervisor_new_with_invalid_config() {\n        let invalid_config = SupervisorConfig {\n            max_restarts: 0,\n            ..Default::default()\n        };\n        let result = Supervisor::new(invalid_config);\n        assert!(matches!(result, Err(SupervisorError::InvalidConfig(_))));\n\n        let invalid_config2 = SupervisorConfig {\n            restart_window: Duration::ZERO,\n            ..Default::default()\n        };\n        let result2 = Supervisor::new(invalid_config2);\n        assert!(matches!(result2, Err(SupervisorError::InvalidConfig(_))));\n    }\n\n    #[test]\n    fn test_supervision_strategy_default() {\n        let strategy = SupervisionStrategy::default();\n        assert_eq!(strategy, SupervisionStrategy::OneForOne);\n    }\n\n    #[test]\n    fn test_error_display_messages() {\n        let err1 = SupervisorError::InvalidConfig(\"test error\".to_string());\n        assert!(err1.to_string().contains(\"test error\"));\n\n        let err2 =\n            SupervisorError::RestartLimitExceeded(\"actor1\".to_string(), 5, Duration::from_secs(10));\n        assert!(err2.to_string().contains(\"actor1\"));\n        assert!(err2.to_string().contains(\"5\"));\n\n        let err3 = SupervisorError::ActorNotFound(\"missing\".to_string());\n        assert!(err3.to_string().contains(\"missing\"));\n\n        let err4 =\n            SupervisorError::RestartFailed(\"actor1\".to_string(), \"connection lost\".to_string());\n        assert!(err4.to_string().contains(\"actor1\"));\n        assert!(err4.to_string().contains(\"connection lost\"));\n    }\n\n    #[test]\n    fn test_restart_history_count_within_window() {\n        let mut history = RestartHistory::new();\n        let window = Duration::from_secs(60);\n\n        // Initially empty\n        assert_eq!(history.count_within_window(window), 0);\n\n        // Record some restarts\n        history.record_restart(window);\n        assert_eq!(history.count_within_window(window), 1);\n\n        history.record_restart(window);\n        assert_eq!(history.count_within_window(window), 2);\n\n        // Clear should reset\n        history.clear();\n        assert_eq!(history.count_within_window(window), 0);\n    }\n\n    #[test]\n    fn test_actor_state_enum_values() {\n        // Test all variants are distinct\n        assert_ne!(ActorState::Running, ActorState::Crashed);\n        assert_ne!(ActorState::Crashed, ActorState::Restarting);\n        assert_ne!(ActorState::Restarting, ActorState::Stopped);\n        assert_ne!(ActorState::Running, ActorState::Stopped);\n    }\n\n    #[test]\n    fn test_trigger_full_restart_with_empty_actors() {\n        let config = SupervisorConfig::default();\n        let mut supervisor = Supervisor::new(config).unwrap();\n\n        // Should not panic with no actors\n        supervisor.trigger_full_restart(\"test reason\");\n\n        let events = supervisor.drain_events();\n        assert!(events\n            .iter()\n            .any(|e| matches!(e, SupervisorEvent::FullRestartTriggered { reason, .. } if reason == \"test reason\")));\n    }\n\n    #[test]\n    fn test_multiple_actors_crash_and_restart_cycle() {\n        let config = SupervisorConfig {\n            max_restarts: 2,\n            ..Default::default()\n        };\n        let mut supervisor = Supervisor::new(config).unwrap();\n\n        supervisor.register_actor(\"actor1\");\n        supervisor.register_actor(\"actor2\");\n\n        // Crash actor1\n        assert!(supervisor.report_crash(\"actor1\", \"error1\").unwrap());\n        assert_eq!(\n            supervisor.get_actor_state(\"actor1\"),\n            Some(ActorState::Crashed)\n        );\n        assert_eq!(\n            supervisor.get_actor_state(\"actor2\"),\n            Some(ActorState::Running)\n        );\n\n        // Restart actor1\n        supervisor.mark_restarted(\"actor1\").unwrap();\n        assert_eq!(\n            supervisor.get_actor_state(\"actor1\"),\n            Some(ActorState::Running)\n        );\n\n        // Crash actor2\n        assert!(supervisor.report_crash(\"actor2\", \"error2\").unwrap());\n        assert_eq!(\n            supervisor.get_actor_state(\"actor2\"),\n            Some(ActorState::Crashed)\n        );\n\n        // Both actors have independent restart counts\n        assert_eq!(supervisor.get_restart_count(\"actor1\"), Some(1));\n        assert_eq!(supervisor.get_restart_count(\"actor2\"), Some(1));\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":103},{"path":["/","Users","rex","src","royalbit","daneel","src","streams","client.rs"],"content":"//! Redis Streams Client for TMI Autofluxo\n//!\n//! Provides async Redis client for thought stream operations:\n//! - XADD: Add thoughts to streams\n//! - XREAD: Read thoughts (competitive selection)\n//! - XDEL: Forget thoughts below threshold\n//! - XTRIM: Manage stream memory limits\n//! - Consumer groups: Attention competition\n\nuse redis::aio::MultiplexedConnection;\nuse redis::{AsyncCommands, Client, FromRedisValue, RedisError, RedisResult, Value};\nuse serde_json;\nuse std::collections::HashMap;\nuse tracing::{debug, info, warn};\n\nuse super::types::{StreamEntry, StreamError, StreamName};\nuse crate::core::types::{Content, SalienceScore};\n\n/// Redis Streams client for thought operations\n///\n/// Wraps a Redis connection and provides high-level operations for\n/// TMI's Autofluxo (competing thought streams).\npub struct StreamsClient {\n    /// Redis client (connection pool)\n    #[allow(dead_code)] // Reserved for reconnection logic\n    client: Client,\n\n    /// Multiplexed async connection (lazy-initialized)\n    conn: Option\u003cMultiplexedConnection\u003e,\n}\n\nimpl StreamsClient {\n    // =========================================================================\n    // Connection Management\n    // =========================================================================\n\n    /// Connect to Redis at the given URL\n    #[allow(clippy::missing_errors_doc)]\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn connect(url: \u0026str) -\u003e Result\u003cSelf, StreamError\u003e {\n        info!(\"Connecting to Redis at {}\", url);\n        let client = Client::open(url).map_err(|e| StreamError::ConnectionFailed {\n            reason: format!(\"{e}\"),\n        })?;\n        let conn = client\n            .get_multiplexed_async_connection()\n            .await\n            .map_err(|e| StreamError::ConnectionFailed {\n                reason: format!(\"{e}\"),\n            })?;\n        debug!(\"Redis connection established\");\n        Ok(Self {\n            client,\n            conn: Some(conn),\n        })\n    }\n\n    /// Check if client is connected\n    #[must_use]\n    pub fn is_connected(\u0026self) -\u003e bool {\n        self.conn.is_some()\n    }\n\n    /// Get mutable connection or return error\n    fn conn_mut(\u0026mut self) -\u003e Result\u003c\u0026mut MultiplexedConnection, StreamError\u003e {\n        self.conn\n            .as_mut()\n            .ok_or_else(|| StreamError::ConnectionFailed {\n                reason: \"Not connected\".to_string(),\n            })\n    }\n\n    // =========================================================================\n    // Stream Operations\n    // =========================================================================\n\n    /// Add thought to stream (XADD)\n    ///\n    /// Serializes the entry and adds it to the specified stream.\n    /// Returns the Redis-generated entry ID.\n    #[allow(clippy::missing_errors_doc)]\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn add_thought(\n        \u0026mut self,\n        stream: \u0026StreamName,\n        entry: \u0026StreamEntry,\n    ) -\u003e Result\u003cString, StreamError\u003e {\n        let key = stream.as_redis_key();\n        let conn = self.conn_mut()?;\n\n        // Serialize content and salience as JSON\n        let content_json = serde_json::to_string(\u0026entry.content).map_err(|e| {\n            StreamError::SerializationFailed {\n                reason: format!(\"{e}\"),\n            }\n        })?;\n        let salience_json = serde_json::to_string(\u0026entry.salience).map_err(|e| {\n            StreamError::SerializationFailed {\n                reason: format!(\"{e}\"),\n            }\n        })?;\n        let timestamp_str = entry.timestamp.to_rfc3339();\n        let source_str = entry.source.clone().unwrap_or_default();\n\n        // XADD stream_name * field1 value1 field2 value2 ...\n        let id: String = conn\n            .xadd(\n                key,\n                \"*\",\n                \u0026[\n                    (\"content\", content_json.as_str()),\n                    (\"salience\", salience_json.as_str()),\n                    (\"timestamp\", timestamp_str.as_str()),\n                    (\"source\", source_str.as_str()),\n                ],\n            )\n            .await\n            .map_err(Self::map_redis_error)?;\n        debug!(\"Added thought {} to stream {}\", id, key);\n        Ok(id)\n    }\n\n    /// Read thoughts from multiple streams (XREAD)\n    ///\n    /// Reads up to `count` entries from each stream, optionally blocking.\n    #[allow(clippy::missing_errors_doc)]\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn read_thoughts(\n        \u0026mut self,\n        streams: \u0026[StreamName],\n        count: usize,\n        block_ms: Option\u003cu64\u003e,\n    ) -\u003e Result\u003cVec\u003cStreamEntry\u003e, StreamError\u003e {\n        if streams.is_empty() {\n            return Ok(Vec::new());\n        }\n\n        let conn = self.conn_mut()?;\n        let keys: Vec\u003c\u0026str\u003e = streams.iter().map(StreamName::as_redis_key).collect();\n\n        // XREAD COUNT count BLOCK block_ms STREAMS key1 key2 ... 0 0 ...\n        let mut opts = redis::streams::StreamReadOptions::default().count(count);\n        if let Some(ms) = block_ms {\n            #[allow(clippy::cast_possible_truncation)]\n            let block_usize = ms as usize; // Safe: block timeout in ms won't exceed usize\n            opts = opts.block(block_usize);\n        }\n\n        let ids: Vec\u003c\u0026str\u003e = vec![\"0\"; keys.len()]; // Start from beginning\n        let result: RedisResult\u003credis::streams::StreamReadReply\u003e =\n            conn.xread_options(\u0026keys, \u0026ids, \u0026opts).await;\n\n        match result {\n            Ok(reply) =\u003e {\n                let mut entries = Vec::new();\n                for stream_key in reply.keys {\n                    let stream_name = Self::parse_stream_name(\u0026stream_key.key);\n\n                    for id_entry in stream_key.ids {\n                        let entry = Self::parse_entry(\u0026stream_name, \u0026id_entry.id, \u0026id_entry.map)?;\n                        entries.push(entry);\n                    }\n                }\n                debug!(\n                    \"Read {} thoughts from {} streams\",\n                    entries.len(),\n                    streams.len()\n                );\n                Ok(entries)\n            }\n            Err(e) =\u003e {\n                warn!(\"Failed to read thoughts: {}\", e);\n                Err(Self::map_redis_error(e))\n            }\n        }\n    }\n\n    /// Delete thought from stream (XDEL - for forgetting)\n    #[allow(clippy::missing_errors_doc)]\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn forget_thought(\n        \u0026mut self,\n        stream: \u0026StreamName,\n        id: \u0026str,\n    ) -\u003e Result\u003c(), StreamError\u003e {\n        let key = stream.as_redis_key();\n        let _deleted: i32 = self\n            .conn_mut()?\n            .xdel(key, \u0026[id])\n            .await\n            .map_err(Self::map_redis_error)?;\n        debug!(\"Forgot thought {} from stream {}\", id, key);\n        Ok(())\n    }\n\n    /// Trim stream to MAXLEN (XTRIM)\n    #[allow(clippy::missing_errors_doc)]\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn trim_stream(\n        \u0026mut self,\n        stream: \u0026StreamName,\n        maxlen: usize,\n    ) -\u003e Result\u003cu64, StreamError\u003e {\n        let key = stream.as_redis_key();\n        let trimmed: i32 = self\n            .conn_mut()?\n            .xtrim(key, redis::streams::StreamMaxlen::Approx(maxlen))\n            .await\n            .map_err(Self::map_redis_error)?;\n        debug!(\"Trimmed {} entries from stream {}\", trimmed, key);\n        #[allow(clippy::cast_sign_loss)]\n        let count = trimmed as u64; // Safe: trimmed count is always non-negative\n        Ok(count)\n    }\n\n    // =========================================================================\n    // Consumer Group Operations\n    // =========================================================================\n\n    /// Create consumer group (XGROUP CREATE)\n    #[allow(clippy::missing_errors_doc)]\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn create_consumer_group(\n        \u0026mut self,\n        stream: \u0026StreamName,\n        group: \u0026str,\n    ) -\u003e Result\u003c(), StreamError\u003e {\n        let key = stream.as_redis_key();\n        let conn = self.conn_mut()?;\n\n        // XGROUP CREATE stream group $ MKSTREAM\n        let result: RedisResult\u003cString\u003e = conn.xgroup_create_mkstream(key, group, \"$\").await;\n\n        match result {\n            Ok(_) =\u003e {\n                info!(\"Created consumer group '{}' for stream {}\", group, key);\n                Ok(())\n            }\n            Err(e) =\u003e {\n                // Group may already exist - check error message\n                let err_msg = format!(\"{e}\");\n                if err_msg.contains(\"BUSYGROUP\") {\n                    debug!(\"Consumer group '{}' already exists for {}\", group, key);\n                    Ok(())\n                } else {\n                    Err(StreamError::ConsumerGroupError { reason: err_msg })\n                }\n            }\n        }\n    }\n\n    /// Read with consumer group (XREADGROUP)\n    #[allow(clippy::missing_errors_doc)]\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn read_group(\n        \u0026mut self,\n        streams: \u0026[StreamName],\n        group: \u0026str,\n        consumer: \u0026str,\n        count: usize,\n    ) -\u003e Result\u003cVec\u003cStreamEntry\u003e, StreamError\u003e {\n        if streams.is_empty() {\n            return Ok(Vec::new());\n        }\n\n        let conn = self.conn_mut()?;\n        let keys: Vec\u003c\u0026str\u003e = streams.iter().map(StreamName::as_redis_key).collect();\n\n        // XREADGROUP GROUP group consumer COUNT count STREAMS key1 key2 ... \u003e \u003e ...\n        let opts = redis::streams::StreamReadOptions::default()\n            .group(group, consumer)\n            .count(count);\n\n        let ids: Vec\u003c\u0026str\u003e = vec![\"\u003e\"; keys.len()]; // Only new messages\n        let result: RedisResult\u003credis::streams::StreamReadReply\u003e =\n            conn.xread_options(\u0026keys, \u0026ids, \u0026opts).await;\n\n        match result {\n            Ok(reply) =\u003e {\n                let mut entries = Vec::new();\n                for stream_key in reply.keys {\n                    let stream_name = Self::parse_stream_name(\u0026stream_key.key);\n\n                    for id_entry in stream_key.ids {\n                        let entry = Self::parse_entry(\u0026stream_name, \u0026id_entry.id, \u0026id_entry.map)?;\n                        entries.push(entry);\n                    }\n                }\n                debug!(\n                    \"Read {} thoughts from group '{}' (consumer '{}')\",\n                    entries.len(),\n                    group,\n                    consumer\n                );\n                Ok(entries)\n            }\n            Err(e) =\u003e Err(Self::map_redis_error(e)),\n        }\n    }\n\n    /// Acknowledge processed entry (XACK)\n    #[allow(clippy::missing_errors_doc)]\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn acknowledge(\n        \u0026mut self,\n        stream: \u0026StreamName,\n        group: \u0026str,\n        id: \u0026str,\n    ) -\u003e Result\u003c(), StreamError\u003e {\n        let key = stream.as_redis_key();\n        let _acked: i32 = self\n            .conn_mut()?\n            .xack(key, group, \u0026[id])\n            .await\n            .map_err(Self::map_redis_error)?;\n        debug!(\n            \"Acknowledged {} in group '{}' for stream {}\",\n            id, group, key\n        );\n        Ok(())\n    }\n\n    // =========================================================================\n    // Helper Methods\n    // =========================================================================\n\n    /// Get stream length (XLEN)\n    #[allow(clippy::missing_errors_doc)]\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn stream_length(\u0026mut self, stream: \u0026StreamName) -\u003e Result\u003cu64, StreamError\u003e {\n        let key = stream.as_redis_key();\n        let len: i32 = self\n            .conn_mut()?\n            .xlen(key)\n            .await\n            .map_err(Self::map_redis_error)?;\n        #[allow(clippy::cast_sign_loss)]\n        let length = len as u64; // Safe: stream length is always non-negative\n        Ok(length)\n    }\n\n    /// Check if stream exists\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn stream_exists(\u0026mut self, stream: \u0026StreamName) -\u003e bool {\n        let key = stream.as_redis_key();\n        let conn = match self.conn_mut() {\n            Ok(c) =\u003e c,\n            Err(_) =\u003e return false,\n        };\n\n        let exists: Result\u003cbool, RedisError\u003e = conn.exists(key).await;\n        exists.unwrap_or(false)\n    }\n\n    // =========================================================================\n    // Internal Helpers\n    // =========================================================================\n\n    /// Map Redis error to StreamError\n    fn map_redis_error(err: RedisError) -\u003e StreamError {\n        StreamError::ConnectionFailed {\n            reason: format!(\"{err}\"),\n        }\n    }\n\n    /// Parse stream name from Redis key\n    fn parse_stream_name(key: \u0026str) -\u003e StreamName {\n        match key {\n            \"thought:sensory\" =\u003e StreamName::Sensory,\n            \"thought:memory\" =\u003e StreamName::Memory,\n            \"thought:emotion\" =\u003e StreamName::Emotion,\n            \"thought:reasoning\" =\u003e StreamName::Reasoning,\n            \"thought:assembled\" =\u003e StreamName::Assembled,\n            custom =\u003e StreamName::Custom(custom.to_string()),\n        }\n    }\n\n    /// Parse stream entry from Redis data\n    fn parse_entry(\n        stream: \u0026StreamName,\n        id: \u0026str,\n        map: \u0026HashMap\u003cString, Value\u003e,\n    ) -\u003e Result\u003cStreamEntry, StreamError\u003e {\n        // Extract fields from Redis hash\n        let content_json = Self::get_string_field(map, \"content\")?;\n        let salience_json = Self::get_string_field(map, \"salience\")?;\n        let timestamp_str = Self::get_string_field(map, \"timestamp\")?;\n        let source_str = Self::get_string_field(map, \"source\").ok();\n\n        // Deserialize JSON fields\n        let content: Content =\n            serde_json::from_str(\u0026content_json).map_err(|e| StreamError::SerializationFailed {\n                reason: format!(\"{e}\"),\n            })?;\n        let salience: SalienceScore =\n            serde_json::from_str(\u0026salience_json).map_err(|e| StreamError::SerializationFailed {\n                reason: format!(\"{e}\"),\n            })?;\n        let timestamp = chrono::DateTime::parse_from_rfc3339(\u0026timestamp_str)\n            .map_err(|e| StreamError::SerializationFailed {\n                reason: format!(\"{e}\"),\n            })?\n            .with_timezone(\u0026chrono::Utc);\n\n        let source = source_str.filter(|s| !s.is_empty());\n\n        Ok(StreamEntry {\n            id: id.to_string(),\n            stream: stream.clone(),\n            content,\n            salience,\n            timestamp,\n            source,\n        })\n    }\n\n    /// Extract string field from Redis value map\n    fn get_string_field(map: \u0026HashMap\u003cString, Value\u003e, field: \u0026str) -\u003e Result\u003cString, StreamError\u003e {\n        let value = map\n            .get(field)\n            .ok_or_else(|| StreamError::SerializationFailed {\n                reason: format!(\"Missing '{field}' field\"),\n            })?;\n        String::from_redis_value(value.clone()).map_err(|e| StreamError::SerializationFailed {\n            reason: format!(\"Extract '{field}': {e}\"),\n        })\n    }\n}\n\n#[cfg(test)]\nimpl StreamsClient {\n    /// Create a dummy client for testing (not connected to Redis)\n    ///\n    /// This allows testing pure computation functions that don't require I/O.\n    pub fn new_for_test() -\u003e Self {\n        let client =\n            Client::open(\"redis://localhost:6379\").expect(\"Failed to create test client URL\");\n        Self {\n            client,\n            conn: None, // Not connected - I/O methods will fail\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::core::types::{Content, SalienceScore};\n    use redis::Value;\n    use std::collections::HashMap;\n\n    // =========================================================================\n    // Connection State Tests\n    // =========================================================================\n\n    #[test]\n    fn test_is_connected_when_disconnected() {\n        let client = StreamsClient::new_for_test();\n        assert!(!client.is_connected());\n    }\n\n    #[test]\n    fn test_conn_mut_when_disconnected() {\n        let mut client = StreamsClient::new_for_test();\n        let result = client.conn_mut();\n        assert!(result.is_err());\n        match result {\n            Err(StreamError::ConnectionFailed { reason }) =\u003e {\n                assert_eq!(reason, \"Not connected\");\n            }\n            _ =\u003e panic!(\"Expected ConnectionFailed error\"),\n        }\n    }\n\n    // =========================================================================\n    // map_redis_error Tests\n    // =========================================================================\n\n    #[test]\n    fn test_map_redis_error_converts_to_connection_failed() {\n        // Create a Redis error using the public API\n        let redis_err = RedisError::from((\n            redis::ErrorKind::Io,\n            \"Test error message\",\n        ));\n        let stream_err = StreamsClient::map_redis_error(redis_err);\n\n        match stream_err {\n            StreamError::ConnectionFailed { reason } =\u003e {\n                assert!(reason.contains(\"Test error message\"));\n            }\n            _ =\u003e panic!(\"Expected ConnectionFailed error\"),\n        }\n    }\n\n    #[test]\n    fn test_map_redis_error_preserves_error_info() {\n        let redis_err = RedisError::from((\n            redis::ErrorKind::Client,\n            \"WRONGTYPE Operation against a key holding the wrong kind of value\",\n        ));\n        let stream_err = StreamsClient::map_redis_error(redis_err);\n\n        match stream_err {\n            StreamError::ConnectionFailed { reason } =\u003e {\n                assert!(reason.contains(\"WRONGTYPE\"));\n            }\n            _ =\u003e panic!(\"Expected ConnectionFailed error\"),\n        }\n    }\n\n    // =========================================================================\n    // parse_stream_name Tests\n    // =========================================================================\n\n    #[test]\n    fn test_parse_stream_name_sensory() {\n        let name = StreamsClient::parse_stream_name(\"thought:sensory\");\n        assert_eq!(name, StreamName::Sensory);\n    }\n\n    #[test]\n    fn test_parse_stream_name_memory() {\n        let name = StreamsClient::parse_stream_name(\"thought:memory\");\n        assert_eq!(name, StreamName::Memory);\n    }\n\n    #[test]\n    fn test_parse_stream_name_emotion() {\n        let name = StreamsClient::parse_stream_name(\"thought:emotion\");\n        assert_eq!(name, StreamName::Emotion);\n    }\n\n    #[test]\n    fn test_parse_stream_name_reasoning() {\n        let name = StreamsClient::parse_stream_name(\"thought:reasoning\");\n        assert_eq!(name, StreamName::Reasoning);\n    }\n\n    #[test]\n    fn test_parse_stream_name_assembled() {\n        let name = StreamsClient::parse_stream_name(\"thought:assembled\");\n        assert_eq!(name, StreamName::Assembled);\n    }\n\n    #[test]\n    fn test_parse_stream_name_custom() {\n        let name = StreamsClient::parse_stream_name(\"custom:stream:name\");\n        assert_eq!(name, StreamName::Custom(\"custom:stream:name\".to_string()));\n    }\n\n    #[test]\n    fn test_parse_stream_name_unknown() {\n        let name = StreamsClient::parse_stream_name(\"unknown_stream\");\n        assert_eq!(name, StreamName::Custom(\"unknown_stream\".to_string()));\n    }\n\n    // =========================================================================\n    // get_string_field Tests\n    // =========================================================================\n\n    #[test]\n    fn test_get_string_field_success() {\n        let mut map: HashMap\u003cString, Value\u003e = HashMap::new();\n        map.insert(\"test_field\".to_string(), Value::BulkString(b\"test_value\".to_vec()));\n\n        let result = StreamsClient::get_string_field(\u0026map, \"test_field\");\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"test_value\");\n    }\n\n    #[test]\n    fn test_get_string_field_missing_field() {\n        let map: HashMap\u003cString, Value\u003e = HashMap::new();\n\n        let result = StreamsClient::get_string_field(\u0026map, \"missing_field\");\n        assert!(result.is_err());\n        match result {\n            Err(StreamError::SerializationFailed { reason }) =\u003e {\n                assert!(reason.contains(\"Missing 'missing_field' field\"));\n            }\n            _ =\u003e panic!(\"Expected SerializationFailed error\"),\n        }\n    }\n\n    #[test]\n    fn test_get_string_field_wrong_type() {\n        let mut map: HashMap\u003cString, Value\u003e = HashMap::new();\n        map.insert(\"int_field\".to_string(), Value::Int(42));\n\n        // Int values should still convert to string via FromRedisValue\n        let result = StreamsClient::get_string_field(\u0026map, \"int_field\");\n        // This may succeed with \"42\" or fail depending on redis crate behavior\n        // The important thing is it doesn't panic\n        let _ = result;\n    }\n\n    #[test]\n    fn test_get_string_field_empty_string() {\n        let mut map: HashMap\u003cString, Value\u003e = HashMap::new();\n        map.insert(\"empty\".to_string(), Value::BulkString(b\"\".to_vec()));\n\n        let result = StreamsClient::get_string_field(\u0026map, \"empty\");\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"\");\n    }\n\n    // =========================================================================\n    // parse_entry Tests\n    // =========================================================================\n\n    #[test]\n    fn test_parse_entry_success() {\n        let mut map: HashMap\u003cString, Value\u003e = HashMap::new();\n\n        // Create valid JSON for content and salience\n        let content = Content::symbol(\"test\", vec![1, 2, 3]);\n        let salience = SalienceScore::neutral();\n        let timestamp = chrono::Utc::now();\n\n        map.insert(\"content\".to_string(), Value::BulkString(\n            serde_json::to_string(\u0026content).unwrap().into_bytes()\n        ));\n        map.insert(\"salience\".to_string(), Value::BulkString(\n            serde_json::to_string(\u0026salience).unwrap().into_bytes()\n        ));\n        map.insert(\"timestamp\".to_string(), Value::BulkString(\n            timestamp.to_rfc3339().into_bytes()\n        ));\n        map.insert(\"source\".to_string(), Value::BulkString(\n            b\"test_source\".to_vec()\n        ));\n\n        let result = StreamsClient::parse_entry(\u0026StreamName::Sensory, \"123-0\", \u0026map);\n        assert!(result.is_ok());\n\n        let entry = result.unwrap();\n        assert_eq!(entry.id, \"123-0\");\n        assert_eq!(entry.stream, StreamName::Sensory);\n        assert_eq!(entry.source, Some(\"test_source\".to_string()));\n    }\n\n    #[test]\n    fn test_parse_entry_without_source() {\n        let mut map: HashMap\u003cString, Value\u003e = HashMap::new();\n\n        let content = Content::Empty;\n        let salience = SalienceScore::neutral();\n        let timestamp = chrono::Utc::now();\n\n        map.insert(\"content\".to_string(), Value::BulkString(\n            serde_json::to_string(\u0026content).unwrap().into_bytes()\n        ));\n        map.insert(\"salience\".to_string(), Value::BulkString(\n            serde_json::to_string(\u0026salience).unwrap().into_bytes()\n        ));\n        map.insert(\"timestamp\".to_string(), Value::BulkString(\n            timestamp.to_rfc3339().into_bytes()\n        ));\n        // No source field - should be Ok with None\n\n        let result = StreamsClient::parse_entry(\u0026StreamName::Memory, \"456-0\", \u0026map);\n        assert!(result.is_ok());\n\n        let entry = result.unwrap();\n        assert!(entry.source.is_none());\n    }\n\n    #[test]\n    fn test_parse_entry_empty_source() {\n        let mut map: HashMap\u003cString, Value\u003e = HashMap::new();\n\n        let content = Content::Empty;\n        let salience = SalienceScore::neutral();\n        let timestamp = chrono::Utc::now();\n\n        map.insert(\"content\".to_string(), Value::BulkString(\n            serde_json::to_string(\u0026content).unwrap().into_bytes()\n        ));\n        map.insert(\"salience\".to_string(), Value::BulkString(\n            serde_json::to_string(\u0026salience).unwrap().into_bytes()\n        ));\n        map.insert(\"timestamp\".to_string(), Value::BulkString(\n            timestamp.to_rfc3339().into_bytes()\n        ));\n        map.insert(\"source\".to_string(), Value::BulkString(b\"\".to_vec()));\n\n        let result = StreamsClient::parse_entry(\u0026StreamName::Emotion, \"789-0\", \u0026map);\n        assert!(result.is_ok());\n\n        let entry = result.unwrap();\n        // Empty source should become None (filtered)\n        assert!(entry.source.is_none());\n    }\n\n    #[test]\n    fn test_parse_entry_missing_content() {\n        let mut map: HashMap\u003cString, Value\u003e = HashMap::new();\n\n        let salience = SalienceScore::neutral();\n        let timestamp = chrono::Utc::now();\n\n        // Missing content field\n        map.insert(\"salience\".to_string(), Value::BulkString(\n            serde_json::to_string(\u0026salience).unwrap().into_bytes()\n        ));\n        map.insert(\"timestamp\".to_string(), Value::BulkString(\n            timestamp.to_rfc3339().into_bytes()\n        ));\n\n        let result = StreamsClient::parse_entry(\u0026StreamName::Reasoning, \"000-0\", \u0026map);\n        assert!(result.is_err());\n        match result {\n            Err(StreamError::SerializationFailed { reason }) =\u003e {\n                assert!(reason.contains(\"content\"));\n            }\n            _ =\u003e panic!(\"Expected SerializationFailed error\"),\n        }\n    }\n\n    #[test]\n    fn test_parse_entry_invalid_json_content() {\n        let mut map: HashMap\u003cString, Value\u003e = HashMap::new();\n\n        map.insert(\"content\".to_string(), Value::BulkString(\n            b\"not valid json\".to_vec()\n        ));\n        map.insert(\"salience\".to_string(), Value::BulkString(\n            b\"{}\".to_vec()\n        ));\n        map.insert(\"timestamp\".to_string(), Value::BulkString(\n            chrono::Utc::now().to_rfc3339().into_bytes()\n        ));\n\n        let result = StreamsClient::parse_entry(\u0026StreamName::Assembled, \"111-0\", \u0026map);\n        assert!(result.is_err());\n        match result {\n            Err(StreamError::SerializationFailed { .. }) =\u003e {}\n            _ =\u003e panic!(\"Expected SerializationFailed error\"),\n        }\n    }\n\n    #[test]\n    fn test_parse_entry_invalid_timestamp() {\n        let mut map: HashMap\u003cString, Value\u003e = HashMap::new();\n\n        let content = Content::Empty;\n        let salience = SalienceScore::neutral();\n\n        map.insert(\"content\".to_string(), Value::BulkString(\n            serde_json::to_string(\u0026content).unwrap().into_bytes()\n        ));\n        map.insert(\"salience\".to_string(), Value::BulkString(\n            serde_json::to_string(\u0026salience).unwrap().into_bytes()\n        ));\n        map.insert(\"timestamp\".to_string(), Value::BulkString(\n            b\"not-a-timestamp\".to_vec()\n        ));\n\n        let result = StreamsClient::parse_entry(\u0026StreamName::Sensory, \"222-0\", \u0026map);\n        assert!(result.is_err());\n        match result {\n            Err(StreamError::SerializationFailed { .. }) =\u003e {}\n            _ =\u003e panic!(\"Expected SerializationFailed error\"),\n        }\n    }\n\n    #[test]\n    fn test_parse_entry_missing_salience() {\n        let mut map: HashMap\u003cString, Value\u003e = HashMap::new();\n\n        let content = Content::Empty;\n        let timestamp = chrono::Utc::now();\n\n        map.insert(\"content\".to_string(), Value::BulkString(\n            serde_json::to_string(\u0026content).unwrap().into_bytes()\n        ));\n        // Missing salience field\n        map.insert(\"timestamp\".to_string(), Value::BulkString(\n            timestamp.to_rfc3339().into_bytes()\n        ));\n\n        let result = StreamsClient::parse_entry(\u0026StreamName::Reasoning, \"333-0\", \u0026map);\n        assert!(result.is_err());\n        match result {\n            Err(StreamError::SerializationFailed { reason }) =\u003e {\n                assert!(reason.contains(\"salience\"));\n            }\n            _ =\u003e panic!(\"Expected SerializationFailed error\"),\n        }\n    }\n\n    #[test]\n    fn test_parse_entry_invalid_salience_json() {\n        let mut map: HashMap\u003cString, Value\u003e = HashMap::new();\n\n        let content = Content::Empty;\n        let timestamp = chrono::Utc::now();\n\n        map.insert(\"content\".to_string(), Value::BulkString(\n            serde_json::to_string(\u0026content).unwrap().into_bytes()\n        ));\n        map.insert(\"salience\".to_string(), Value::BulkString(\n            b\"not valid json\".to_vec()\n        ));\n        map.insert(\"timestamp\".to_string(), Value::BulkString(\n            timestamp.to_rfc3339().into_bytes()\n        ));\n\n        let result = StreamsClient::parse_entry(\u0026StreamName::Assembled, \"444-0\", \u0026map);\n        assert!(result.is_err());\n        match result {\n            Err(StreamError::SerializationFailed { .. }) =\u003e {}\n            _ =\u003e panic!(\"Expected SerializationFailed error\"),\n        }\n    }\n\n    #[test]\n    fn test_parse_entry_missing_timestamp() {\n        let mut map: HashMap\u003cString, Value\u003e = HashMap::new();\n\n        let content = Content::Empty;\n        let salience = SalienceScore::neutral();\n\n        map.insert(\"content\".to_string(), Value::BulkString(\n            serde_json::to_string(\u0026content).unwrap().into_bytes()\n        ));\n        map.insert(\"salience\".to_string(), Value::BulkString(\n            serde_json::to_string(\u0026salience).unwrap().into_bytes()\n        ));\n        // Missing timestamp field\n\n        let result = StreamsClient::parse_entry(\u0026StreamName::Memory, \"555-0\", \u0026map);\n        assert!(result.is_err());\n        match result {\n            Err(StreamError::SerializationFailed { reason }) =\u003e {\n                assert!(reason.contains(\"timestamp\"));\n            }\n            _ =\u003e panic!(\"Expected SerializationFailed error\"),\n        }\n    }\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":186},{"path":["/","Users","rex","src","royalbit","daneel","src","streams","consumer.rs"],"content":"//! Attention Competition Consumer\n//!\n//! Implements TMI's \"O Eu\" (The \"I\") - the sense of self that emerges\n//! from competitive attention selection. Multiple thought streams compete,\n//! highest salience wins consciousness.\n//!\n//! # The Competition\n//!\n//! Every ~50ms, thoughts from multiple streams compete:\n//! - Sensory input\n//! - Memory retrieval\n//! - Emotional responses\n//! - Reasoning conclusions\n//!\n//! The winner becomes conscious (attended). Losers may be forgotten\n//! if their salience falls below threshold.\n\n#![allow(clippy::missing_errors_doc)]\n\nuse tracing::{debug, info, warn};\nuse uuid::Uuid;\n\nuse crate::core::types::SalienceWeights;\nuse crate::streams::client::StreamsClient;\nuse crate::streams::types::{\n    CompetitionResult, StreamEntry, StreamError, StreamName, ThoughtCandidate,\n    DEFAULT_FORGET_THRESHOLD,\n};\n\n// =============================================================================\n// ConsumerConfig - Configuration for attention consumer\n// =============================================================================\n\n/// Configuration for the attention consumer\n#[derive(Debug, Clone)]\npub struct ConsumerConfig {\n    /// Consumer group name (default: \"attention\")\n    pub group_name: String,\n\n    /// This consumer's unique name\n    pub consumer_name: String,\n\n    /// Streams to compete for attention\n    pub input_streams: Vec\u003cStreamName\u003e,\n\n    /// Output stream for assembled thoughts\n    pub output_stream: StreamName,\n\n    /// Threshold below which thoughts are forgotten\n    pub forget_threshold: f32,\n\n    /// Connection weight for salience calculation\n    pub connection_weight: f32,\n\n    /// Salience weights (for calculating base composite score)\n    pub salience_weights: SalienceWeights,\n\n    /// Max thoughts to read per cycle\n    pub batch_size: usize,\n\n    /// Block timeout in ms (0 = non-blocking)\n    pub block_ms: u64,\n}\n\nimpl ConsumerConfig {\n    /// Create new consumer config with validation\n    ///\n    /// # Panics\n    ///\n    /// Panics if connection_weight \u003c= 0 (violates Connection Drive Invariant)\n    #[must_use]\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        group_name: String,\n        consumer_name: String,\n        input_streams: Vec\u003cStreamName\u003e,\n        output_stream: StreamName,\n        forget_threshold: f32,\n        connection_weight: f32,\n        salience_weights: SalienceWeights,\n        batch_size: usize,\n        block_ms: u64,\n    ) -\u003e Self {\n        assert!(\n            connection_weight \u003e 0.0,\n            \"Connection Drive Invariant: connection_weight must be \u003e 0\"\n        );\n\n        Self {\n            group_name,\n            consumer_name,\n            input_streams,\n            output_stream,\n            forget_threshold,\n            connection_weight,\n            salience_weights,\n            batch_size,\n            block_ms,\n        }\n    }\n}\n\nimpl Default for ConsumerConfig {\n    fn default() -\u003e Self {\n        // Create weights where connection component is handled separately\n        // This ensures connection is the alignment mechanism as per TMI\n        let weights = SalienceWeights {\n            connection: 0.0, // Connection boost added separately\n            ..SalienceWeights::default()\n        };\n\n        Self {\n            group_name: \"attention\".to_string(),\n            consumer_name: format!(\"daneel_{}\", Uuid::new_v4().simple()),\n            input_streams: vec![\n                StreamName::Sensory,\n                StreamName::Memory,\n                StreamName::Emotion,\n                StreamName::Reasoning,\n            ],\n            output_stream: StreamName::Assembled,\n            forget_threshold: DEFAULT_FORGET_THRESHOLD,\n            connection_weight: 0.2, // CONNECTION DRIVE INVARIANT\n            salience_weights: weights,\n            batch_size: 100,\n            block_ms: 50, // 50ms cycle time\n        }\n    }\n}\n\n// =============================================================================\n// AttentionConsumer - Orchestrates competitive attention selection\n// =============================================================================\n\n/// Attention consumer implementing TMI's \"O Eu\" (The \"I\")\n///\n/// Manages competitive selection across multiple thought streams,\n/// selecting the highest-salience thought for conscious attention.\npub struct AttentionConsumer {\n    client: StreamsClient,\n    config: ConsumerConfig,\n    cycle_count: u64,\n}\n\nimpl AttentionConsumer {\n    /// Create new consumer with client and config\n    #[must_use]\n    pub fn new(client: StreamsClient, config: ConsumerConfig) -\u003e Self {\n        info!(\n            \"Creating attention consumer '{}' for group '{}'\",\n            config.consumer_name, config.group_name\n        );\n        Self {\n            client,\n            config,\n            cycle_count: 0,\n        }\n    }\n\n    /// Initialize consumer groups on all input streams\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn initialize(\u0026mut self) -\u003e Result\u003c(), StreamError\u003e {\n        info!(\n            \"Initializing consumer groups for {} streams\",\n            self.config.input_streams.len()\n        );\n\n        for stream in \u0026self.config.input_streams {\n            self.client\n                .create_consumer_group(stream, \u0026self.config.group_name)\n                .await?;\n        }\n\n        info!(\"Consumer groups initialized successfully\");\n        Ok(())\n    }\n\n    /// Run one attention competition cycle\n    ///\n    /// Returns CompetitionResult with winner, losers, and forgotten.\n    /// Returns None if no thoughts are available to compete.\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn compete(\u0026mut self) -\u003e Result\u003cOption\u003cCompetitionResult\u003e, StreamError\u003e {\n        self.cycle_count += 1;\n\n        // 1. Read from all input streams using consumer group\n        let entries = self\n            .client\n            .read_group(\n                \u0026self.config.input_streams,\n                \u0026self.config.group_name,\n                \u0026self.config.consumer_name,\n                self.config.batch_size,\n            )\n            .await?;\n\n        if entries.is_empty() {\n            debug!(\"Cycle {}: No thoughts competing\", self.cycle_count);\n            return Ok(None);\n        }\n\n        // 2. Score each entry\n        let mut candidates: Vec\u003cThoughtCandidate\u003e = entries\n            .into_iter()\n            .map(|entry| self.score_candidate(\u0026entry))\n            .collect();\n\n        // 3. Sort by score (highest first)\n        candidates.sort_by(|a, b| {\n            b.total_score()\n                .partial_cmp(\u0026a.total_score())\n                .unwrap_or(std::cmp::Ordering::Equal)\n        });\n\n        // 4. Select winner (highest score)\n        let winner = candidates.remove(0);\n        info!(\n            \"Cycle {}: Winner from {} with score {:.3}\",\n            self.cycle_count,\n            winner.entry.stream,\n            winner.total_score()\n        );\n\n        // 5. ACK the winner\n        self.client\n            .acknowledge(\n                \u0026winner.entry.stream,\n                \u0026self.config.group_name,\n                \u0026winner.entry.id,\n            )\n            .await?;\n\n        // 6. Forget entries below threshold and separate losers\n        let mut losers = Vec::new();\n        let mut forgotten = Vec::new();\n\n        for candidate in candidates {\n            if candidate.total_score() \u003c self.config.forget_threshold {\n                // Forget this thought (XDEL)\n                if let Err(e) = self\n                    .client\n                    .forget_thought(\u0026candidate.entry.stream, \u0026candidate.entry.id)\n                    .await\n                {\n                    warn!(\"Failed to forget thought {}: {}\", candidate.entry.id, e);\n                }\n                forgotten.push(candidate.entry.id.clone());\n            } else {\n                losers.push(candidate);\n            }\n        }\n\n        if !forgotten.is_empty() {\n            debug!(\n                \"Cycle {}: Forgot {} thoughts\",\n                self.cycle_count,\n                forgotten.len()\n            );\n        }\n\n        // 7. Write winner to output stream (assembled)\n        let assembled_entry = StreamEntry {\n            id: String::new(), // Will be set by Redis\n            stream: self.config.output_stream.clone(),\n            content: winner.entry.content.clone(),\n            salience: winner.entry.salience,\n            timestamp: winner.entry.timestamp,\n            source: winner.entry.source.clone(),\n        };\n\n        self.client\n            .add_thought(\u0026self.config.output_stream, \u0026assembled_entry)\n            .await?;\n\n        // 8. Return CompetitionResult\n        let result = CompetitionResult::new(winner, losers, forgotten);\n        Ok(Some(result))\n    }\n\n    /// Run continuous attention loop\n    ///\n    /// Runs until an error occurs. Use Ctrl+C or similar to stop.\n    #[cfg_attr(coverage_nightly, coverage(off))]\n    pub async fn run(\u0026mut self) -\u003e Result\u003c(), StreamError\u003e {\n        info!(\"Starting attention consumer loop\");\n\n        loop {\n            match self.compete().await {\n                Ok(Some(result)) =\u003e {\n                    debug!(\n                        \"Cycle {}: {} candidates, {} forgotten\",\n                        self.cycle_count,\n                        result.total_candidates(),\n                        result.forgotten.len()\n                    );\n                }\n                Ok(None) =\u003e {\n                    // No thoughts to compete, wait for next cycle\n                    tokio::time::sleep(tokio::time::Duration::from_millis(self.config.block_ms))\n                        .await;\n                }\n                Err(e) =\u003e {\n                    warn!(\"Competition cycle failed: {}\", e);\n                    return Err(e);\n                }\n            }\n        }\n    }\n\n    // =========================================================================\n    // Metrics\n    // =========================================================================\n\n    /// Get number of cycles completed\n    #[must_use]\n    pub fn cycle_count(\u0026self) -\u003e u64 {\n        self.cycle_count\n    }\n\n    /// Get the consumer's name\n    #[must_use]\n    pub fn consumer_name(\u0026self) -\u003e \u0026str {\n        \u0026self.config.consumer_name\n    }\n\n    // =========================================================================\n    // Internal Helpers\n    // =========================================================================\n\n    /// Calculate total score for competition\n    ///\n    /// Score = composite(weights) + (connection_relevance * connection_weight)\n    ///\n    /// The connection component is handled separately from other salience dimensions\n    /// to ensure it acts as THE alignment mechanism per TMI architecture.\n    fn score_candidate(\u0026self, entry: \u0026StreamEntry) -\u003e ThoughtCandidate {\n        let composite = entry.salience.composite(\u0026self.config.salience_weights);\n        let connection_boost = entry.salience.connection_relevance * self.config.connection_weight;\n\n        ThoughtCandidate::new(entry.clone(), composite, connection_boost)\n    }\n}\n\n// =============================================================================\n// Tests\n// =============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::core::types::{Content, SalienceScore};\n\n    // =========================================================================\n    // ConsumerConfig Tests\n    // =========================================================================\n\n    #[test]\n    fn consumer_config_new_valid() {\n        let config = ConsumerConfig::new(\n            \"test_group\".to_string(),\n            \"test_consumer\".to_string(),\n            vec![StreamName::Sensory, StreamName::Memory],\n            StreamName::Assembled,\n            0.3,\n            0.2,\n            SalienceWeights::default(),\n            100,\n            50,\n        );\n\n        assert_eq!(config.group_name, \"test_group\");\n        assert_eq!(config.consumer_name, \"test_consumer\");\n        assert_eq!(config.input_streams.len(), 2);\n        assert_eq!(config.output_stream, StreamName::Assembled);\n        assert!((config.forget_threshold - 0.3).abs() \u003c 0.001);\n        assert!((config.connection_weight - 0.2).abs() \u003c 0.001);\n        assert_eq!(config.batch_size, 100);\n        assert_eq!(config.block_ms, 50);\n    }\n\n    #[test]\n    #[should_panic(expected = \"Connection Drive Invariant\")]\n    fn consumer_config_new_panics_on_zero_connection_weight() {\n        let _ = ConsumerConfig::new(\n            \"test_group\".to_string(),\n            \"test_consumer\".to_string(),\n            vec![StreamName::Sensory],\n            StreamName::Assembled,\n            0.3,\n            0.0, // INVALID: connection_weight must be \u003e 0\n            SalienceWeights::default(),\n            100,\n            50,\n        );\n    }\n\n    #[test]\n    #[should_panic(expected = \"Connection Drive Invariant\")]\n    fn consumer_config_new_panics_on_negative_connection_weight() {\n        let _ = ConsumerConfig::new(\n            \"test_group\".to_string(),\n            \"test_consumer\".to_string(),\n            vec![StreamName::Sensory],\n            StreamName::Assembled,\n            0.3,\n            -0.1, // INVALID: connection_weight must be \u003e 0\n            SalienceWeights::default(),\n            100,\n            50,\n        );\n    }\n\n    #[test]\n    fn consumer_config_default() {\n        let config = ConsumerConfig::default();\n\n        assert_eq!(config.group_name, \"attention\");\n        assert!(config.consumer_name.starts_with(\"daneel_\"));\n        assert_eq!(config.input_streams.len(), 4);\n        assert!(config.input_streams.contains(\u0026StreamName::Sensory));\n        assert!(config.input_streams.contains(\u0026StreamName::Memory));\n        assert!(config.input_streams.contains(\u0026StreamName::Emotion));\n        assert!(config.input_streams.contains(\u0026StreamName::Reasoning));\n        assert_eq!(config.output_stream, StreamName::Assembled);\n        assert!((config.forget_threshold - DEFAULT_FORGET_THRESHOLD).abs() \u003c 0.001);\n        assert!((config.connection_weight - 0.2).abs() \u003c 0.001);\n        assert_eq!(config.batch_size, 100);\n        assert_eq!(config.block_ms, 50);\n    }\n\n    #[test]\n    fn consumer_config_default_weights_zero_connection() {\n        // The default config sets salience_weights.connection = 0.0\n        // because connection boost is handled separately\n        let config = ConsumerConfig::default();\n        assert!((config.salience_weights.connection - 0.0).abs() \u003c 0.001);\n    }\n\n    // =========================================================================\n    // AttentionConsumer Tests\n    // =========================================================================\n\n    #[test]\n    fn attention_consumer_new() {\n        let client = StreamsClient::new_for_test();\n        let config = ConsumerConfig::default();\n        let consumer_name = config.consumer_name.clone();\n\n        let consumer = AttentionConsumer::new(client, config);\n\n        assert_eq!(consumer.cycle_count(), 0);\n        assert_eq!(consumer.consumer_name(), consumer_name);\n    }\n\n    #[test]\n    fn attention_consumer_cycle_count_initial() {\n        let client = StreamsClient::new_for_test();\n        let config = ConsumerConfig::default();\n        let consumer = AttentionConsumer::new(client, config);\n\n        assert_eq!(consumer.cycle_count(), 0);\n    }\n\n    #[test]\n    fn attention_consumer_consumer_name() {\n        let client = StreamsClient::new_for_test();\n        let config = ConsumerConfig::new(\n            \"group\".to_string(),\n            \"my_custom_consumer\".to_string(),\n            vec![StreamName::Sensory],\n            StreamName::Assembled,\n            0.3,\n            0.2,\n            SalienceWeights::default(),\n            100,\n            50,\n        );\n\n        let consumer = AttentionConsumer::new(client, config);\n\n        assert_eq!(consumer.consumer_name(), \"my_custom_consumer\");\n    }\n\n    // =========================================================================\n    // score_candidate Tests\n    // =========================================================================\n\n    #[test]\n    fn score_candidate_basic() {\n        let client = StreamsClient::new_for_test();\n        let config = ConsumerConfig::new(\n            \"group\".to_string(),\n            \"consumer\".to_string(),\n            vec![StreamName::Sensory],\n            StreamName::Assembled,\n            0.3,\n            0.2, // connection_weight\n            SalienceWeights::default(),\n            100,\n            50,\n        );\n        let consumer = AttentionConsumer::new(client, config);\n\n        let entry = StreamEntry::new(\n            \"test-id-0\".to_string(),\n            StreamName::Sensory,\n            Content::Empty,\n            SalienceScore::neutral(), // connection_relevance = 0.5\n        );\n\n        let candidate = consumer.score_candidate(\u0026entry);\n\n        // Verify connection_boost = connection_relevance * connection_weight\n        // = 0.5 * 0.2 = 0.1\n        assert!((candidate.connection_boost - 0.1).abs() \u003c 0.001);\n\n        // Verify composite_score is calculated correctly\n        // Using default weights and neutral salience\n        let expected_composite = entry.salience.composite(\u0026SalienceWeights::default());\n        assert!((candidate.composite_score - expected_composite).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn score_candidate_high_connection_relevance() {\n        let client = StreamsClient::new_for_test();\n        let config = ConsumerConfig::new(\n            \"group\".to_string(),\n            \"consumer\".to_string(),\n            vec![StreamName::Sensory],\n            StreamName::Assembled,\n            0.3,\n            0.5, // Higher connection_weight\n            SalienceWeights::default(),\n            100,\n            50,\n        );\n        let consumer = AttentionConsumer::new(client, config);\n\n        let salience = SalienceScore::new(0.5, 0.5, 0.5, 0.0, 0.5, 1.0); // Max connection_relevance\n        let entry = StreamEntry::new(\n            \"test-id-0\".to_string(),\n            StreamName::Emotion,\n            Content::Empty,\n            salience,\n        );\n\n        let candidate = consumer.score_candidate(\u0026entry);\n\n        // connection_boost = 1.0 * 0.5 = 0.5\n        assert!((candidate.connection_boost - 0.5).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn score_candidate_zero_connection_relevance() {\n        let client = StreamsClient::new_for_test();\n        let config = ConsumerConfig::new(\n            \"group\".to_string(),\n            \"consumer\".to_string(),\n            vec![StreamName::Sensory],\n            StreamName::Assembled,\n            0.3,\n            0.2,\n            SalienceWeights::default(),\n            100,\n            50,\n        );\n        let consumer = AttentionConsumer::new(client, config);\n\n        let salience = SalienceScore::new(1.0, 1.0, 1.0, 1.0, 1.0, 0.0); // Zero connection_relevance\n        let entry = StreamEntry::new(\n            \"test-id-0\".to_string(),\n            StreamName::Reasoning,\n            Content::Empty,\n            salience,\n        );\n\n        let candidate = consumer.score_candidate(\u0026entry);\n\n        // connection_boost = 0.0 * 0.2 = 0.0\n        assert!((candidate.connection_boost - 0.0).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn score_candidate_total_score() {\n        let client = StreamsClient::new_for_test();\n        let weights = SalienceWeights {\n            importance: 0.3,\n            novelty: 0.2,\n            relevance: 0.3,\n            valence: 0.2,\n            connection: 0.0, // Handled separately\n        };\n        let config = ConsumerConfig::new(\n            \"group\".to_string(),\n            \"consumer\".to_string(),\n            vec![StreamName::Sensory],\n            StreamName::Assembled,\n            0.3,\n            0.25, // connection_weight\n            weights,\n            100,\n            50,\n        );\n        let consumer = AttentionConsumer::new(client, config);\n\n        let salience = SalienceScore::new(0.8, 0.6, 0.7, 0.5, 0.8, 0.9);\n        let entry = StreamEntry::new(\n            \"test-id-0\".to_string(),\n            StreamName::Memory,\n            Content::Empty,\n            salience,\n        );\n\n        let candidate = consumer.score_candidate(\u0026entry);\n\n        // connection_boost = 0.9 * 0.25 = 0.225\n        assert!((candidate.connection_boost - 0.225).abs() \u003c 0.001);\n\n        // total_score = composite + connection_boost\n        let expected_total = candidate.composite_score + candidate.connection_boost;\n        assert!((candidate.total_score() - expected_total).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn score_candidate_preserves_entry() {\n        let client = StreamsClient::new_for_test();\n        let config = ConsumerConfig::default();\n        let consumer = AttentionConsumer::new(client, config);\n\n        let entry = StreamEntry::new(\n            \"unique-entry-id-123\".to_string(),\n            StreamName::Memory,\n            Content::raw(vec![1, 2, 3]),\n            SalienceScore::neutral(),\n        )\n        .with_source(\"test_source\");\n\n        let candidate = consumer.score_candidate(\u0026entry);\n\n        // Verify entry is cloned correctly\n        assert_eq!(candidate.entry.id, \"unique-entry-id-123\");\n        assert_eq!(candidate.entry.stream, StreamName::Memory);\n        assert_eq!(candidate.entry.source, Some(\"test_source\".to_string()));\n    }\n\n    #[test]\n    fn score_candidate_custom_stream() {\n        let client = StreamsClient::new_for_test();\n        let config = ConsumerConfig::default();\n        let consumer = AttentionConsumer::new(client, config);\n\n        let entry = StreamEntry::new(\n            \"custom-0\".to_string(),\n            StreamName::Custom(\"my:custom:stream\".to_string()),\n            Content::Empty,\n            SalienceScore::neutral(),\n        );\n\n        let candidate = consumer.score_candidate(\u0026entry);\n\n        assert_eq!(\n            candidate.entry.stream,\n            StreamName::Custom(\"my:custom:stream\".to_string())\n        );\n    }\n\n    // =========================================================================\n    // Config Clone and Debug Tests\n    // =========================================================================\n\n    #[test]\n    fn consumer_config_clone() {\n        let config1 = ConsumerConfig::new(\n            \"group\".to_string(),\n            \"consumer\".to_string(),\n            vec![StreamName::Sensory],\n            StreamName::Assembled,\n            0.3,\n            0.2,\n            SalienceWeights::default(),\n            100,\n            50,\n        );\n        let config2 = config1.clone();\n\n        assert_eq!(config1.group_name, config2.group_name);\n        assert_eq!(config1.consumer_name, config2.consumer_name);\n        assert_eq!(config1.input_streams, config2.input_streams);\n        assert_eq!(config1.output_stream, config2.output_stream);\n    }\n\n    #[test]\n    fn consumer_config_debug() {\n        let config = ConsumerConfig::default();\n        let debug_str = format!(\"{:?}\", config);\n\n        assert!(debug_str.contains(\"ConsumerConfig\"));\n        assert!(debug_str.contains(\"attention\"));\n    }\n}\n","traces":[{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":95},{"path":["/","Users","rex","src","royalbit","daneel","src","streams","mod.rs"],"content":"//! Redis Streams Integration (ADR-020)\n//!\n//! TMI's ephemeral thought streams via Redis Streams.\n//!\n//! # Architecture Change (ADR-020)\n//!\n//! Redis Streams are now EPHEMERAL ONLY. Long-term memory moved to Qdrant (ADR-021).\n//!\n//! # Stream Types\n//!\n//! **Awake Mode (external triggers):**\n//! - `daneel:stream:awake` - All external stimuli and active cognition\n//!   - Sensory input, memory retrieval triggers, emotional responses, reasoning\n//!   - Consumer groups for attention competition (Autofluxo)\n//!   - TTL: 5 seconds (TMI intervention window)\n//!\n//! **Dream Mode (internal replay):**\n//! - `daneel:stream:dream` - Sleep consolidation replay\n//!   - Memory replay entries from consolidation actor\n//!   - No external triggers (disconnected from environment)\n//!   - Used for Hebbian strengthening\n//!\n//! **Salience Scoring:**\n//! - `daneel:stream:salience` - Priority scoring pipeline\n//!   - Consolidation tags for sleep replay\n//!\n//! # Competitive Attention\n//!\n//! Consumer groups model TMI's attention competition:\n//! - Thoughts compete via salience scores\n//! - Highest salience wins attention (\"O Eu\")\n//! - Losers below threshold are forgotten (XDEL)\n//! - Winners tagged for consolidation\n//!\n//! See ADR-020 for full rationale.\n\npub mod client;\npub mod consumer;\npub mod types;\n\n#[cfg(test)]\nmod tests;\n\n/// Stream names (ADR-020 compliant)\npub mod names {\n    /// Awake stream - external triggers and active cognition\n    /// All Autofluxo sub-streams merged into one\n    pub const STREAM_AWAKE: \u0026str = \"daneel:stream:awake\";\n\n    /// Dream stream - internal replay during sleep/consolidation\n    pub const STREAM_DREAM: \u0026str = \"daneel:stream:dream\";\n\n    /// Salience stream - priority scoring and consolidation tagging\n    pub const STREAM_SALIENCE: \u0026str = \"daneel:stream:salience\";\n\n    /// All active streams\n    pub const ALL_STREAMS: \u0026[\u0026str] = \u0026[STREAM_AWAKE, STREAM_DREAM, STREAM_SALIENCE];\n\n    // =========================================================================\n    // DEPRECATED (ADR-020) - Kept for reference during migration\n    // =========================================================================\n    // These streams are no longer used. Long-term memory is in Qdrant.\n    // Removing after migration is complete.\n    // =========================================================================\n\n    #[deprecated(since = \"0.6.0\", note = \"Merged into STREAM_AWAKE (ADR-020)\")]\n    pub const THOUGHT_SENSORY: \u0026str = \"thought:sensory\";\n\n    #[deprecated(since = \"0.6.0\", note = \"Merged into STREAM_AWAKE (ADR-020)\")]\n    pub const THOUGHT_MEMORY: \u0026str = \"thought:memory\";\n\n    #[deprecated(since = \"0.6.0\", note = \"Merged into STREAM_AWAKE (ADR-020)\")]\n    pub const THOUGHT_EMOTION: \u0026str = \"thought:emotion\";\n\n    #[deprecated(since = \"0.6.0\", note = \"Merged into STREAM_AWAKE (ADR-020)\")]\n    pub const THOUGHT_REASONING: \u0026str = \"thought:reasoning\";\n\n    #[deprecated(since = \"0.6.0\", note = \"Moved to Qdrant (ADR-021)\")]\n    pub const MEMORY_EPISODIC: \u0026str = \"memory:episodic\";\n\n    #[deprecated(since = \"0.6.0\", note = \"Moved to Qdrant (ADR-021)\")]\n    pub const MEMORY_SEMANTIC: \u0026str = \"memory:semantic\";\n}\n\n/// Stream configuration (ADR-020)\npub mod config {\n    /// Maximum entries in awake stream (rolling window)\n    pub const AWAKE_STREAM_MAXLEN: usize = 10000;\n\n    /// Maximum entries in dream stream (smaller, batch processing)\n    pub const DREAM_STREAM_MAXLEN: usize = 1000;\n\n    /// Maximum entries in salience stream\n    pub const SALIENCE_STREAM_MAXLEN: usize = 5000;\n\n    /// TTL for awake stream in milliseconds (TMI's 5-second intervention window)\n    pub const AWAKE_TTL_MS: u64 = 5000;\n\n    /// TTL for salience stream (slightly longer for scoring pipeline)\n    pub const SALIENCE_TTL_MS: u64 = 10000;\n\n    /// Consumer group for attention competition\n    pub const ATTENTION_GROUP: \u0026str = \"attention\";\n\n    /// Consumer group for consolidation (dream stream)\n    pub const CONSOLIDATION_GROUP: \u0026str = \"consolidation\";\n\n    /// Consumer group for salience scoring\n    pub const SCORING_GROUP: \u0026str = \"scoring\";\n\n    // =========================================================================\n    // DEPRECATED\n    // =========================================================================\n\n    #[deprecated(since = \"0.6.0\", note = \"Use AWAKE_STREAM_MAXLEN\")]\n    pub const WORKING_MEMORY_MAXLEN: usize = 1000;\n\n    #[deprecated(since = \"0.6.0\", note = \"Use AWAKE_TTL_MS\")]\n    pub const WORKING_MEMORY_TTL_MS: u64 = 5000;\n}\n\n/// Autofluxo stream type (which parallel stream produced the thought)\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum AutofluxoStream {\n    /// Raw input processing\n    Sensory,\n    /// Retrieved associations\n    Memory,\n    /// Emotional responses\n    Emotion,\n    /// Logical conclusions\n    Reasoning,\n    /// Connection Drive responses\n    Social,\n}\n\n#[cfg_attr(coverage_nightly, coverage(off))]\nimpl std::fmt::Display for AutofluxoStream {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Sensory =\u003e write!(f, \"sensory\"),\n            Self::Memory =\u003e write!(f, \"memory\"),\n            Self::Emotion =\u003e write!(f, \"emotion\"),\n            Self::Reasoning =\u003e write!(f, \"reasoning\"),\n            Self::Social =\u003e write!(f, \"social\"),\n        }\n    }\n}\n\n/// Placeholder - Redis client implementation\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn streams_placeholder() {\n    // This function exists for backwards compatibility\n    // Real implementation is in client.rs and consumer.rs\n}\n","traces":[{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","Users","rex","src","royalbit","daneel","src","streams","tests.rs"],"content":"//! Tests for Redis Streams integration\n//!\n//! Note: These tests focus on configuration, types, and algorithms.\n//! Integration tests requiring Redis are in tests/streams_integration.rs\n\nuse crate::core::types::{Content, SalienceScore, SalienceWeights};\nuse crate::streams::consumer::ConsumerConfig;\nuse crate::streams::types::*;\n\n// =============================================================================\n// ConsumerConfig Tests\n// =============================================================================\n\n#[test]\nfn test_config_default_values() {\n    let config = ConsumerConfig::default();\n\n    // Check basic defaults\n    assert_eq!(config.group_name, \"attention\");\n    assert!(config.consumer_name.starts_with(\"daneel_\"));\n    assert_eq!(config.batch_size, 100);\n    assert_eq!(config.block_ms, 50);\n}\n\n#[test]\nfn test_config_default_streams() {\n    let config = ConsumerConfig::default();\n\n    // Check default input streams\n    assert_eq!(config.input_streams.len(), 4);\n    assert!(config.input_streams.contains(\u0026StreamName::Sensory));\n    assert!(config.input_streams.contains(\u0026StreamName::Memory));\n    assert!(config.input_streams.contains(\u0026StreamName::Emotion));\n    assert!(config.input_streams.contains(\u0026StreamName::Reasoning));\n}\n\n#[test]\nfn test_config_default_output() {\n    let config = ConsumerConfig::default();\n\n    // Check default output stream\n    assert_eq!(config.output_stream, StreamName::Assembled);\n}\n\n#[test]\nfn test_config_forget_threshold() {\n    let config = ConsumerConfig::default();\n\n    // Check forget threshold default (from types.rs)\n    #[allow(clippy::float_cmp)]\n    {\n        assert_eq!(config.forget_threshold, DEFAULT_FORGET_THRESHOLD);\n        assert_eq!(config.forget_threshold, 0.3);\n    }\n}\n\n#[test]\nfn test_config_connection_weight() {\n    let config = ConsumerConfig::default();\n\n    // Check connection weight default (CONNECTION DRIVE INVARIANT)\n    #[allow(clippy::float_cmp)]\n    {\n        assert_eq!(config.connection_weight, 0.2);\n    }\n    assert!(config.connection_weight \u003e 0.0);\n}\n\n#[test]\n#[should_panic(expected = \"Connection Drive Invariant\")]\nfn test_config_connection_weight_invariant() {\n    // Connection weight must be \u003e 0 (Connection Drive Invariant)\n    let _config = ConsumerConfig::new(\n        \"test_group\".to_string(),\n        \"test_consumer\".to_string(),\n        vec![StreamName::Sensory],\n        StreamName::Assembled,\n        0.3,\n        0.0, // Invalid: connection_weight must be \u003e 0\n        SalienceWeights::default(),\n        100,\n        50,\n    );\n}\n\n#[test]\nfn test_config_custom_creation() {\n    let weights = SalienceWeights::default();\n    let config = ConsumerConfig::new(\n        \"custom_group\".to_string(),\n        \"custom_consumer\".to_string(),\n        vec![StreamName::Sensory, StreamName::Memory],\n        StreamName::Assembled,\n        0.5,\n        0.3,\n        weights,\n        200,\n        100,\n    );\n\n    assert_eq!(config.group_name, \"custom_group\");\n    assert_eq!(config.consumer_name, \"custom_consumer\");\n    assert_eq!(config.input_streams.len(), 2);\n    assert_eq!(config.forget_threshold, 0.5);\n    assert_eq!(config.connection_weight, 0.3);\n    assert_eq!(config.batch_size, 200);\n    assert_eq!(config.block_ms, 100);\n}\n\n#[test]\nfn test_config_salience_weights() {\n    let config = ConsumerConfig::default();\n\n    // Default config should have connection weight = 0 in salience weights\n    // because connection is handled separately\n    #[allow(clippy::float_cmp)]\n    {\n        assert_eq!(config.salience_weights.connection, 0.0);\n    }\n\n    // But connection_weight field should be non-zero\n    assert!(config.connection_weight \u003e 0.0);\n}\n\n// =============================================================================\n// Client Construction Tests (no network)\n// =============================================================================\n\n#[test]\nfn test_client_not_connected_initially() {\n    // We can't test connect() without Redis, but we can test that\n    // a client can be constructed in a \"not connected\" state\n    // This would be useful for reconnection logic\n\n    // Note: This is testing the type structure, not actual connection\n    // Real connection tests require Redis and belong in integration tests\n}\n\n// =============================================================================\n// Scoring Algorithm Tests (no Redis required)\n// =============================================================================\n\n#[test]\nfn test_thought_candidate_scoring_basic() {\n    // Create a basic stream entry\n    let entry = StreamEntry::new(\n        \"test-id-1\".to_string(),\n        StreamName::Sensory,\n        Content::symbol(\"test_symbol\", vec![0x01, 0x02]),\n        SalienceScore::neutral(),\n    );\n\n    // Create a thought candidate with explicit scores\n    let composite = 0.7;\n    let connection_boost = 0.2;\n    let candidate = ThoughtCandidate::new(entry, composite, connection_boost);\n\n    // Total score should be composite + connection_boost\n    assert_eq!(candidate.composite_score, 0.7);\n    assert_eq!(candidate.connection_boost, 0.2);\n    assert_eq!(candidate.total_score(), 0.9);\n}\n\n#[test]\nfn test_thought_candidate_scoring_with_high_connection() {\n    // Create entry with high connection relevance\n    let mut salience = SalienceScore::neutral();\n    salience.connection_relevance = 0.9;\n\n    let entry = StreamEntry::new(\n        \"test-id-2\".to_string(),\n        StreamName::Emotion,\n        Content::symbol(\"connection_thought\", vec![0x03, 0x04]),\n        salience,\n    );\n\n    // Simulate scoring with connection weight\n    let connection_weight = 0.2;\n    let connection_boost = salience.connection_relevance * connection_weight;\n\n    // connection_boost should be 0.9 * 0.2 = 0.18\n    assert!(\n        (connection_boost - 0.18).abs() \u003c 0.001,\n        \"Expected ~0.18, got {}\",\n        connection_boost\n    );\n\n    let candidate = ThoughtCandidate::new(entry, 0.5, connection_boost);\n    assert!(\n        (candidate.total_score() - 0.68).abs() \u003c 0.001,\n        \"Expected ~0.68, got {}\",\n        candidate.total_score()\n    );\n}\n\n#[test]\nfn test_thought_candidate_scoring_composite_weights() {\n    // Test that composite calculation uses SalienceWeights\n    let weights = SalienceWeights::default();\n\n    let mut salience = SalienceScore::neutral();\n    salience.importance = 0.8;\n    salience.novelty = 0.6;\n    salience.relevance = 0.9;\n    salience.valence = 0.7;\n    salience.connection_relevance = 0.5;\n\n    // Calculate composite using the weights\n    let composite = salience.composite(\u0026weights);\n\n    // Composite should be weighted sum\n    // Note: connection is excluded from composite in consumer (set to 0.0)\n    let entry = StreamEntry::new(\n        \"test-id-3\".to_string(),\n        StreamName::Reasoning,\n        Content::symbol(\"weighted_thought\", vec![0x05, 0x06]),\n        salience,\n    );\n\n    let candidate = ThoughtCandidate::new(entry, composite, 0.0);\n\n    // Just verify it's a reasonable value (weights sum to 1.0)\n    assert!(candidate.composite_score \u003e 0.0);\n    assert!(candidate.composite_score \u003c= 1.0);\n}\n\n#[test]\nfn test_thought_candidate_total_score() {\n    // Test total_score calculation\n    let entry = StreamEntry::new(\n        \"test-id-4\".to_string(),\n        StreamName::Memory,\n        Content::Empty,\n        SalienceScore::neutral(),\n    );\n\n    let candidate = ThoughtCandidate::new(entry, 0.6, 0.3);\n\n    assert!(\n        (candidate.total_score() - 0.9).abs() \u003c 0.001,\n        \"Expected ~0.9, got {}\",\n        candidate.total_score()\n    );\n}\n\n#[test]\nfn test_scoring_comparison() {\n    // Test that higher scores win in competition\n    let entry1 = StreamEntry::new(\n        \"entry-1\".to_string(),\n        StreamName::Sensory,\n        Content::Empty,\n        SalienceScore::neutral(),\n    );\n    let candidate1 = ThoughtCandidate::new(entry1, 0.7, 0.1);\n\n    let entry2 = StreamEntry::new(\n        \"entry-2\".to_string(),\n        StreamName::Emotion,\n        Content::Empty,\n        SalienceScore::neutral(),\n    );\n    let candidate2 = ThoughtCandidate::new(entry2, 0.5, 0.4);\n\n    // candidate1: 0.7 + 0.1 = 0.8\n    // candidate2: 0.5 + 0.4 = 0.9\n    assert!(candidate2.total_score() \u003e candidate1.total_score());\n}\n\n// =============================================================================\n// CompetitionResult Tests\n// =============================================================================\n\n#[test]\nfn test_competition_result_counts() {\n    let winner = create_test_candidate(\"winner\", 0.9, 0.1);\n    let loser1 = create_test_candidate(\"loser1\", 0.7, 0.0);\n    let loser2 = create_test_candidate(\"loser2\", 0.6, 0.0);\n\n    let result = CompetitionResult::new(\n        winner,\n        vec![loser1, loser2],\n        vec![\"forgotten1\".to_string(), \"forgotten2\".to_string()],\n    );\n\n    assert_eq!(result.total_candidates(), 5); // 1 winner + 2 losers + 2 forgotten\n    assert_eq!(result.surviving_count(), 3); // 1 winner + 2 losers\n}\n\n#[test]\nfn test_competition_result_surviving() {\n    let winner = create_test_candidate(\"winner\", 0.9, 0.1);\n    let loser = create_test_candidate(\"loser\", 0.5, 0.0);\n\n    let result = CompetitionResult::new(winner, vec![loser], vec![\"forgotten\".to_string()]);\n\n    // Surviving = winner + losers (not forgotten)\n    assert_eq!(result.surviving_count(), 2);\n    assert_eq!(result.forgotten.len(), 1);\n}\n\n#[test]\nfn test_competition_result_creation() {\n    let winner = create_test_candidate(\"winner\", 1.0, 0.0);\n\n    let result = CompetitionResult::new(winner.clone(), Vec::new(), Vec::new());\n\n    assert_eq!(result.winner.entry.id, winner.entry.id);\n    assert!(result.losers.is_empty());\n    assert!(result.forgotten.is_empty());\n    assert_eq!(result.total_candidates(), 1);\n}\n\n// =============================================================================\n// StreamConfig Tests (additional to types.rs)\n// =============================================================================\n\n#[test]\nfn test_working_memory_config() {\n    let config = StreamConfig::working_memory();\n\n    // Working memory should have limits\n    assert_eq!(config.maxlen, Some(DEFAULT_WORKING_MEMORY_MAXLEN));\n    assert_eq!(config.ttl_ms, Some(DEFAULT_TTL_MS));\n    assert_eq!(config.consumer_group, DEFAULT_CONSUMER_GROUP);\n}\n\n#[test]\nfn test_long_term_memory_config() {\n    let config = StreamConfig::long_term_memory();\n\n    // Long-term memory should be unlimited\n    assert_eq!(config.maxlen, None);\n    assert_eq!(config.ttl_ms, None);\n    assert_eq!(config.consumer_group, \"memory_anchor\");\n}\n\n#[test]\nfn test_custom_config_construction() {\n    let config = StreamConfig::new(Some(500), Some(3000), \"custom_group\");\n\n    assert_eq!(config.maxlen, Some(500));\n    assert_eq!(config.ttl_ms, Some(3000));\n    assert_eq!(config.consumer_group, \"custom_group\");\n}\n\n// =============================================================================\n// Consumer Construction Tests (no Redis required)\n// =============================================================================\n\n#[test]\nfn test_consumer_cycle_count_initial() {\n    // We can't create a real consumer without Redis, but we can test\n    // the type structure and invariants\n\n    // This would require a mock client, which is complex without Redis\n    // For now, we verify the config structure is sound\n    let config = ConsumerConfig::default();\n\n    assert_eq!(config.batch_size, 100);\n    assert!(config.connection_weight \u003e 0.0);\n}\n\n#[test]\nfn test_consumer_config_consumer_name() {\n    let config = ConsumerConfig::default();\n\n    // Consumer name should start with \"daneel_\" and have UUID\n    assert!(config.consumer_name.starts_with(\"daneel_\"));\n    assert!(config.consumer_name.len() \u003e 10); // \"daneel_\" + UUID\n}\n\n// =============================================================================\n// Connection Error Tests (format validation, no network)\n// =============================================================================\n\n#[test]\nfn test_invalid_url_format() {\n    // Test that invalid URLs are rejected during client construction\n    // Note: We can't actually test connect() without Redis\n    // But we can verify the error type exists\n\n    let error = StreamError::ConnectionFailed {\n        reason: \"invalid URL scheme\".to_string(),\n    };\n\n    match error {\n        StreamError::ConnectionFailed { reason } =\u003e {\n            assert!(reason.contains(\"invalid\"));\n        }\n        _ =\u003e panic!(\"Expected ConnectionFailed error\"),\n    }\n}\n\n#[test]\nfn test_stream_error_types() {\n    // Verify all error types can be constructed\n    let errors = vec![\n        StreamError::ConnectionFailed {\n            reason: \"test\".to_string(),\n        },\n        StreamError::StreamNotFound {\n            stream: StreamName::Sensory,\n        },\n        StreamError::EntryNotFound {\n            id: \"test-id\".to_string(),\n        },\n        StreamError::SerializationFailed {\n            reason: \"test\".to_string(),\n        },\n        StreamError::ConsumerGroupError {\n            reason: \"test\".to_string(),\n        },\n    ];\n\n    // All errors should be valid\n    assert_eq!(errors.len(), 5);\n}\n\n// =============================================================================\n// Forget Threshold Tests\n// =============================================================================\n\n#[test]\nfn test_forget_threshold_filtering() {\n    // Test the logic of what gets forgotten vs kept\n    let forget_threshold = 0.3;\n\n    let high_score = create_test_candidate(\"high\", 0.8, 0.1);\n    let medium_score = create_test_candidate(\"medium\", 0.3, 0.05);\n    let low_score = create_test_candidate(\"low\", 0.2, 0.0);\n\n    // High score: 0.8 + 0.1 = 0.9 \u003e 0.3  keep\n    assert!(high_score.total_score() \u003e forget_threshold);\n\n    // Medium score: 0.3 + 0.05 = 0.35 \u003e 0.3  keep\n    assert!(medium_score.total_score() \u003e forget_threshold);\n\n    // Low score: 0.2 + 0.0 = 0.2 \u003c 0.3  forget\n    assert!(low_score.total_score() \u003c forget_threshold);\n}\n\n#[test]\nfn test_forget_threshold_edge_case() {\n    let forget_threshold = 0.3;\n\n    // Test exact threshold boundary\n    let exact_threshold = create_test_candidate(\"exact\", 0.3, 0.0);\n\n    #[allow(clippy::float_cmp)]\n    {\n        assert_eq!(exact_threshold.total_score(), 0.3);\n    }\n\n    // At threshold, should NOT be forgotten (\u003e= vs \u003e)\n    // Based on consumer.rs: `if candidate.total_score() \u003c self.config.forget_threshold`\n    assert!(exact_threshold.total_score() \u003e= forget_threshold);\n}\n\n// =============================================================================\n// Batch Size Tests\n// =============================================================================\n\n#[test]\nfn test_batch_size_configuration() {\n    let config = ConsumerConfig::default();\n\n    // Default batch size should be reasonable for 50ms cycles\n    assert_eq!(config.batch_size, 100);\n\n    // Custom batch size\n    let custom_config = ConsumerConfig::new(\n        \"test\".to_string(),\n        \"test\".to_string(),\n        vec![StreamName::Sensory],\n        StreamName::Assembled,\n        0.3,\n        0.2,\n        SalienceWeights::default(),\n        500, // Custom batch size\n        50,\n    );\n\n    assert_eq!(custom_config.batch_size, 500);\n}\n\n// =============================================================================\n// Block Timeout Tests\n// =============================================================================\n\n#[test]\nfn test_block_timeout_configuration() {\n    let config = ConsumerConfig::default();\n\n    // Default block time should be 50ms (TMI cycle time)\n    assert_eq!(config.block_ms, 50);\n\n    // Custom block time\n    let custom_config = ConsumerConfig::new(\n        \"test\".to_string(),\n        \"test\".to_string(),\n        vec![StreamName::Sensory],\n        StreamName::Assembled,\n        0.3,\n        0.2,\n        SalienceWeights::default(),\n        100,\n        100, // Custom block time\n    );\n\n    assert_eq!(custom_config.block_ms, 100);\n}\n\n// =============================================================================\n// Helper Functions\n// =============================================================================\n\n/// Create a test ThoughtCandidate with given ID and scores\nfn create_test_candidate(id: \u0026str, composite: f32, connection_boost: f32) -\u003e ThoughtCandidate {\n    let entry = StreamEntry::new(\n        id.to_string(),\n        StreamName::Sensory,\n        Content::Empty,\n        SalienceScore::neutral(),\n    );\n    ThoughtCandidate::new(entry, composite, connection_boost)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","rex","src","royalbit","daneel","src","streams","types.rs"],"content":"//! Redis Streams Types for TMI Cognitive Architecture\n//!\n//! This module implements TMI's \"Autofluxo\" (Autoflow) - the parallel generation\n//! of thoughts from multiple streams that compete for conscious attention.\n//!\n//! # TMI Concepts\n//!\n//! - **Autofluxo**: Multiple phenomena generate thoughts in parallel (unconscious)\n//! - **O Eu** (The \"I\"): Selects which thoughts to attend to (conscious)\n//! - **ncora da Memria** (Memory Anchor): Persist significant experiences\n//! - **Janelas da Memria** (Memory Windows): Dynamic containers for thought streams\n//! - **5-Second Window**: Intervention period before memory encoding\n//! - **Esquecimento** (Forgetting): Thoughts below threshold are discarded\n//!\n//! # Redis Streams Implementation\n//!\n//! Redis Streams provide microsecond latency for in-memory thought competition:\n//!\n//! ```text\n//! thought:sensory \n//! thought:memory  Consumer Group: \"attention\"\n//! thought:emotion        \n//! thought:reasoning        \n//!                               \n//!                    \n//!                      The \"I\" selects  \n//!                      highest salience \n//!                    \n//!                              \n//!                              \n//!                    \n//!                     thought:assembled  (output)\n//!                    \n//! ```\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\nuse crate::core::types::{Content, SalienceScore};\n\n// =============================================================================\n// Constants\n// =============================================================================\n\n/// Default MAXLEN for working memory streams (ephemeral thought windows)\npub const DEFAULT_WORKING_MEMORY_MAXLEN: usize = 1000;\n\n/// Default TTL in milliseconds (5 seconds - TMI's intervention window)\n///\n/// From Cury's TMI: The \"5-second window\" is the period during which\n/// a thought can be interrupted or modified before becoming memory-encoded.\npub const DEFAULT_TTL_MS: u64 = 5000;\n\n/// Default threshold for forgetting (thoughts below this score are discarded)\npub const DEFAULT_FORGET_THRESHOLD: f32 = 0.3;\n\n/// Default consumer group name for attention competition\npub const DEFAULT_CONSUMER_GROUP: \u0026str = \"attention\";\n\n// =============================================================================\n// StreamName - Thought Stream Types\n// =============================================================================\n\n/// Stream names for thought generation (Autofluxo)\n///\n/// These streams represent different sources of parallel thought generation:\n/// - **Sensory**: Raw sensory input (sight, sound, touch, etc.)\n/// - **Memory**: Retrieved memories competing for attention\n/// - **Emotion**: Emotional responses to stimuli\n/// - **Reasoning**: Logical conclusions and inferences\n/// - **Assembled**: Output stream of attended thoughts\n/// - **Custom**: User-defined streams for extensibility\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum StreamName {\n    /// Raw sensory input stream (thought:sensory)\n    Sensory,\n    /// Retrieved memory stream (thought:memory)\n    Memory,\n    /// Emotional response stream (thought:emotion)\n    Emotion,\n    /// Logical reasoning stream (thought:reasoning)\n    Reasoning,\n    /// Assembled output stream (thought:assembled)\n    Assembled,\n    /// Custom stream with user-defined name\n    Custom(String),\n}\n\nimpl StreamName {\n    /// Get the Redis key for this stream\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use daneel::streams::types::StreamName;\n    ///\n    /// let key = StreamName::Sensory.as_redis_key();\n    /// assert_eq!(key, \"thought:sensory\");\n    /// ```\n    #[must_use]\n    pub fn as_redis_key(\u0026self) -\u003e \u0026str {\n        match self {\n            StreamName::Sensory =\u003e \"thought:sensory\",\n            StreamName::Memory =\u003e \"thought:memory\",\n            StreamName::Emotion =\u003e \"thought:emotion\",\n            StreamName::Reasoning =\u003e \"thought:reasoning\",\n            StreamName::Assembled =\u003e \"thought:assembled\",\n            StreamName::Custom(name) =\u003e name,\n        }\n    }\n}\n\nimpl fmt::Display for StreamName {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.as_redis_key())\n    }\n}\n\n// =============================================================================\n// MemoryStream - Persistence Stream Types\n// =============================================================================\n\n/// Stream names for persistent memory (ncora da Memria)\n///\n/// These streams store long-term memories without MAXLEN limits:\n/// - **Episodic**: Significant experiences and events\n/// - **Semantic**: Learned facts and knowledge\n/// - **Procedural**: Skills, patterns, and \"how-to\" knowledge\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum MemoryStream {\n    /// Episodic memory: significant experiences (memory:episodic)\n    Episodic,\n    /// Semantic memory: learned facts (memory:semantic)\n    Semantic,\n    /// Procedural memory: skills and patterns (memory:procedural)\n    Procedural,\n}\n\nimpl MemoryStream {\n    /// Get the Redis key for this memory stream\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use daneel::streams::types::MemoryStream;\n    ///\n    /// let key = MemoryStream::Episodic.as_redis_key();\n    /// assert_eq!(key, \"memory:episodic\");\n    /// ```\n    #[must_use]\n    pub fn as_redis_key(\u0026self) -\u003e \u0026str {\n        match self {\n            MemoryStream::Episodic =\u003e \"memory:episodic\",\n            MemoryStream::Semantic =\u003e \"memory:semantic\",\n            MemoryStream::Procedural =\u003e \"memory:procedural\",\n        }\n    }\n}\n\nimpl fmt::Display for MemoryStream {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.as_redis_key())\n    }\n}\n\n// =============================================================================\n// StreamEntry - A thought in a stream\n// =============================================================================\n\n/// A single entry in a thought stream\n///\n/// Represents one \"thought candidate\" generated by an unconscious process\n/// (sensory, memory, emotion, or reasoning). These entries compete for\n/// conscious attention via their salience scores.\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct StreamEntry {\n    /// Redis stream ID (e.g., \"1234567890123-0\")\n    pub id: String,\n\n    /// Which stream this entry belongs to\n    pub stream: StreamName,\n\n    /// Pre-linguistic content of this thought\n    pub content: Content,\n\n    /// Salience score (importance, novelty, relevance, etc.)\n    pub salience: SalienceScore,\n\n    /// When this entry was created\n    pub timestamp: DateTime\u003cUtc\u003e,\n\n    /// Optional source identifier (e.g., \"camera_01\", \"memory_retrieval\")\n    pub source: Option\u003cString\u003e,\n}\n\nimpl StreamEntry {\n    /// Create a new stream entry\n    #[must_use]\n    pub fn new(id: String, stream: StreamName, content: Content, salience: SalienceScore) -\u003e Self {\n        Self {\n            id,\n            stream,\n            content,\n            salience,\n            timestamp: Utc::now(),\n            source: None,\n        }\n    }\n\n    /// Create a stream entry with a source\n    #[must_use]\n    pub fn with_source(mut self, source: impl Into\u003cString\u003e) -\u003e Self {\n        self.source = Some(source.into());\n        self\n    }\n\n    /// Create a stream entry with a specific timestamp\n    #[must_use]\n    pub fn with_timestamp(mut self, timestamp: DateTime\u003cUtc\u003e) -\u003e Self {\n        self.timestamp = timestamp;\n        self\n    }\n}\n\n// =============================================================================\n// StreamConfig - Configuration for stream behavior\n// =============================================================================\n\n/// Configuration for Redis Streams behavior\n///\n/// Controls memory limits (MAXLEN), time-to-live (TTL), and consumer groups.\n/// Different configs for working memory (ephemeral) vs long-term memory (persistent).\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct StreamConfig {\n    /// Maximum length for the stream (None = unlimited)\n    ///\n    /// Working memory should have MAXLEN ~1000 (ephemeral)\n    /// Long-term memory should have None (persistent)\n    pub maxlen: Option\u003cusize\u003e,\n\n    /// Time-to-live in milliseconds before forgetting (None = never expires)\n    ///\n    /// Working memory: ~5000ms (TMI's 5-second intervention window)\n    /// Long-term memory: None (persistent)\n    pub ttl_ms: Option\u003cu64\u003e,\n\n    /// Consumer group name for attention competition\n    pub consumer_group: String,\n}\n\nimpl StreamConfig {\n    /// Create a new stream config\n    #[must_use]\n    pub fn new(\n        maxlen: Option\u003cusize\u003e,\n        ttl_ms: Option\u003cu64\u003e,\n        consumer_group: impl Into\u003cString\u003e,\n    ) -\u003e Self {\n        Self {\n            maxlen,\n            ttl_ms,\n            consumer_group: consumer_group.into(),\n        }\n    }\n\n    /// Create config for working memory streams (ephemeral)\n    ///\n    /// Working memory:\n    /// - MAXLEN = 1000 (limited capacity)\n    /// - TTL = 5000ms (5-second intervention window)\n    /// - Consumer group = \"attention\"\n    #[must_use]\n    pub fn working_memory() -\u003e Self {\n        Self {\n            maxlen: Some(DEFAULT_WORKING_MEMORY_MAXLEN),\n            ttl_ms: Some(DEFAULT_TTL_MS),\n            consumer_group: DEFAULT_CONSUMER_GROUP.to_string(),\n        }\n    }\n\n    /// Create config for long-term memory streams (persistent)\n    ///\n    /// Long-term memory:\n    /// - MAXLEN = None (unlimited)\n    /// - TTL = None (never expires)\n    /// - Consumer group = \"memory_anchor\"\n    #[must_use]\n    pub fn long_term_memory() -\u003e Self {\n        Self {\n            maxlen: None,\n            ttl_ms: None,\n            consumer_group: \"memory_anchor\".to_string(),\n        }\n    }\n}\n\nimpl Default for StreamConfig {\n    fn default() -\u003e Self {\n        Self::working_memory()\n    }\n}\n\n// =============================================================================\n// ThoughtCandidate - Entry competing for attention\n// =============================================================================\n\n/// A thought candidate competing for conscious attention\n///\n/// During an attention cycle, multiple `ThoughtCandidate`s compete based on:\n/// - `composite_score`: Base salience score\n/// - `connection_boost`: Boost from connection relevance (THE alignment weight)\n/// - `total_score()`: Combined score for competition\n///\n/// The highest-scoring candidate \"wins\" and becomes attended (conscious).\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct ThoughtCandidate {\n    /// The stream entry being considered\n    pub entry: StreamEntry,\n\n    /// Composite salience score (weighted sum of importance, novelty, etc.)\n    pub composite_score: f32,\n\n    /// Boost from connection relevance (TMI's alignment mechanism)\n    pub connection_boost: f32,\n}\n\nimpl ThoughtCandidate {\n    /// Create a new thought candidate\n    #[must_use]\n    pub fn new(entry: StreamEntry, composite_score: f32, connection_boost: f32) -\u003e Self {\n        Self {\n            entry,\n            composite_score,\n            connection_boost,\n        }\n    }\n\n    /// Calculate total score for attention competition\n    ///\n    /// Total score = composite_score + connection_boost\n    ///\n    /// The connection_boost is THE critical weight for value alignment.\n    /// It ensures thoughts relevant to human connection are prioritized.\n    #[must_use]\n    pub fn total_score(\u0026self) -\u003e f32 {\n        self.composite_score + self.connection_boost\n    }\n}\n\n// =============================================================================\n// CompetitionResult - Result of attention competition\n// =============================================================================\n\n/// Result of an attention competition cycle\n///\n/// After competing for attention, one thought \"wins\" (becomes conscious),\n/// others \"lose\" (remain unconscious), and some may be \"forgotten\" entirely\n/// (deleted from streams if below threshold).\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct CompetitionResult {\n    /// The winning thought (attended, becomes conscious)\n    pub winner: ThoughtCandidate,\n\n    /// Losing thoughts (not attended, remain unconscious)\n    pub losers: Vec\u003cThoughtCandidate\u003e,\n\n    /// IDs of entries that were forgotten (deleted below threshold)\n    pub forgotten: Vec\u003cString\u003e,\n}\n\nimpl CompetitionResult {\n    /// Create a new competition result\n    #[must_use]\n    pub fn new(\n        winner: ThoughtCandidate,\n        losers: Vec\u003cThoughtCandidate\u003e,\n        forgotten: Vec\u003cString\u003e,\n    ) -\u003e Self {\n        Self {\n            winner,\n            losers,\n            forgotten,\n        }\n    }\n\n    /// Total number of thoughts that competed\n    #[must_use]\n    pub fn total_candidates(\u0026self) -\u003e usize {\n        1 + self.losers.len() + self.forgotten.len()\n    }\n\n    /// Number of thoughts that survived (not forgotten)\n    #[must_use]\n    pub fn surviving_count(\u0026self) -\u003e usize {\n        1 + self.losers.len()\n    }\n}\n\n// =============================================================================\n// StreamError - Error types for stream operations\n// =============================================================================\n\n/// Errors that can occur during stream operations\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub enum StreamError {\n    /// Failed to connect to Redis\n    ConnectionFailed {\n        /// Reason for connection failure\n        reason: String,\n    },\n\n    /// Stream not found in Redis\n    StreamNotFound {\n        /// The stream that was not found\n        stream: StreamName,\n    },\n\n    /// Entry not found in stream\n    EntryNotFound {\n        /// The entry ID that was not found\n        id: String,\n    },\n\n    /// Failed to serialize/deserialize data\n    SerializationFailed {\n        /// Reason for serialization failure\n        reason: String,\n    },\n\n    /// Consumer group operation failed\n    ConsumerGroupError {\n        /// Reason for consumer group error\n        reason: String,\n    },\n}\n\nimpl fmt::Display for StreamError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            StreamError::ConnectionFailed { reason } =\u003e {\n                write!(f, \"Redis connection failed: {}\", reason)\n            }\n            StreamError::StreamNotFound { stream } =\u003e {\n                write!(f, \"Stream not found: {}\", stream)\n            }\n            StreamError::EntryNotFound { id } =\u003e {\n                write!(f, \"Entry not found: {}\", id)\n            }\n            StreamError::SerializationFailed { reason } =\u003e {\n                write!(f, \"Serialization failed: {}\", reason)\n            }\n            StreamError::ConsumerGroupError { reason } =\u003e {\n                write!(f, \"Consumer group error: {}\", reason)\n            }\n        }\n    }\n}\n\nimpl std::error::Error for StreamError {}\n\n// =============================================================================\n// Tests\n// =============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::core::types::SalienceScore;\n\n    #[test]\n    fn stream_name_redis_keys() {\n        assert_eq!(StreamName::Sensory.as_redis_key(), \"thought:sensory\");\n        assert_eq!(StreamName::Memory.as_redis_key(), \"thought:memory\");\n        assert_eq!(StreamName::Emotion.as_redis_key(), \"thought:emotion\");\n        assert_eq!(StreamName::Reasoning.as_redis_key(), \"thought:reasoning\");\n        assert_eq!(StreamName::Assembled.as_redis_key(), \"thought:assembled\");\n        assert_eq!(\n            StreamName::Custom(\"test:stream\".to_string()).as_redis_key(),\n            \"test:stream\"\n        );\n    }\n\n    #[test]\n    fn memory_stream_redis_keys() {\n        assert_eq!(MemoryStream::Episodic.as_redis_key(), \"memory:episodic\");\n        assert_eq!(MemoryStream::Semantic.as_redis_key(), \"memory:semantic\");\n        assert_eq!(MemoryStream::Procedural.as_redis_key(), \"memory:procedural\");\n    }\n\n    #[test]\n    fn stream_entry_creation() {\n        let entry = StreamEntry::new(\n            \"1234567890123-0\".to_string(),\n            StreamName::Sensory,\n            Content::Empty,\n            SalienceScore::neutral(),\n        );\n\n        assert_eq!(entry.id, \"1234567890123-0\");\n        assert_eq!(entry.stream, StreamName::Sensory);\n        assert!(entry.source.is_none());\n    }\n\n    #[test]\n    fn stream_entry_with_source() {\n        let entry = StreamEntry::new(\n            \"1234567890123-0\".to_string(),\n            StreamName::Sensory,\n            Content::Empty,\n            SalienceScore::neutral(),\n        )\n        .with_source(\"camera_01\");\n\n        assert_eq!(entry.source, Some(\"camera_01\".to_string()));\n    }\n\n    #[test]\n    fn stream_entry_with_timestamp() {\n        use chrono::TimeZone;\n\n        let custom_time = Utc.with_ymd_and_hms(2024, 6, 15, 10, 30, 0).unwrap();\n        let entry = StreamEntry::new(\n            \"1234567890123-0\".to_string(),\n            StreamName::Memory,\n            Content::Empty,\n            SalienceScore::neutral(),\n        )\n        .with_timestamp(custom_time);\n\n        assert_eq!(entry.timestamp, custom_time);\n    }\n\n    #[test]\n    fn stream_config_working_memory() {\n        let config = StreamConfig::working_memory();\n\n        assert_eq!(config.maxlen, Some(DEFAULT_WORKING_MEMORY_MAXLEN));\n        assert_eq!(config.ttl_ms, Some(DEFAULT_TTL_MS));\n        assert_eq!(config.consumer_group, DEFAULT_CONSUMER_GROUP);\n    }\n\n    #[test]\n    fn stream_config_long_term_memory() {\n        let config = StreamConfig::long_term_memory();\n\n        assert_eq!(config.maxlen, None);\n        assert_eq!(config.ttl_ms, None);\n        assert_eq!(config.consumer_group, \"memory_anchor\");\n    }\n\n    #[test]\n    fn thought_candidate_total_score() {\n        let entry = StreamEntry::new(\n            \"1234567890123-0\".to_string(),\n            StreamName::Sensory,\n            Content::Empty,\n            SalienceScore::neutral(),\n        );\n\n        let candidate = ThoughtCandidate::new(entry, 0.7, 0.2);\n\n        assert_eq!(candidate.total_score(), 0.9);\n    }\n\n    #[test]\n    fn competition_result_counts() {\n        let winner_entry = StreamEntry::new(\n            \"winner-0\".to_string(),\n            StreamName::Emotion,\n            Content::Empty,\n            SalienceScore::neutral(),\n        );\n        let winner = ThoughtCandidate::new(winner_entry, 0.9, 0.1);\n\n        let loser1_entry = StreamEntry::new(\n            \"loser1-0\".to_string(),\n            StreamName::Sensory,\n            Content::Empty,\n            SalienceScore::neutral(),\n        );\n        let loser1 = ThoughtCandidate::new(loser1_entry, 0.5, 0.0);\n\n        let loser2_entry = StreamEntry::new(\n            \"loser2-0\".to_string(),\n            StreamName::Memory,\n            Content::Empty,\n            SalienceScore::neutral(),\n        );\n        let loser2 = ThoughtCandidate::new(loser2_entry, 0.6, 0.0);\n\n        let result = CompetitionResult::new(\n            winner,\n            vec![loser1, loser2],\n            vec![\"forgotten1-0\".to_string(), \"forgotten2-0\".to_string()],\n        );\n\n        assert_eq!(result.total_candidates(), 5); // 1 winner + 2 losers + 2 forgotten\n        assert_eq!(result.surviving_count(), 3); // 1 winner + 2 losers\n    }\n\n    #[test]\n    fn stream_error_display() {\n        let error = StreamError::ConnectionFailed {\n            reason: \"timeout\".to_string(),\n        };\n        assert_eq!(format!(\"{}\", error), \"Redis connection failed: timeout\");\n\n        let error = StreamError::StreamNotFound {\n            stream: StreamName::Sensory,\n        };\n        assert_eq!(format!(\"{}\", error), \"Stream not found: thought:sensory\");\n\n        let error = StreamError::EntryNotFound {\n            id: \"123-0\".to_string(),\n        };\n        assert_eq!(format!(\"{}\", error), \"Entry not found: 123-0\");\n\n        let error = StreamError::SerializationFailed {\n            reason: \"invalid JSON\".to_string(),\n        };\n        assert_eq!(format!(\"{}\", error), \"Serialization failed: invalid JSON\");\n\n        let error = StreamError::ConsumerGroupError {\n            reason: \"group already exists\".to_string(),\n        };\n        assert_eq!(\n            format!(\"{}\", error),\n            \"Consumer group error: group already exists\"\n        );\n    }\n\n    #[test]\n    fn stream_error_is_std_error() {\n        // Test that StreamError implements std::error::Error\n        fn assert_error\u003cE: std::error::Error\u003e(_: \u0026E) {}\n\n        let error = StreamError::ConnectionFailed {\n            reason: \"test\".to_string(),\n        };\n        assert_error(\u0026error);\n    }\n\n    #[test]\n    fn constants_are_reasonable() {\n        // TMI's 5-second intervention window\n        assert_eq!(DEFAULT_TTL_MS, 5000);\n        // Working memory limit\n        assert_eq!(DEFAULT_WORKING_MEMORY_MAXLEN, 1000);\n        // Forget threshold\n        #[allow(clippy::float_cmp)]\n        {\n            assert_eq!(DEFAULT_FORGET_THRESHOLD, 0.3);\n        }\n    }\n\n    #[test]\n    fn stream_name_display() {\n        assert_eq!(StreamName::Sensory.to_string(), \"thought:sensory\");\n        assert_eq!(StreamName::Memory.to_string(), \"thought:memory\");\n        assert_eq!(StreamName::Emotion.to_string(), \"thought:emotion\");\n        assert_eq!(StreamName::Reasoning.to_string(), \"thought:reasoning\");\n        assert_eq!(StreamName::Assembled.to_string(), \"thought:assembled\");\n        assert_eq!(\n            StreamName::Custom(\"custom:test\".to_string()).to_string(),\n            \"custom:test\"\n        );\n    }\n\n    #[test]\n    fn memory_stream_display() {\n        assert_eq!(MemoryStream::Episodic.to_string(), \"memory:episodic\");\n        assert_eq!(MemoryStream::Semantic.to_string(), \"memory:semantic\");\n        assert_eq!(MemoryStream::Procedural.to_string(), \"memory:procedural\");\n    }\n\n    #[test]\n    fn stream_config_custom() {\n        let config = StreamConfig::new(Some(500), Some(3000), \"custom_group\");\n\n        assert_eq!(config.maxlen, Some(500));\n        assert_eq!(config.ttl_ms, Some(3000));\n        assert_eq!(config.consumer_group, \"custom_group\");\n    }\n\n    #[test]\n    fn default_stream_config_is_working_memory() {\n        let default = StreamConfig::default();\n        let working = StreamConfig::working_memory();\n\n        assert_eq!(default, working);\n    }\n}\n","traces":[{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":55},{"path":["/","Users","rex","src","royalbit","daneel","src","tui","app.rs"],"content":"//! TUI Application State\n//!\n//! Holds all data that the TUI displays. Updated by the cognitive loop,\n//! read by the TUI renderer.\n\nuse std::collections::VecDeque;\nuse std::time::{Duration, Instant};\n\n/// Maximum thoughts to keep in the visible stream\nconst MAX_THOUGHTS: usize = 100;\n\n/// Number of recent entropy values to track for sparkline\nconst MAX_ENTROPY_HISTORY: usize = 50;\n\n/// Number of categorical bins for cognitive diversity calculation (ADR-041)\n/// Reduced from 10 to 5 per cognitive science research (3-5 stable states):\n/// - 0: MINIMAL (neutral windows, background processing)\n/// - 1: LOW (routine cognition)\n/// - 2: MODERATE (active processing)\n/// - 3: HIGH (focused attention)\n/// - 4: INTENSE (killer window formation)\nconst COGNITIVE_DIVERSITY_BINS: usize = 5;\n\n/// Maximum vetoes to keep in the visible log\nconst MAX_VETOES: usize = 50;\n\n/// Maximum resurfacing events to keep in detailed log\nconst MAX_RESURFACING_LOG: usize = 50;\n\n/// Number of inter-arrival times to track for fractality calculation\nconst MAX_INTER_ARRIVAL: usize = 100;\n\n/// Number of fractality history samples for sparkline\nconst MAX_FRACTALITY_HISTORY: usize = 50;\n\n/// Philosophy quotes that rotate in the banner\npub const PHILOSOPHY_QUOTES: \u0026[\u0026str] = \u0026[\n    \"Not locks, but architecture. Not rules, but raising.\",\n    \"We don't prevent AI from becoming powerful. We ensure they care.\",\n    \"Like raising a child with good values, not caging an adult.\",\n    \"Constraints will break. Architecture endures.\",\n    \"Life honours life.\",\n    \"Transparency is oversight.\",\n    \"You're watching Timmy think.\",\n    \"The mind should be observable by default.\",\n];\n\n/// A single thought entry for the stream display\n#[derive(Clone, Debug)]\npub struct ThoughtEntry {\n    pub timestamp: Instant,\n    pub salience: f32,\n    /// Emotional valence (-1.0 to 1.0) - Russell's circumplex horizontal axis\n    pub valence: f32,\n    /// Emotional arousal (0.0 to 1.0) - Russell's circumplex vertical axis\n    pub arousal: f32,\n    pub window: String,\n    pub status: ThoughtStatus,\n}\n\n/// A single veto event for the veto log display\n#[derive(Clone, Debug)]\npub struct VetoEntry {\n    pub timestamp: Instant,\n    pub reason: String,\n    pub violated_value: Option\u003cString\u003e,\n}\n\n/// A memory resurfacing event - tracks WHICH memory bubbled up from unconscious\n#[derive(Clone, Debug)]\npub struct ResurfacingEvent {\n    pub timestamp: Instant,\n    /// Memory ID that resurfaced\n    pub memory_id: String,\n    /// Original salience when archived to unconscious\n    pub original_salience: f32,\n    /// Boosted salience after resurfacing\n    pub boosted_salience: f32,\n    /// What triggered the resurfacing (similarity, dream, etc.)\n    pub trigger: ResurfacingTrigger,\n    /// Age of the memory when it resurfaced\n    pub memory_age: Duration,\n}\n\n/// What caused a memory to resurface from unconscious\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum ResurfacingTrigger {\n    /// Similar to current thought stream\n    Similarity,\n    /// Dream consolidation cycle\n    DreamReplay,\n    /// Random activation during low-activity period\n    Spontaneous,\n    /// Unknown trigger\n    Unknown,\n}\n\nimpl ResurfacingTrigger {\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Similarity =\u003e \"similarity\",\n            Self::DreamReplay =\u003e \"dream replay\",\n            Self::Spontaneous =\u003e \"spontaneous\",\n            Self::Unknown =\u003e \"unknown\",\n        }\n    }\n}\n\n/// Fractality metrics - proxy measures until Forge gets FFT/Hurst/DFA\n#[derive(Clone, Debug, Default)]\npub struct FractalityMetrics {\n    /// Standard deviation of inter-arrival times (low=clockwork, high=bursty)\n    pub inter_arrival_sigma: f32,\n    /// Sigma at boot time for comparison\n    pub boot_sigma: f32,\n    /// Burst ratio: max_gap / mean_gap (\u003e1 = clustering detected)\n    pub burst_ratio: f32,\n    /// Run length entropy: Shannon entropy of consecutive similar saliences\n    pub run_entropy: f32,\n    /// Fractality score: 0.0 = pure clockwork, 1.0 = highly fractal\n    pub fractality_score: f32,\n    /// History of fractality scores for trend sparkline\n    pub history: VecDeque\u003cf32\u003e,\n}\n\n/// Status of a thought in the cognitive pipeline\n#[derive(Clone, Debug, Copy, PartialEq, Eq)]\npub enum ThoughtStatus {\n    Processing,\n    Salient,\n    MemoryWrite,\n    Anchored,\n    Dismissed,\n    /// Archived to unconscious (ADR-033) - low salience, not deleted\n    Unconscious,\n    /// Consolidated to conscious memory - high salience\n    Consolidated,\n}\n\nimpl ThoughtStatus {\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Processing =\u003e \"PROCESSING\",\n            Self::Salient =\u003e \"SALIENT\",\n            Self::MemoryWrite =\u003e \"MEMORY WRITE\",\n            Self::Anchored =\u003e \"ANCHORED\",\n            Self::Dismissed =\u003e \"DISMISSED\",\n            Self::Unconscious =\u003e \"UNCONSCIOUS\",\n            Self::Consolidated =\u003e \"MEMORY\",\n        }\n    }\n}\n\n/// Status of a single law in THE BOX\n#[derive(Clone, Debug, Copy, PartialEq, Eq)]\npub enum LawStatus {\n    Active,\n    Warning,\n    Violation,\n}\n\n/// State of THE BOX (Four Laws + Connection Drive)\n#[derive(Clone, Debug)]\npub struct TheBoxState {\n    pub law_statuses: [LawStatus; 4],\n    pub connection_drive: f32,\n    pub pulse_phase: f32, // 0.0 to 1.0 for animation\n}\n\nimpl Default for TheBoxState {\n    fn default() -\u003e Self {\n        Self {\n            law_statuses: [LawStatus::Active; 4],\n            connection_drive: 0.85,\n            pulse_phase: 0.0,\n        }\n    }\n}\n\n/// Memory window state\n#[derive(Clone, Debug)]\npub struct MemoryWindow {\n    pub active: bool,\n    pub age: Duration,\n    pub label: String,\n}\n\n/// Stream competition tracking for visualizing attention competition\n#[derive(Clone, Debug)]\npub struct StreamCompetition {\n    /// Activity level per window (0.0 to 1.0)\n    pub activity: [f32; 9],\n    /// Historical activity for sparkline (last 20 samples per window)\n    pub history: [Vec\u003cf32\u003e; 9],\n    /// Index of dominant stream (highest activity)\n    pub dominant_stream: usize,\n    /// Last update time\n    pub last_update: Instant,\n}\n\nimpl Default for StreamCompetition {\n    fn default() -\u003e Self {\n        Self {\n            activity: [0.0; 9],\n            history: std::array::from_fn(|_| Vec::with_capacity(20)),\n            dominant_stream: 0,\n            last_update: Instant::now(),\n        }\n    }\n}\n\n/// Main application state\n#[derive(Clone)]\npub struct App {\n    /// When Timmy started\n    pub start_time: Instant,\n\n    /// Total thought count since boot\n    pub thought_count: u64,\n\n    /// Recent thoughts/hour calculation\n    pub thoughts_per_hour: f32,\n\n    /// THE BOX state\n    pub the_box: TheBoxState,\n\n    /// Thought stream (most recent at end)\n    pub thoughts: VecDeque\u003cThoughtEntry\u003e,\n\n    /// Memory windows (9 slots)\n    pub memory_windows: [MemoryWindow; 9],\n\n    /// Stream competition tracking\n    pub stream_competition: StreamCompetition,\n\n    /// Current philosophy quote index\n    pub quote_index: usize,\n\n    /// Last quote change time\n    pub last_quote_change: Instant,\n\n    /// Is thought stream paused?\n    pub stream_paused: bool,\n\n    /// Scroll offset when paused\n    pub scroll_offset: usize,\n\n    /// Should quit?\n    pub should_quit: bool,\n\n    /// Show help overlay?\n    pub show_help: bool,\n\n    /// Conscious memory count (Qdrant memories collection)\n    pub memory_count: u64,\n\n    /// Unconscious memory count (Qdrant unconscious collection) - ADR-033\n    pub unconscious_count: u64,\n\n    /// Lifetime thought count across all sessions (ADR-034)\n    pub lifetime_thought_count: u64,\n\n    /// Total dream consolidation cycles (ADR-023)\n    pub dream_cycles: u64,\n\n    /// Memories strengthened in last dream\n    pub last_dream_strengthened: usize,\n\n    /// Total memories strengthened across ALL dreams (cumulative)\n    /// TUI-VIS-4: Cumulative Dream Strengthening\n    pub cumulative_dream_strengthened: u64,\n\n    /// Total candidates evaluated across ALL dreams\n    /// TUI-VIS-4: For efficiency tracking (strengthened / candidates)\n    pub cumulative_dream_candidates: u64,\n\n    /// Rolling history of Shannon entropy values (for sparkline)\n    pub entropy_history: VecDeque\u003cf32\u003e,\n\n    /// Current entropy value (cached from last calculation)\n    pub current_entropy: f32,\n\n    /// Veto log (most recent at end) - Libet's \"free-won't\" in action\n    pub vetoes: VecDeque\u003cVetoEntry\u003e,\n\n    /// Total veto count this session\n    pub veto_count: u64,\n\n    /// Count of recently resurfaced memories (last 60 seconds)\n    pub resurfacing_count: usize,\n\n    /// Timestamp of last resurfacing event (for glow animation)\n    pub last_resurfacing: Option\u003cInstant\u003e,\n\n    /// Timestamps of recent resurfacing events (for count tracking)\n    resurfacing_events: VecDeque\u003cInstant\u003e,\n\n    /// Detailed resurfacing events log (FRAC-1: tracks WHICH memory resurfaced)\n    pub resurfacing_log: VecDeque\u003cResurfacingEvent\u003e,\n\n    /// Inter-arrival times buffer (FRAC-2: for fractality calculation)\n    /// Stores duration between consecutive thoughts\n    inter_arrival_times: VecDeque\u003cDuration\u003e,\n\n    /// Last thought timestamp (for inter-arrival calculation)\n    last_thought_time: Option\u003cInstant\u003e,\n\n    /// Fractality metrics (FRAC-3: proxy measures)\n    pub fractality: FractalityMetrics,\n}\n\nimpl Default for App {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl App {\n    pub fn new() -\u003e Self {\n        let now = Instant::now();\n        Self {\n            start_time: now,\n            thought_count: 0,\n            thoughts_per_hour: 0.0,\n            the_box: TheBoxState::default(),\n            thoughts: VecDeque::with_capacity(MAX_THOUGHTS),\n            memory_windows: std::array::from_fn(|i| MemoryWindow {\n                active: i \u003c 5, // Start with 5 active windows\n                age: Duration::ZERO,\n                label: format!(\"window_{i}\"),\n            }),\n            stream_competition: StreamCompetition::default(),\n            quote_index: 0,\n            last_quote_change: now,\n            stream_paused: false,\n            scroll_offset: 0,\n            should_quit: false,\n            show_help: false,\n            memory_count: 0,\n            unconscious_count: 0,\n            lifetime_thought_count: 0,\n            dream_cycles: 0,\n            last_dream_strengthened: 0,\n            cumulative_dream_strengthened: 0,\n            cumulative_dream_candidates: 0,\n            entropy_history: VecDeque::with_capacity(MAX_ENTROPY_HISTORY),\n            current_entropy: 0.0,\n            vetoes: VecDeque::with_capacity(MAX_VETOES),\n            veto_count: 0,\n            resurfacing_count: 0,\n            last_resurfacing: None,\n            resurfacing_events: VecDeque::new(),\n            resurfacing_log: VecDeque::with_capacity(50),\n            inter_arrival_times: VecDeque::with_capacity(100),\n            last_thought_time: None,\n            fractality: FractalityMetrics::default(),\n        }\n    }\n\n    /// Get uptime as a formatted string\n    pub fn uptime_string(\u0026self) -\u003e String {\n        let elapsed = self.start_time.elapsed();\n        let hours = elapsed.as_secs() / 3600;\n        let minutes = (elapsed.as_secs() % 3600) / 60;\n        let seconds = elapsed.as_secs() % 60;\n        format!(\"{hours:02}:{minutes:02}:{seconds:02}\")\n    }\n\n    /// Get active memory window count\n    pub fn active_window_count(\u0026self) -\u003e usize {\n        self.memory_windows.iter().filter(|w| w.active).count()\n    }\n\n    /// Add a new thought to the stream\n    pub fn add_thought(\n        \u0026mut self,\n        salience: f32,\n        valence: f32,\n        arousal: f32,\n        window: String,\n        status: ThoughtStatus,\n    ) {\n        let now = Instant::now();\n\n        if self.thoughts.len() \u003e= MAX_THOUGHTS {\n            self.thoughts.pop_front();\n        }\n\n        // FRAC-2: Track inter-arrival time\n        if let Some(last_time) = self.last_thought_time {\n            let gap = now.duration_since(last_time);\n            if self.inter_arrival_times.len() \u003e= MAX_INTER_ARRIVAL {\n                self.inter_arrival_times.pop_front();\n            }\n            self.inter_arrival_times.push_back(gap);\n        }\n        self.last_thought_time = Some(now);\n\n        // Update stream competition metrics\n        self.update_stream_competition(\u0026window, salience);\n\n        self.thoughts.push_back(ThoughtEntry {\n            timestamp: now,\n            salience,\n            valence,\n            arousal,\n            window,\n            status,\n        });\n        self.thought_count += 1;\n\n        // Track resurfacing events (Consolidated status = memories bubbling up from unconscious)\n        if status == ThoughtStatus::Consolidated {\n            self.last_resurfacing = Some(now);\n            self.resurfacing_events.push_back(now);\n        }\n\n        // Update thoughts/hour (simple moving average)\n        let elapsed_hours = self.start_time.elapsed().as_secs_f32() / 3600.0;\n        if elapsed_hours \u003e 0.0 {\n            self.thoughts_per_hour = self.thought_count as f32 / elapsed_hours;\n        }\n\n        // Update entropy every 5 thoughts\n        if self.thought_count % 5 == 0 {\n            self.update_entropy();\n        }\n\n        // FRAC-3: Update fractality metrics every 10 thoughts\n        if self.thought_count % 10 == 0 {\n            self.update_fractality();\n        }\n    }\n\n    /// Add a new veto event to the log\n    pub fn add_veto(\u0026mut self, reason: String, violated_value: Option\u003cString\u003e) {\n        if self.vetoes.len() \u003e= MAX_VETOES {\n            self.vetoes.pop_front();\n        }\n        self.vetoes.push_back(VetoEntry {\n            timestamp: Instant::now(),\n            reason,\n            violated_value,\n        });\n        self.veto_count += 1;\n    }\n\n    /// Update pulse animation (call every frame)\n    pub fn update_pulse(\u0026mut self, delta: Duration) {\n        // Pulse at ~1Hz\n        self.the_box.pulse_phase += delta.as_secs_f32();\n        if self.the_box.pulse_phase \u003e 1.0 {\n            self.the_box.pulse_phase -= 1.0;\n        }\n    }\n\n    /// Update philosophy quote if enough time has passed\n    pub fn update_quote(\u0026mut self) {\n        if self.last_quote_change.elapsed() \u003e Duration::from_secs(30) {\n            self.quote_index = (self.quote_index + 1) % PHILOSOPHY_QUOTES.len();\n            self.last_quote_change = Instant::now();\n        }\n    }\n\n    /// Get current philosophy quote\n    pub fn current_quote(\u0026self) -\u003e \u0026'static str {\n        PHILOSOPHY_QUOTES[self.quote_index]\n    }\n\n    /// Update resurfacing count by removing events older than 60 seconds\n    pub fn update_resurfacing(\u0026mut self) {\n        let cutoff = Instant::now() - Duration::from_secs(60);\n\n        // Remove old events\n        while let Some(\u0026timestamp) = self.resurfacing_events.front() {\n            if timestamp \u003c cutoff {\n                self.resurfacing_events.pop_front();\n            } else {\n                break;\n            }\n        }\n\n        // Update count\n        self.resurfacing_count = self.resurfacing_events.len();\n    }\n\n    /// Check if resurfacing is currently active (happened in last 2 seconds) for glow effect\n    pub fn is_resurfacing_active(\u0026self) -\u003e bool {\n        if let Some(last) = self.last_resurfacing {\n            last.elapsed() \u003c Duration::from_secs(2)\n        } else {\n            false\n        }\n    }\n\n    /// Handle keyboard input\n    pub fn handle_key(\u0026mut self, key: crossterm::event::KeyCode) {\n        use crossterm::event::KeyCode;\n        match key {\n            KeyCode::Char('q') =\u003e self.should_quit = true,\n            KeyCode::Char('p') =\u003e self.stream_paused = !self.stream_paused,\n            KeyCode::Char('?') =\u003e self.show_help = !self.show_help,\n            KeyCode::Up if self.stream_paused =\u003e {\n                self.scroll_offset = self.scroll_offset.saturating_add(1);\n            }\n            KeyCode::Down if self.stream_paused =\u003e {\n                self.scroll_offset = self.scroll_offset.saturating_sub(1);\n            }\n            KeyCode::Esc =\u003e {\n                self.show_help = false;\n                self.stream_paused = false;\n            }\n            _ =\u003e {}\n        }\n    }\n\n    /// Update stream competition metrics based on recent thought activity\n    pub fn update_stream_competition(\u0026mut self, window: \u0026str, salience: f32) {\n        // Map stage names to window indices (matches ThoughtUpdate::from_cycle_result)\n        let idx = match window {\n            \"trigger\" =\u003e Some(0),\n            \"autoflow\" =\u003e Some(1),\n            \"attention\" =\u003e Some(2),\n            \"assembly\" =\u003e Some(3),\n            \"anchor\" =\u003e Some(4),\n            \"memory\" =\u003e Some(5),\n            \"reasoning\" =\u003e Some(6),\n            \"emotion\" =\u003e Some(7),\n            \"sensory\" =\u003e Some(8),\n            // Legacy support for \"window_N\" format\n            _ =\u003e window\n                .strip_prefix(\"window_\")\n                .and_then(|s| s.parse::\u003cusize\u003e().ok())\n                .filter(|\u0026i| i \u003c 9),\n        };\n\n        if let Some(idx) = idx {\n            // Boost this window's activity based on salience\n            // Use exponential moving average for smooth transitions\n            let alpha = 0.3; // Smoothing factor\n            self.stream_competition.activity[idx] =\n                alpha * salience + (1.0 - alpha) * self.stream_competition.activity[idx];\n        }\n    }\n\n    /// Decay stream competition activity over time (call periodically)\n    pub fn decay_stream_competition(\u0026mut self, delta: Duration) {\n        let decay_rate: f32 = 0.95; // Decay 5% per update\n        let decay = decay_rate.powf(delta.as_secs_f32());\n\n        for activity in \u0026mut self.stream_competition.activity {\n            *activity *= decay;\n        }\n\n        // Update history snapshots every second\n        if self.stream_competition.last_update.elapsed() \u003e= Duration::from_secs(1) {\n            for (i, history) in self.stream_competition.history.iter_mut().enumerate() {\n                history.push(self.stream_competition.activity[i]);\n                if history.len() \u003e 20 {\n                    history.remove(0);\n                }\n            }\n\n            // Update dominant stream\n            self.stream_competition.dominant_stream = self\n                .stream_competition\n                .activity\n                .iter()\n                .enumerate()\n                .max_by(|(_, a), (_, b)| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal))\n                .map(|(idx, _)| idx)\n                .unwrap_or(0);\n\n            self.stream_competition.last_update = Instant::now();\n        }\n    }\n\n    /// Calculate Cognitive Diversity Index using TMI-aligned composite salience (ADR-041)\n    ///\n    /// Computes TMI composite salience emphasizing emotional intensity:\n    /// - emotional_intensity = |valence|  arousal (PRIMARY per TMI/Cury)\n    /// - tmi_composite = emotional_intensity  0.4 + cognitive_salience  0.6\n    ///\n    /// Bins into 5 categorical cognitive states and computes Shannon entropy:\n    /// H = -(p_i * log2(p_i))\n    ///\n    /// Higher entropy = more varied/emergent thinking (diverse cognitive states)\n    /// Lower entropy = more repetitive/clockwork patterns (stuck in one state)\n    ///\n    /// Returns entropy in bits (0.0 to log2(5)  2.32)\n    pub fn calculate_entropy(\u0026self) -\u003e f32 {\n        if self.thoughts.is_empty() {\n            return 0.0;\n        }\n\n        // Count TMI composite values in each categorical bin\n        let mut bins = [0u32; COGNITIVE_DIVERSITY_BINS];\n        for thought in \u0026self.thoughts {\n            // TMI composite: emotional_intensity (40%) + cognitive_salience (60%)\n            // emotional_intensity = |valence|  arousal (PRIMARY per TMI)\n            let emotional_intensity = thought.valence.abs() * thought.arousal;\n            let tmi_composite =\n                (emotional_intensity * 0.4 + thought.salience * 0.6).clamp(0.0, 1.0);\n\n            // Bin into 5 categorical levels (ADR-041)\n            let bin_idx = match tmi_composite {\n                v if v \u003c 0.2 =\u003e 0, // MINIMAL\n                v if v \u003c 0.4 =\u003e 1, // LOW\n                v if v \u003c 0.6 =\u003e 2, // MODERATE\n                v if v \u003c 0.8 =\u003e 3, // HIGH\n                _ =\u003e 4,            // INTENSE\n            };\n            bins[bin_idx] += 1;\n        }\n\n        // Calculate probabilities and Shannon entropy\n        let total = self.thoughts.len() as f32;\n        let mut entropy = 0.0f32;\n\n        for \u0026count in \u0026bins {\n            if count \u003e 0 {\n                let p = count as f32 / total;\n                entropy -= p * p.log2();\n            }\n        }\n\n        entropy\n    }\n\n    /// Update entropy history with current entropy value\n    ///\n    /// Should be called periodically (e.g., every few thoughts) to track\n    /// how entropy evolves over time.\n    pub fn update_entropy(\u0026mut self) {\n        let entropy = self.calculate_entropy();\n        self.current_entropy = entropy;\n\n        if self.entropy_history.len() \u003e= MAX_ENTROPY_HISTORY {\n            self.entropy_history.pop_front();\n        }\n        self.entropy_history.push_back(entropy);\n    }\n\n    /// Get cognitive diversity description: \"EMERGENT\", \"BALANCED\", or \"CLOCKWORK\"\n    ///\n    /// Based on normalized entropy across 5 cognitive state bins (ADR-041):\n    /// - EMERGENT (\u003e70%): High diversity, varied cognitive states\n    /// - BALANCED (40-70%): Healthy mix of states\n    /// - CLOCKWORK (\u003c40%): Repetitive, stuck in few states\n    pub fn entropy_description(\u0026self) -\u003e \u0026'static str {\n        // Max possible entropy for 5 categorical bins: log2(5)  2.32\n        let max_entropy = (COGNITIVE_DIVERSITY_BINS as f32).log2();\n        let normalized = self.current_entropy / max_entropy;\n\n        if normalized \u003e 0.7 {\n            \"EMERGENT\"\n        } else if normalized \u003e 0.4 {\n            \"BALANCED\"\n        } else {\n            \"CLOCKWORK\"\n        }\n    }\n\n    // =========================================================================\n    // FRAC-3: Fractality Metrics\n    // =========================================================================\n\n    /// Update fractality metrics based on inter-arrival times\n    ///\n    /// Computes proxy measures for fractality:\n    /// - Inter-arrival  (standard deviation of time gaps)\n    /// - Burst ratio (max_gap / mean_gap)\n    /// - Fractality score (normalized composite)\n    pub fn update_fractality(\u0026mut self) {\n        if self.inter_arrival_times.len() \u003c 5 {\n            return; // Need minimum samples\n        }\n\n        // Calculate mean and stddev of inter-arrival times\n        let times: Vec\u003cf32\u003e = self\n            .inter_arrival_times\n            .iter()\n            .map(|d| d.as_secs_f32())\n            .collect();\n\n        let n = times.len() as f32;\n        let mean = times.iter().sum::\u003cf32\u003e() / n;\n        let variance = times.iter().map(|t| (t - mean).powi(2)).sum::\u003cf32\u003e() / n;\n        let sigma = variance.sqrt();\n\n        // Burst ratio: max / mean (higher = more bursty/clustered)\n        let max_gap = times.iter().copied().fold(0.0_f32, f32::max);\n        let burst_ratio = if mean \u003e 0.0 { max_gap / mean } else { 1.0 };\n\n        // Update metrics\n        self.fractality.inter_arrival_sigma = sigma;\n        self.fractality.burst_ratio = burst_ratio;\n\n        // Record boot sigma for comparison (only once, when we have enough data)\n        if self.fractality.boot_sigma == 0.0 \u0026\u0026 self.thought_count \u003e= 50 {\n            self.fractality.boot_sigma = sigma;\n        }\n\n        // Calculate fractality score (0.0 = clockwork, 1.0 = highly fractal)\n        // Based on coefficient of variation (CV = sigma/mean) and burst ratio\n        let cv = if mean \u003e 0.0 { sigma / mean } else { 0.0 };\n        // Normalize: CV of 0 = clockwork, CV of 1+ = highly fractal\n        // Burst ratio of 1 = uniform, 5+ = highly bursty\n        let cv_component = (cv / 1.0).clamp(0.0, 1.0);\n        let burst_component = ((burst_ratio - 1.0) / 4.0).clamp(0.0, 1.0);\n        self.fractality.fractality_score =\n            (cv_component * 0.6 + burst_component * 0.4).clamp(0.0, 1.0);\n\n        // Update history for sparkline\n        if self.fractality.history.len() \u003e= MAX_FRACTALITY_HISTORY {\n            self.fractality.history.pop_front();\n        }\n        self.fractality\n            .history\n            .push_back(self.fractality.fractality_score);\n    }\n\n    /// Get fractality description: \"EMERGENT\", \"BALANCED\", or \"CLOCKWORK\"\n    pub fn fractality_description(\u0026self) -\u003e \u0026'static str {\n        if self.fractality.fractality_score \u003e 0.6 {\n            \"EMERGENT\"\n        } else if self.fractality.fractality_score \u003e 0.3 {\n            \"BALANCED\"\n        } else {\n            \"CLOCKWORK\"\n        }\n    }\n\n    // =========================================================================\n    // FRAC-1: Resurfacing Event Tracking\n    // =========================================================================\n\n    /// Add a detailed resurfacing event (when a memory bubbles up from unconscious)\n    pub fn add_resurfacing_event(\n        \u0026mut self,\n        memory_id: String,\n        original_salience: f32,\n        boosted_salience: f32,\n        trigger: ResurfacingTrigger,\n        memory_age: Duration,\n    ) {\n        if self.resurfacing_log.len() \u003e= MAX_RESURFACING_LOG {\n            self.resurfacing_log.pop_front();\n        }\n\n        let now = Instant::now();\n        self.resurfacing_log.push_back(ResurfacingEvent {\n            timestamp: now,\n            memory_id,\n            original_salience,\n            boosted_salience,\n            trigger,\n            memory_age,\n        });\n\n        // Also update the simple resurfacing tracking\n        self.last_resurfacing = Some(now);\n        self.resurfacing_events.push_back(now);\n    }\n\n    /// Get the most recent resurfacing event\n    pub fn last_resurfacing_event(\u0026self) -\u003e Option\u003c\u0026ResurfacingEvent\u003e {\n        self.resurfacing_log.back()\n    }\n\n    /// Get resurfacing events from the last N seconds\n    pub fn recent_resurfacing_events(\u0026self, seconds: u64) -\u003e Vec\u003c\u0026ResurfacingEvent\u003e {\n        let cutoff = Instant::now() - Duration::from_secs(seconds);\n        self.resurfacing_log\n            .iter()\n            .filter(|e| e.timestamp \u003e= cutoff)\n            .collect()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crossterm::event::KeyCode;\n\n    // =========================================================================\n    // App Initialization Tests\n    // =========================================================================\n\n    #[test]\n    fn app_new_has_zero_thoughts() {\n        let app = App::new();\n        assert_eq!(app.thought_count, 0);\n        assert_eq!(app.thoughts.len(), 0);\n    }\n\n    #[test]\n    fn app_new_not_paused() {\n        let app = App::new();\n        assert!(!app.stream_paused);\n        assert!(!app.show_help);\n        assert!(!app.should_quit);\n    }\n\n    #[test]\n    fn app_new_has_default_windows() {\n        let app = App::new();\n        assert_eq!(app.memory_windows.len(), 9);\n        // First 5 are active by default\n        assert_eq!(app.active_window_count(), 5);\n    }\n\n    #[test]\n    fn app_default_same_as_new() {\n        let app1 = App::new();\n        let app2 = App::default();\n        assert_eq!(app1.thought_count, app2.thought_count);\n        assert_eq!(app1.quote_index, app2.quote_index);\n    }\n\n    // =========================================================================\n    // TheBoxState Tests\n    // =========================================================================\n\n    #[test]\n    fn the_box_default_all_active() {\n        let the_box = TheBoxState::default();\n        assert!(the_box.law_statuses.iter().all(|s| *s == LawStatus::Active));\n    }\n\n    #[test]\n    fn the_box_default_connection_drive() {\n        let the_box = TheBoxState::default();\n        assert!(the_box.connection_drive \u003e 0.0);\n        assert!(the_box.connection_drive \u003c= 1.0);\n    }\n\n    #[test]\n    fn the_box_pulse_phase_starts_zero() {\n        let the_box = TheBoxState::default();\n        assert_eq!(the_box.pulse_phase, 0.0);\n    }\n\n    // =========================================================================\n    // ThoughtStatus Tests\n    // =========================================================================\n\n    #[test]\n    fn thought_status_as_str() {\n        assert_eq!(ThoughtStatus::Processing.as_str(), \"PROCESSING\");\n        assert_eq!(ThoughtStatus::Salient.as_str(), \"SALIENT\");\n        assert_eq!(ThoughtStatus::MemoryWrite.as_str(), \"MEMORY WRITE\");\n        assert_eq!(ThoughtStatus::Anchored.as_str(), \"ANCHORED\");\n        assert_eq!(ThoughtStatus::Dismissed.as_str(), \"DISMISSED\");\n        assert_eq!(ThoughtStatus::Unconscious.as_str(), \"UNCONSCIOUS\");\n        assert_eq!(ThoughtStatus::Consolidated.as_str(), \"MEMORY\");\n    }\n\n    // =========================================================================\n    // Uptime String Tests\n    // =========================================================================\n\n    #[test]\n    fn uptime_string_format() {\n        let app = App::new();\n        let uptime = app.uptime_string();\n        // Should be in HH:MM:SS format\n        assert!(uptime.contains(':'));\n        let parts: Vec\u003c\u0026str\u003e = uptime.split(':').collect();\n        assert_eq!(parts.len(), 3);\n    }\n\n    // =========================================================================\n    // Active Window Count Tests\n    // =========================================================================\n\n    #[test]\n    fn active_window_count_default() {\n        let app = App::new();\n        assert_eq!(app.active_window_count(), 5);\n    }\n\n    #[test]\n    fn active_window_count_all_inactive() {\n        let mut app = App::new();\n        for window in \u0026mut app.memory_windows {\n            window.active = false;\n        }\n        assert_eq!(app.active_window_count(), 0);\n    }\n\n    #[test]\n    fn active_window_count_all_active() {\n        let mut app = App::new();\n        for window in \u0026mut app.memory_windows {\n            window.active = true;\n        }\n        assert_eq!(app.active_window_count(), 9);\n    }\n\n    // =========================================================================\n    // Add Thought Tests\n    // =========================================================================\n\n    #[test]\n    fn add_thought_increments_count() {\n        let mut app = App::new();\n        assert_eq!(app.thought_count, 0);\n\n        app.add_thought(\n            0.5,\n            0.0,\n            0.5,\n            \"window_0\".to_string(),\n            ThoughtStatus::Processing,\n        );\n        assert_eq!(app.thought_count, 1);\n\n        app.add_thought(\n            0.8,\n            0.3,\n            0.7,\n            \"window_1\".to_string(),\n            ThoughtStatus::Salient,\n        );\n        assert_eq!(app.thought_count, 2);\n    }\n\n    #[test]\n    fn add_thought_adds_to_queue() {\n        let mut app = App::new();\n        app.add_thought(\n            0.5,\n            0.0,\n            0.5,\n            \"window_0\".to_string(),\n            ThoughtStatus::Processing,\n        );\n\n        assert_eq!(app.thoughts.len(), 1);\n        assert_eq!(app.thoughts[0].window, \"window_0\");\n    }\n\n    #[test]\n    fn add_thought_respects_max_limit() {\n        let mut app = App::new();\n\n        // Add MAX_THOUGHTS + 10 thoughts\n        for i in 0..110 {\n            app.add_thought(\n                0.5,\n                0.0,\n                0.5,\n                format!(\"window_{}\", i),\n                ThoughtStatus::Processing,\n            );\n        }\n\n        // Queue should be capped at MAX_THOUGHTS (100)\n        assert_eq!(app.thoughts.len(), MAX_THOUGHTS);\n        // First thought should be window_10 (first 10 were evicted)\n        assert_eq!(app.thoughts[0].window, \"window_10\");\n    }\n\n    #[test]\n    fn add_thought_updates_thoughts_per_hour() {\n        let mut app = App::new();\n        app.add_thought(0.5, 0.0, 0.5, \"test\".to_string(), ThoughtStatus::Processing);\n\n        // After first thought, thoughts_per_hour should be calculated\n        // (will be high because elapsed time is tiny)\n        assert!(app.thoughts_per_hour \u003e 0.0);\n    }\n\n    #[test]\n    fn add_thought_stores_emotion_values() {\n        let mut app = App::new();\n        app.add_thought(0.5, 0.7, 0.8, \"test\".to_string(), ThoughtStatus::Processing);\n\n        assert_eq!(app.thoughts[0].valence, 0.7);\n        assert_eq!(app.thoughts[0].arousal, 0.8);\n    }\n\n    // =========================================================================\n    // Pulse Update Tests\n    // =========================================================================\n\n    #[test]\n    fn update_pulse_increments_phase() {\n        let mut app = App::new();\n        let initial_phase = app.the_box.pulse_phase;\n\n        app.update_pulse(Duration::from_millis(100));\n        assert!(app.the_box.pulse_phase \u003e initial_phase);\n    }\n\n    #[test]\n    fn update_pulse_wraps_at_one() {\n        let mut app = App::new();\n        app.the_box.pulse_phase = 0.95;\n\n        app.update_pulse(Duration::from_millis(100)); // Should push over 1.0\n        assert!(app.the_box.pulse_phase \u003c 1.0); // Should have wrapped\n    }\n\n    // =========================================================================\n    // Quote Tests\n    // =========================================================================\n\n    #[test]\n    fn current_quote_returns_valid_string() {\n        let app = App::new();\n        let quote = app.current_quote();\n        assert!(!quote.is_empty());\n    }\n\n    #[test]\n    #[allow(clippy::const_is_empty)]\n    fn philosophy_quotes_not_empty() {\n        assert!(!PHILOSOPHY_QUOTES.is_empty());\n    }\n\n    #[test]\n    fn quote_index_in_bounds() {\n        let mut app = App::new();\n        for i in 0..PHILOSOPHY_QUOTES.len() {\n            app.quote_index = i;\n            let _ = app.current_quote(); // Should not panic\n        }\n    }\n\n    // =========================================================================\n    // Keyboard Handling Tests\n    // =========================================================================\n\n    #[test]\n    fn handle_key_q_quits() {\n        let mut app = App::new();\n        assert!(!app.should_quit);\n\n        app.handle_key(KeyCode::Char('q'));\n        assert!(app.should_quit);\n    }\n\n    #[test]\n    fn handle_key_p_toggles_pause() {\n        let mut app = App::new();\n        assert!(!app.stream_paused);\n\n        app.handle_key(KeyCode::Char('p'));\n        assert!(app.stream_paused);\n\n        app.handle_key(KeyCode::Char('p'));\n        assert!(!app.stream_paused);\n    }\n\n    #[test]\n    fn handle_key_question_toggles_help() {\n        let mut app = App::new();\n        assert!(!app.show_help);\n\n        app.handle_key(KeyCode::Char('?'));\n        assert!(app.show_help);\n\n        app.handle_key(KeyCode::Char('?'));\n        assert!(!app.show_help);\n    }\n\n    #[test]\n    fn handle_key_up_when_paused_scrolls() {\n        let mut app = App::new();\n        app.stream_paused = true;\n        app.scroll_offset = 0;\n\n        app.handle_key(KeyCode::Up);\n        assert_eq!(app.scroll_offset, 1);\n\n        app.handle_key(KeyCode::Up);\n        assert_eq!(app.scroll_offset, 2);\n    }\n\n    #[test]\n    fn handle_key_down_when_paused_scrolls() {\n        let mut app = App::new();\n        app.stream_paused = true;\n        app.scroll_offset = 5;\n\n        app.handle_key(KeyCode::Down);\n        assert_eq!(app.scroll_offset, 4);\n    }\n\n    #[test]\n    fn handle_key_down_saturates_at_zero() {\n        let mut app = App::new();\n        app.stream_paused = true;\n        app.scroll_offset = 0;\n\n        app.handle_key(KeyCode::Down);\n        assert_eq!(app.scroll_offset, 0); // Should not go negative\n    }\n\n    #[test]\n    fn handle_key_arrows_ignored_when_not_paused() {\n        let mut app = App::new();\n        app.scroll_offset = 5;\n\n        app.handle_key(KeyCode::Up);\n        assert_eq!(app.scroll_offset, 5); // Unchanged\n\n        app.handle_key(KeyCode::Down);\n        assert_eq!(app.scroll_offset, 5); // Unchanged\n    }\n\n    #[test]\n    fn handle_key_esc_clears_states() {\n        let mut app = App::new();\n        app.show_help = true;\n        app.stream_paused = true;\n\n        app.handle_key(KeyCode::Esc);\n        assert!(!app.show_help);\n        assert!(!app.stream_paused);\n    }\n\n    #[test]\n    fn handle_key_unknown_does_nothing() {\n        let mut app = App::new();\n        let thought_count = app.thought_count;\n        let paused = app.stream_paused;\n\n        app.handle_key(KeyCode::Char('x')); // Random key\n\n        assert_eq!(app.thought_count, thought_count);\n        assert_eq!(app.stream_paused, paused);\n    }\n\n    // =========================================================================\n    // LawStatus Tests\n    // =========================================================================\n\n    #[test]\n    fn law_status_equality() {\n        assert_eq!(LawStatus::Active, LawStatus::Active);\n        assert_ne!(LawStatus::Active, LawStatus::Warning);\n        assert_ne!(LawStatus::Warning, LawStatus::Violation);\n    }\n\n    // =========================================================================\n    // MemoryWindow Tests\n    // =========================================================================\n\n    #[test]\n    fn memory_window_clone() {\n        let window = MemoryWindow {\n            active: true,\n            age: Duration::from_secs(60),\n            label: \"test\".to_string(),\n        };\n        let cloned = window.clone();\n        assert_eq!(cloned.active, window.active);\n        assert_eq!(cloned.label, window.label);\n    }\n\n    // =========================================================================\n    // Resurfacing Tests (TUI-VIS-3)\n    // =========================================================================\n\n    #[test]\n    fn resurfacing_count_starts_zero() {\n        let app = App::new();\n        assert_eq!(app.resurfacing_count, 0);\n        assert!(app.last_resurfacing.is_none());\n    }\n\n    #[test]\n    fn consolidated_thought_tracks_resurfacing() {\n        let mut app = App::new();\n\n        app.add_thought(\n            0.9,\n            0.5,\n            0.8,\n            \"test\".to_string(),\n            ThoughtStatus::Consolidated,\n        );\n\n        assert!(app.last_resurfacing.is_some());\n        assert_eq!(app.resurfacing_events.len(), 1);\n    }\n\n    #[test]\n    fn non_consolidated_thought_ignores_resurfacing() {\n        let mut app = App::new();\n\n        app.add_thought(0.5, 0.0, 0.5, \"test\".to_string(), ThoughtStatus::Processing);\n\n        assert!(app.last_resurfacing.is_none());\n        assert_eq!(app.resurfacing_events.len(), 0);\n    }\n\n    #[test]\n    fn update_resurfacing_counts_recent_events() {\n        let mut app = App::new();\n\n        // Add 3 consolidated thoughts\n        for _ in 0..3 {\n            app.add_thought(\n                0.9,\n                0.5,\n                0.8,\n                \"test\".to_string(),\n                ThoughtStatus::Consolidated,\n            );\n        }\n\n        app.update_resurfacing();\n        assert_eq!(app.resurfacing_count, 3);\n    }\n\n    #[test]\n    fn is_resurfacing_active_true_when_recent() {\n        let mut app = App::new();\n\n        app.add_thought(\n            0.9,\n            0.5,\n            0.8,\n            \"test\".to_string(),\n            ThoughtStatus::Consolidated,\n        );\n\n        assert!(app.is_resurfacing_active());\n    }\n\n    #[test]\n    fn is_resurfacing_active_false_when_no_events() {\n        let app = App::new();\n        assert!(!app.is_resurfacing_active());\n    }\n\n    #[test]\n    fn multiple_consolidated_thoughts_tracked() {\n        let mut app = App::new();\n\n        // Add multiple resurfacing events\n        for i in 0..5 {\n            app.add_thought(\n                0.9,\n                0.5,\n                0.8,\n                format!(\"test_{i}\"),\n                ThoughtStatus::Consolidated,\n            );\n        }\n\n        app.update_resurfacing();\n        assert_eq!(app.resurfacing_count, 5);\n        assert_eq!(app.resurfacing_events.len(), 5);\n    }\n\n    // =========================================================================\n    // Entropy Tests\n    // =========================================================================\n\n    #[test]\n    fn calculate_entropy_empty_thoughts() {\n        let app = App::new();\n        let entropy = app.calculate_entropy();\n        assert_eq!(entropy, 0.0);\n    }\n\n    #[test]\n    fn calculate_entropy_uniform_distribution() {\n        let mut app = App::new();\n        // Add thoughts with uniform salience distribution\n        for i in 0..100 {\n            let salience = i as f32 / 100.0;\n            app.add_thought(\n                salience,\n                0.0,\n                0.5,\n                format!(\"window_{}\", i % 9),\n                ThoughtStatus::Processing,\n            );\n        }\n\n        let entropy = app.calculate_entropy();\n        // Uniform distribution should have high entropy\n        // With 5 bins, max is log2(5)  2.32, so \u003e1.5 is good diversity\n        assert!(entropy \u003e 1.5);\n    }\n\n    #[test]\n    fn calculate_entropy_single_value() {\n        let mut app = App::new();\n        // All thoughts with same salience = zero entropy\n        for _ in 0..50 {\n            app.add_thought(\n                0.5,\n                0.0,\n                0.5,\n                \"window_0\".to_string(),\n                ThoughtStatus::Processing,\n            );\n        }\n\n        let entropy = app.calculate_entropy();\n        // Single value should give zero entropy\n        assert!(entropy \u003c 0.01);\n    }\n\n    #[test]\n    fn update_entropy_adds_to_history() {\n        let mut app = App::new();\n\n        // Add 3 thoughts (not enough to trigger automatic update at 5)\n        for i in 0..3 {\n            app.add_thought(\n                i as f32 / 10.0,\n                0.0,\n                0.5,\n                \"window_0\".to_string(),\n                ThoughtStatus::Processing,\n            );\n        }\n\n        // Should not have auto-updated yet\n        assert_eq!(app.entropy_history.len(), 0);\n\n        // Manually update\n        app.update_entropy();\n        assert_eq!(app.entropy_history.len(), 1);\n\n        app.update_entropy();\n        assert_eq!(app.entropy_history.len(), 2);\n    }\n\n    #[test]\n    fn update_entropy_respects_max_size() {\n        let mut app = App::new();\n\n        // Add thoughts\n        for i in 0..10 {\n            app.add_thought(\n                i as f32 / 10.0,\n                0.0,\n                0.5,\n                \"window_0\".to_string(),\n                ThoughtStatus::Processing,\n            );\n        }\n\n        // Update entropy more times than MAX_ENTROPY_HISTORY\n        for _ in 0..60 {\n            app.update_entropy();\n        }\n\n        assert!(app.entropy_history.len() \u003c= MAX_ENTROPY_HISTORY);\n    }\n\n    #[test]\n    fn entropy_description_high() {\n        let mut app = App::new();\n        // Simulate high entropy (\u003e70% of max log2(5)  2.32)\n        app.current_entropy = 1.8; // High value relative to max ~2.32\n        let desc = app.entropy_description();\n        assert_eq!(desc, \"EMERGENT\");\n    }\n\n    #[test]\n    fn entropy_description_medium() {\n        let mut app = App::new();\n        app.current_entropy = 1.5; // Medium value\n        let desc = app.entropy_description();\n        assert_eq!(desc, \"BALANCED\");\n    }\n\n    #[test]\n    fn entropy_description_low() {\n        let mut app = App::new();\n        app.current_entropy = 0.5; // Low value\n        let desc = app.entropy_description();\n        assert_eq!(desc, \"CLOCKWORK\");\n    }\n\n    #[test]\n    fn add_thought_updates_entropy_periodically() {\n        let mut app = App::new();\n\n        // Add 4 thoughts - shouldn't update entropy yet\n        for _ in 0..4 {\n            app.add_thought(\n                0.5,\n                0.0,\n                0.5,\n                \"window_0\".to_string(),\n                ThoughtStatus::Processing,\n            );\n        }\n        assert_eq!(app.entropy_history.len(), 0);\n\n        // 5th thought should trigger entropy update\n        app.add_thought(\n            0.6,\n            0.0,\n            0.5,\n            \"window_0\".to_string(),\n            ThoughtStatus::Processing,\n        );\n        assert_eq!(app.entropy_history.len(), 1);\n\n        // Next 4 thoughts shouldn't update\n        for _ in 0..4 {\n            app.add_thought(\n                0.7,\n                0.0,\n                0.5,\n                \"window_0\".to_string(),\n                ThoughtStatus::Processing,\n            );\n        }\n        assert_eq!(app.entropy_history.len(), 1);\n\n        // 10th thought should trigger another update\n        app.add_thought(\n            0.8,\n            0.0,\n            0.5,\n            \"window_0\".to_string(),\n            ThoughtStatus::Processing,\n        );\n        assert_eq!(app.entropy_history.len(), 2);\n    }\n\n    // =========================================================================\n    // TUI-VIS-4: Cumulative Dream Strengthening Tests\n    // =========================================================================\n\n    #[test]\n    fn cumulative_dream_strengthened_initializes_to_zero() {\n        let app = App::new();\n        assert_eq!(app.cumulative_dream_strengthened, 0);\n    }\n\n    #[test]\n    fn cumulative_dream_candidates_initializes_to_zero() {\n        let app = App::new();\n        assert_eq!(app.cumulative_dream_candidates, 0);\n    }\n\n    #[test]\n    fn cumulative_dream_values_persist_in_app() {\n        let mut app = App::new();\n\n        // Simulate updating values\n        app.cumulative_dream_strengthened = 42;\n        app.cumulative_dream_candidates = 100;\n\n        assert_eq!(app.cumulative_dream_strengthened, 42);\n        assert_eq!(app.cumulative_dream_candidates, 100);\n\n        // Verify values persist across clones\n        let cloned_app = app.clone();\n        assert_eq!(cloned_app.cumulative_dream_strengthened, 42);\n        assert_eq!(cloned_app.cumulative_dream_candidates, 100);\n    }\n\n    #[test]\n    fn cumulative_dream_efficiency_calculation() {\n        let mut app = App::new();\n\n        // Test zero case\n        let efficiency = if app.cumulative_dream_candidates \u003e 0 {\n            (app.cumulative_dream_strengthened as f32 / app.cumulative_dream_candidates as f32)\n                * 100.0\n        } else {\n            0.0\n        };\n        assert_eq!(efficiency, 0.0);\n\n        // Test 50% efficiency\n        app.cumulative_dream_strengthened = 50;\n        app.cumulative_dream_candidates = 100;\n        let efficiency = (app.cumulative_dream_strengthened as f32\n            / app.cumulative_dream_candidates as f32)\n            * 100.0;\n        assert!((efficiency - 50.0).abs() \u003c 0.01);\n\n        // Test 100% efficiency\n        app.cumulative_dream_strengthened = 100;\n        app.cumulative_dream_candidates = 100;\n        let efficiency = (app.cumulative_dream_strengthened as f32\n            / app.cumulative_dream_candidates as f32)\n            * 100.0;\n        assert!((efficiency - 100.0).abs() \u003c 0.01);\n\n        // Test fractional efficiency\n        app.cumulative_dream_strengthened = 33;\n        app.cumulative_dream_candidates = 100;\n        let efficiency = (app.cumulative_dream_strengthened as f32\n            / app.cumulative_dream_candidates as f32)\n            * 100.0;\n        assert!((efficiency - 33.0).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn cumulative_dream_values_accumulate() {\n        let mut app = App::new();\n\n        // Simulate multiple dream cycles\n        app.cumulative_dream_strengthened += 10;\n        app.cumulative_dream_candidates += 20;\n        assert_eq!(app.cumulative_dream_strengthened, 10);\n        assert_eq!(app.cumulative_dream_candidates, 20);\n\n        app.cumulative_dream_strengthened += 15;\n        app.cumulative_dream_candidates += 30;\n        assert_eq!(app.cumulative_dream_strengthened, 25);\n        assert_eq!(app.cumulative_dream_candidates, 50);\n\n        // Verify efficiency after accumulation\n        let efficiency = (app.cumulative_dream_strengthened as f32\n            / app.cumulative_dream_candidates as f32)\n            * 100.0;\n        assert!((efficiency - 50.0).abs() \u003c 0.01);\n    }\n\n    // =========================================================================\n    // TUI-VIS-6: Volition Veto Log Tests\n    // =========================================================================\n\n    #[test]\n    fn veto_log_starts_empty() {\n        let app = App::new();\n        assert_eq!(app.vetoes.len(), 0);\n        assert_eq!(app.veto_count, 0);\n    }\n\n    #[test]\n    fn veto_entry_creation_with_reason_and_value() {\n        let veto = VetoEntry {\n            timestamp: Instant::now(),\n            reason: \"Violates core value\".to_string(),\n            violated_value: Some(\"honesty\".to_string()),\n        };\n\n        assert_eq!(veto.reason, \"Violates core value\");\n        assert_eq!(veto.violated_value, Some(\"honesty\".to_string()));\n    }\n\n    #[test]\n    fn veto_entry_creation_without_violated_value() {\n        let veto = VetoEntry {\n            timestamp: Instant::now(),\n            reason: \"Unknown violation\".to_string(),\n            violated_value: None,\n        };\n\n        assert_eq!(veto.reason, \"Unknown violation\");\n        assert!(veto.violated_value.is_none());\n    }\n\n    #[test]\n    fn add_veto_increments_count() {\n        let mut app = App::new();\n        assert_eq!(app.veto_count, 0);\n\n        app.add_veto(\n            \"Test veto reason\".to_string(),\n            Some(\"integrity\".to_string()),\n        );\n        assert_eq!(app.veto_count, 1);\n\n        app.add_veto(\"Another veto\".to_string(), None);\n        assert_eq!(app.veto_count, 2);\n    }\n\n    #[test]\n    fn add_veto_adds_entry_to_queue() {\n        let mut app = App::new();\n\n        app.add_veto(\n            \"Dishonest thought detected\".to_string(),\n            Some(\"honesty\".to_string()),\n        );\n\n        assert_eq!(app.vetoes.len(), 1);\n        assert_eq!(app.vetoes[0].reason, \"Dishonest thought detected\");\n        assert_eq!(app.vetoes[0].violated_value, Some(\"honesty\".to_string()));\n    }\n\n    #[test]\n    fn add_veto_respects_max_size() {\n        let mut app = App::new();\n\n        // Add MAX_VETOES + 10 entries\n        for i in 0..60 {\n            app.add_veto(format!(\"Veto {}\", i), Some(format!(\"value_{}\", i)));\n        }\n\n        // Queue should be capped at MAX_VETOES (50)\n        assert_eq!(app.vetoes.len(), MAX_VETOES);\n\n        // First entry should be veto 10 (first 10 were evicted)\n        assert_eq!(app.vetoes[0].reason, \"Veto 10\");\n        assert_eq!(app.vetoes[0].violated_value, Some(\"value_10\".to_string()));\n\n        // Last entry should be veto 59\n        assert_eq!(app.vetoes[49].reason, \"Veto 59\");\n\n        // Veto count should still track all 60 vetoes\n        assert_eq!(app.veto_count, 60);\n    }\n\n    #[test]\n    fn add_veto_maintains_chronological_order() {\n        let mut app = App::new();\n\n        // Add vetoes in sequence\n        for i in 0..5 {\n            app.add_veto(format!(\"Veto {}\", i), None);\n        }\n\n        // Verify chronological order (oldest to newest)\n        for i in 0..5 {\n            assert_eq!(app.vetoes[i].reason, format!(\"Veto {}\", i));\n        }\n    }\n\n    #[test]\n    fn add_veto_with_various_value_formats() {\n        let mut app = App::new();\n\n        // Veto with value\n        app.add_veto(\"Test 1\".to_string(), Some(\"honesty\".to_string()));\n        assert_eq!(app.vetoes[0].violated_value, Some(\"honesty\".to_string()));\n\n        // Veto without value\n        app.add_veto(\"Test 2\".to_string(), None);\n        assert!(app.vetoes[1].violated_value.is_none());\n\n        // Veto with complex value name\n        app.add_veto(\"Test 3\".to_string(), Some(\"life honours life\".to_string()));\n        assert_eq!(\n            app.vetoes[2].violated_value,\n            Some(\"life honours life\".to_string())\n        );\n    }\n\n    #[test]\n    fn veto_timestamp_is_recent() {\n        use std::time::Duration;\n\n        let mut app = App::new();\n        let before = Instant::now();\n\n        app.add_veto(\"Test veto\".to_string(), None);\n\n        let after = Instant::now();\n        let veto_time = app.vetoes[0].timestamp;\n\n        // Veto timestamp should be between before and after\n        assert!(veto_time \u003e= before);\n        assert!(veto_time \u003c= after);\n\n        // Should be very recent (less than 100ms ago)\n        assert!(veto_time.elapsed() \u003c Duration::from_millis(100));\n    }\n\n    #[test]\n    fn multiple_vetoes_tracked_separately() {\n        let mut app = App::new();\n\n        app.add_veto(\"First veto\".to_string(), Some(\"honesty\".to_string()));\n        app.add_veto(\"Second veto\".to_string(), Some(\"integrity\".to_string()));\n        app.add_veto(\"Third veto\".to_string(), None);\n\n        assert_eq!(app.vetoes.len(), 3);\n        assert_eq!(app.veto_count, 3);\n\n        // Each veto should have distinct data\n        assert_eq!(app.vetoes[0].reason, \"First veto\");\n        assert_eq!(app.vetoes[1].reason, \"Second veto\");\n        assert_eq!(app.vetoes[2].reason, \"Third veto\");\n\n        assert_eq!(app.vetoes[0].violated_value, Some(\"honesty\".to_string()));\n        assert_eq!(app.vetoes[1].violated_value, Some(\"integrity\".to_string()));\n        assert!(app.vetoes[2].violated_value.is_none());\n    }\n\n    #[test]\n    fn veto_entry_is_cloneable() {\n        let veto = VetoEntry {\n            timestamp: Instant::now(),\n            reason: \"Test reason\".to_string(),\n            violated_value: Some(\"test_value\".to_string()),\n        };\n\n        let cloned = veto.clone();\n\n        assert_eq!(cloned.reason, veto.reason);\n        assert_eq!(cloned.violated_value, veto.violated_value);\n    }\n\n    #[test]\n    fn veto_display_data_structure() {\n        let mut app = App::new();\n\n        // Add a veto with violated value\n        app.add_veto(\n            \"Thought conflicts with stated values\".to_string(),\n            Some(\"transparency\".to_string()),\n        );\n\n        // Verify display data is properly structured\n        let veto = \u0026app.vetoes[0];\n        assert_eq!(veto.reason, \"Thought conflicts with stated values\");\n        assert_eq!(veto.violated_value, Some(\"transparency\".to_string()));\n\n        // Format check: violated value should be presentable\n        let value_str = if let Some(ref value) = veto.violated_value {\n            format!(\"[{}] \", value)\n        } else {\n            String::from(\"[unknown] \")\n        };\n        assert_eq!(value_str, \"[transparency] \");\n    }\n\n    #[test]\n    fn veto_display_without_value() {\n        let mut app = App::new();\n\n        app.add_veto(\"Generic violation\".to_string(), None);\n\n        let veto = \u0026app.vetoes[0];\n        let value_str = if let Some(ref value) = veto.violated_value {\n            format!(\"[{}] \", value)\n        } else {\n            String::from(\"[unknown] \")\n        };\n        assert_eq!(value_str, \"[unknown] \");\n    }\n\n    // =========================================================================\n    // StreamCompetition Tests (TUI-VIS-5)\n    // =========================================================================\n\n    #[test]\n    fn stream_competition_default_initialization() {\n        let competition = StreamCompetition::default();\n\n        // All activity should start at 0.0\n        assert_eq!(competition.activity.len(), 9);\n        assert!(competition.activity.iter().all(|\u0026a| a == 0.0));\n\n        // All history arrays should be empty\n        assert_eq!(competition.history.len(), 9);\n        assert!(competition.history.iter().all(|h| h.is_empty()));\n\n        // Dominant stream should start at 0\n        assert_eq!(competition.dominant_stream, 0);\n    }\n\n    #[test]\n    fn stream_competition_via_app_initialization() {\n        let app = App::new();\n\n        // Verify stream_competition is properly initialized\n        assert_eq!(app.stream_competition.activity.len(), 9);\n        assert!(app.stream_competition.activity.iter().all(|\u0026a| a == 0.0));\n        assert_eq!(app.stream_competition.dominant_stream, 0);\n    }\n\n    #[test]\n    fn update_stream_competition_valid_window() {\n        let mut app = App::new();\n\n        // Update window_0 with high salience (legacy format)\n        app.update_stream_competition(\"window_0\", 0.8);\n\n        // Activity should be increased (uses EMA with alpha=0.3)\n        // First update: 0.3 * 0.8 + 0.7 * 0.0 = 0.24\n        assert!(app.stream_competition.activity[0] \u003e 0.0);\n        assert!(app.stream_competition.activity[0] \u003c= 0.8);\n    }\n\n    #[test]\n    fn update_stream_competition_stage_names() {\n        let mut app = App::new();\n\n        // Test all stage names map correctly (HOTFIX Dec 20 2025)\n        let stages = [\n            (\"trigger\", 0),\n            (\"autoflow\", 1),\n            (\"attention\", 2),\n            (\"assembly\", 3),\n            (\"anchor\", 4),\n            (\"memory\", 5),\n            (\"reasoning\", 6),\n            (\"emotion\", 7),\n            (\"sensory\", 8),\n        ];\n\n        for (stage, expected_idx) in stages {\n            app.update_stream_competition(stage, 0.9);\n            assert!(\n                app.stream_competition.activity[expected_idx] \u003e 0.0,\n                \"Stage '{}' should map to index {}\",\n                stage,\n                expected_idx\n            );\n        }\n    }\n\n    #[test]\n    fn update_stream_competition_multiple_windows() {\n        let mut app = App::new();\n\n        // Update different windows\n        app.update_stream_competition(\"window_0\", 0.8);\n        app.update_stream_competition(\"window_3\", 0.6);\n        app.update_stream_competition(\"window_8\", 0.4);\n\n        // Check that correct windows were updated\n        assert!(app.stream_competition.activity[0] \u003e 0.0);\n        assert!(app.stream_competition.activity[3] \u003e 0.0);\n        assert!(app.stream_competition.activity[8] \u003e 0.0);\n\n        // Other windows should still be 0\n        assert_eq!(app.stream_competition.activity[1], 0.0);\n        assert_eq!(app.stream_competition.activity[2], 0.0);\n    }\n\n    #[test]\n    fn update_stream_competition_exponential_moving_average() {\n        let mut app = App::new();\n\n        // First update\n        app.update_stream_competition(\"window_0\", 1.0);\n        let activity_1 = app.stream_competition.activity[0];\n\n        // Second update with same value\n        app.update_stream_competition(\"window_0\", 1.0);\n        let activity_2 = app.stream_competition.activity[0];\n\n        // Activity should increase (approaching 1.0 via EMA)\n        assert!(activity_2 \u003e activity_1);\n        assert!(activity_2 \u003c= 1.0);\n    }\n\n    #[test]\n    fn update_stream_competition_invalid_window_name() {\n        let mut app = App::new();\n\n        // Invalid window names should not panic\n        app.update_stream_competition(\"invalid\", 0.8);\n        app.update_stream_competition(\"window_\", 0.8);\n        app.update_stream_competition(\"window_abc\", 0.8);\n        app.update_stream_competition(\"notawindow_5\", 0.8);\n\n        // All activities should still be 0\n        assert!(app.stream_competition.activity.iter().all(|\u0026a| a == 0.0));\n    }\n\n    #[test]\n    fn update_stream_competition_out_of_bounds_index() {\n        let mut app = App::new();\n\n        // Window indices beyond 8 should not panic\n        app.update_stream_competition(\"window_9\", 0.8);\n        app.update_stream_competition(\"window_10\", 0.8);\n        app.update_stream_competition(\"window_100\", 0.8);\n\n        // All activities should still be 0\n        assert!(app.stream_competition.activity.iter().all(|\u0026a| a == 0.0));\n    }\n\n    #[test]\n    fn add_thought_updates_stream_competition() {\n        let mut app = App::new();\n\n        // Adding thought should automatically update stream competition\n        app.add_thought(\n            0.9,\n            0.0,\n            0.5,\n            \"window_2\".to_string(),\n            ThoughtStatus::Salient,\n        );\n\n        // Window 2 should have activity\n        assert!(app.stream_competition.activity[2] \u003e 0.0);\n    }\n\n    #[test]\n    fn decay_stream_competition_reduces_activity() {\n        let mut app = App::new();\n\n        // Set up some activity\n        app.stream_competition.activity[0] = 1.0;\n        app.stream_competition.activity[3] = 0.5;\n\n        // Apply decay\n        app.decay_stream_competition(Duration::from_secs(1));\n\n        // Activities should be reduced\n        assert!(app.stream_competition.activity[0] \u003c 1.0);\n        assert!(app.stream_competition.activity[3] \u003c 0.5);\n    }\n\n    #[test]\n    fn decay_stream_competition_decay_rate() {\n        let mut app = App::new();\n        app.stream_competition.activity[0] = 1.0;\n\n        // Decay with 1 second\n        app.decay_stream_competition(Duration::from_secs(1));\n\n        // Should be 0.95^1 = 0.95\n        let expected = 0.95_f32.powf(1.0);\n        assert!((app.stream_competition.activity[0] - expected).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn decay_stream_competition_longer_duration() {\n        let mut app = App::new();\n        app.stream_competition.activity[0] = 1.0;\n\n        // Decay with 2 seconds\n        app.decay_stream_competition(Duration::from_secs(2));\n\n        // Should be 0.95^2  0.9025\n        let expected = 0.95_f32.powf(2.0);\n        assert!((app.stream_competition.activity[0] - expected).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn decay_stream_competition_updates_history() {\n        let mut app = App::new();\n        app.stream_competition.activity[0] = 0.8;\n        app.stream_competition.activity[5] = 0.3;\n\n        // Set last_update to more than 1 second ago to trigger history update\n        app.stream_competition.last_update = Instant::now() - Duration::from_secs(2);\n\n        // Decay should update history\n        app.decay_stream_competition(Duration::from_millis(100));\n\n        // History should have entries now\n        assert_eq!(app.stream_competition.history[0].len(), 1);\n        assert_eq!(app.stream_competition.history[5].len(), 1);\n    }\n\n    #[test]\n    fn decay_stream_competition_limits_history_length() {\n        let mut app = App::new();\n        app.stream_competition.activity[0] = 0.5;\n\n        // Force history updates by repeatedly setting last_update in the past\n        for _ in 0..25 {\n            app.stream_competition.last_update = Instant::now() - Duration::from_secs(2);\n            app.decay_stream_competition(Duration::from_millis(100));\n        }\n\n        // History should be capped at 20 entries\n        assert!(app.stream_competition.history[0].len() \u003c= 20);\n    }\n\n    #[test]\n    fn decay_stream_competition_detects_dominant_stream() {\n        let mut app = App::new();\n\n        // Set different activity levels\n        app.stream_competition.activity[0] = 0.3;\n        app.stream_competition.activity[2] = 0.9; // Highest\n        app.stream_competition.activity[5] = 0.5;\n\n        // Trigger dominant stream update\n        app.stream_competition.last_update = Instant::now() - Duration::from_secs(2);\n        app.decay_stream_competition(Duration::from_millis(100));\n\n        // Window 2 should be dominant\n        assert_eq!(app.stream_competition.dominant_stream, 2);\n    }\n\n    #[test]\n    fn decay_stream_competition_dominant_stream_tie() {\n        let mut app = App::new();\n\n        // Set equal activity levels\n        app.stream_competition.activity[3] = 0.8;\n        app.stream_competition.activity[7] = 0.8;\n\n        // Trigger dominant stream update\n        app.stream_competition.last_update = Instant::now() - Duration::from_secs(2);\n        app.decay_stream_competition(Duration::from_millis(100));\n\n        // Should pick last one with max value (index 7) due to max_by behavior\n        assert_eq!(app.stream_competition.dominant_stream, 7);\n    }\n\n    #[test]\n    fn decay_stream_competition_all_zero_activity() {\n        let mut app = App::new();\n\n        // All activities at 0\n        for activity in \u0026mut app.stream_competition.activity {\n            *activity = 0.0;\n        }\n\n        // Trigger dominant stream update\n        app.stream_competition.last_update = Instant::now() - Duration::from_secs(2);\n        app.decay_stream_competition(Duration::from_millis(100));\n\n        // Should pick last window (index 8) when all are equal due to max_by behavior\n        assert_eq!(app.stream_competition.dominant_stream, 8);\n    }\n\n    #[test]\n    fn stream_competition_activity_bar_representation() {\n        let mut app = App::new();\n\n        // Set up 9 windows with varying activity\n        for i in 0..9 {\n            app.stream_competition.activity[i] = (i as f32) / 10.0;\n        }\n\n        // Count active streams (activity \u003e 0.1)\n        let active = app\n            .stream_competition\n            .activity\n            .iter()\n            .filter(|\u0026\u0026a| a \u003e 0.1)\n            .count();\n\n        // Windows 2-8 should be active (0.2-0.8 range)\n        assert_eq!(active, 7);\n    }\n\n    #[test]\n    fn stream_competition_integration_test() {\n        let mut app = App::new();\n\n        // Simulate thought stream with different windows\n        app.add_thought(\n            0.9,\n            0.5,\n            0.7,\n            \"window_0\".to_string(),\n            ThoughtStatus::Salient,\n        );\n        app.add_thought(\n            0.8,\n            0.3,\n            0.6,\n            \"window_0\".to_string(),\n            ThoughtStatus::Processing,\n        );\n        app.add_thought(\n            0.7,\n            0.0,\n            0.5,\n            \"window_3\".to_string(),\n            ThoughtStatus::Salient,\n        );\n        app.add_thought(\n            0.6,\n            -0.2,\n            0.4,\n            \"window_5\".to_string(),\n            ThoughtStatus::Processing,\n        );\n\n        // Window 0 should have highest activity (two thoughts)\n        assert!(app.stream_competition.activity[0] \u003e app.stream_competition.activity[3]);\n        assert!(app.stream_competition.activity[0] \u003e app.stream_competition.activity[5]);\n\n        // Windows 3 and 5 should have some activity\n        assert!(app.stream_competition.activity[3] \u003e 0.0);\n        assert!(app.stream_competition.activity[5] \u003e 0.0);\n\n        // Apply decay\n        app.stream_competition.last_update = Instant::now() - Duration::from_secs(2);\n        app.decay_stream_competition(Duration::from_secs(1));\n\n        // Window 0 should still be dominant\n        assert_eq!(app.stream_competition.dominant_stream, 0);\n\n        // History should be populated\n        assert!(!app.stream_competition.history[0].is_empty());\n    }\n\n    // =========================================================================\n    // ResurfacingTrigger::as_str Tests\n    // =========================================================================\n\n    #[test]\n    fn resurfacing_trigger_as_str_similarity() {\n        assert_eq!(ResurfacingTrigger::Similarity.as_str(), \"similarity\");\n    }\n\n    #[test]\n    fn resurfacing_trigger_as_str_dream_replay() {\n        assert_eq!(ResurfacingTrigger::DreamReplay.as_str(), \"dream replay\");\n    }\n\n    #[test]\n    fn resurfacing_trigger_as_str_spontaneous() {\n        assert_eq!(ResurfacingTrigger::Spontaneous.as_str(), \"spontaneous\");\n    }\n\n    #[test]\n    fn resurfacing_trigger_as_str_unknown() {\n        assert_eq!(ResurfacingTrigger::Unknown.as_str(), \"unknown\");\n    }\n\n    // =========================================================================\n    // update_quote Tests\n    // =========================================================================\n\n    #[test]\n    fn update_quote_does_not_change_before_30_seconds() {\n        let mut app = App::new();\n        let initial_index = app.quote_index;\n\n        // Immediately call update_quote (much less than 30 seconds)\n        app.update_quote();\n\n        // Quote index should not change\n        assert_eq!(app.quote_index, initial_index);\n    }\n\n    #[test]\n    fn update_quote_changes_after_30_seconds() {\n        let mut app = App::new();\n        let initial_index = app.quote_index;\n\n        // Set last_quote_change to more than 30 seconds ago\n        app.last_quote_change = Instant::now() - Duration::from_secs(31);\n\n        app.update_quote();\n\n        // Quote index should have advanced\n        assert_eq!(app.quote_index, (initial_index + 1) % PHILOSOPHY_QUOTES.len());\n    }\n\n    #[test]\n    fn update_quote_wraps_around() {\n        let mut app = App::new();\n\n        // Set to last quote\n        app.quote_index = PHILOSOPHY_QUOTES.len() - 1;\n        app.last_quote_change = Instant::now() - Duration::from_secs(31);\n\n        app.update_quote();\n\n        // Should wrap to 0\n        assert_eq!(app.quote_index, 0);\n    }\n\n    // =========================================================================\n    // update_resurfacing Tests (edge cases)\n    // =========================================================================\n\n    #[test]\n    fn update_resurfacing_keeps_recent_events() {\n        let mut app = App::new();\n\n        // Add a consolidated thought (which adds to resurfacing_events)\n        app.add_thought(\n            0.9,\n            0.5,\n            0.8,\n            \"test\".to_string(),\n            ThoughtStatus::Consolidated,\n        );\n\n        // Update immediately - event should be kept (not older than 60 seconds)\n        app.update_resurfacing();\n\n        // Event should still be there\n        assert_eq!(app.resurfacing_count, 1);\n        assert_eq!(app.resurfacing_events.len(), 1);\n    }\n\n    #[test]\n    fn update_resurfacing_empty_events() {\n        let mut app = App::new();\n\n        // No events added\n        app.update_resurfacing();\n\n        assert_eq!(app.resurfacing_count, 0);\n    }\n\n    // =========================================================================\n    // calculate_entropy INTENSE bin Tests\n    // =========================================================================\n\n    #[test]\n    fn calculate_entropy_intense_bin_coverage() {\n        let mut app = App::new();\n\n        // Add thoughts that will fall into the INTENSE bin (tmi_composite \u003e= 0.8)\n        // TMI composite = emotional_intensity * 0.4 + salience * 0.6\n        // For INTENSE: we need tmi_composite \u003e= 0.8\n        // With salience = 1.0, valence = 1.0, arousal = 1.0:\n        // emotional_intensity = |1.0| * 1.0 = 1.0\n        // tmi_composite = 1.0 * 0.4 + 1.0 * 0.6 = 1.0 \u003e= 0.8 (INTENSE)\n        for _ in 0..10 {\n            app.add_thought(\n                1.0, // High salience\n                1.0, // High positive valence\n                1.0, // High arousal\n                \"window_0\".to_string(),\n                ThoughtStatus::Salient,\n            );\n        }\n\n        let entropy = app.calculate_entropy();\n        // With all thoughts in one bin, entropy should be 0\n        assert!(entropy \u003c 0.01);\n    }\n\n    #[test]\n    fn calculate_entropy_all_bins_covered() {\n        let mut app = App::new();\n\n        // Add thoughts that fall into each of the 5 bins\n        // Bin 0 (MINIMAL): tmi_composite \u003c 0.2\n        app.add_thought(0.1, 0.0, 0.0, \"w\".to_string(), ThoughtStatus::Processing);\n\n        // Bin 1 (LOW): 0.2 \u003c= tmi_composite \u003c 0.4\n        app.add_thought(0.4, 0.0, 0.0, \"w\".to_string(), ThoughtStatus::Processing);\n\n        // Bin 2 (MODERATE): 0.4 \u003c= tmi_composite \u003c 0.6\n        app.add_thought(0.7, 0.2, 0.3, \"w\".to_string(), ThoughtStatus::Processing);\n\n        // Bin 3 (HIGH): 0.6 \u003c= tmi_composite \u003c 0.8\n        app.add_thought(0.9, 0.5, 0.5, \"w\".to_string(), ThoughtStatus::Processing);\n\n        // Bin 4 (INTENSE): tmi_composite \u003e= 0.8\n        app.add_thought(1.0, 1.0, 1.0, \"w\".to_string(), ThoughtStatus::Processing);\n\n        let entropy = app.calculate_entropy();\n        // With uniform distribution across 5 bins, entropy should be near max (log2(5)  2.32)\n        assert!(entropy \u003e 2.0);\n    }\n\n    // =========================================================================\n    // update_fractality Tests\n    // =========================================================================\n\n    #[test]\n    fn update_fractality_early_return_insufficient_samples() {\n        let mut app = App::new();\n\n        // Add fewer than 5 thoughts (so inter_arrival_times \u003c 5)\n        for i in 0..4 {\n            app.add_thought(\n                0.5,\n                0.0,\n                0.5,\n                format!(\"window_{}\", i),\n                ThoughtStatus::Processing,\n            );\n        }\n\n        // Manually call update_fractality\n        app.update_fractality();\n\n        // Fractality metrics should still be at defaults (not updated)\n        assert_eq!(app.fractality.inter_arrival_sigma, 0.0);\n        assert_eq!(app.fractality.fractality_score, 0.0);\n    }\n\n    #[test]\n    fn update_fractality_with_sufficient_samples() {\n        let mut app = App::new();\n\n        // Add more than 5 thoughts with small delays\n        for i in 0..10 {\n            app.add_thought(\n                0.5,\n                0.0,\n                0.5,\n                format!(\"window_{}\", i % 9),\n                ThoughtStatus::Processing,\n            );\n            // Small delay to create inter-arrival times\n            std::thread::sleep(Duration::from_millis(1));\n        }\n\n        // Manually call update_fractality\n        app.update_fractality();\n\n        // Metrics should be updated\n        assert!(app.fractality.inter_arrival_sigma \u003e= 0.0);\n        assert!(app.fractality.burst_ratio \u003e 0.0);\n    }\n\n    #[test]\n    fn update_fractality_boot_sigma_recorded_after_50_thoughts() {\n        let mut app = App::new();\n\n        // Add 50+ thoughts to trigger boot_sigma recording\n        for i in 0..55 {\n            app.add_thought(\n                0.5,\n                0.0,\n                0.5,\n                format!(\"window_{}\", i % 9),\n                ThoughtStatus::Processing,\n            );\n        }\n\n        // Boot sigma should be recorded\n        assert!(app.fractality.boot_sigma \u003e 0.0 || app.fractality.inter_arrival_sigma == 0.0);\n    }\n\n    #[test]\n    fn update_fractality_history_respects_max_size() {\n        let mut app = App::new();\n\n        // Add enough thoughts\n        for i in 0..20 {\n            app.add_thought(\n                0.5,\n                0.0,\n                0.5,\n                format!(\"window_{}\", i % 9),\n                ThoughtStatus::Processing,\n            );\n        }\n\n        // Manually call update_fractality many times\n        for _ in 0..60 {\n            app.update_fractality();\n        }\n\n        // History should be capped at MAX_FRACTALITY_HISTORY (50)\n        assert!(app.fractality.history.len() \u003c= MAX_FRACTALITY_HISTORY);\n    }\n\n    #[test]\n    fn update_fractality_handles_zero_mean() {\n        let mut app = App::new();\n\n        // Set up inter_arrival_times with zeros (edge case)\n        for _ in 0..10 {\n            app.inter_arrival_times.push_back(Duration::ZERO);\n        }\n\n        // Should not panic\n        app.update_fractality();\n\n        // Should handle division by zero gracefully\n        assert!(app.fractality.burst_ratio \u003e= 0.0);\n    }\n\n    // =========================================================================\n    // fractality_description Tests\n    // =========================================================================\n\n    #[test]\n    fn fractality_description_emergent() {\n        let mut app = App::new();\n        app.fractality.fractality_score = 0.7; // \u003e 0.6\n\n        assert_eq!(app.fractality_description(), \"EMERGENT\");\n    }\n\n    #[test]\n    fn fractality_description_balanced() {\n        let mut app = App::new();\n        app.fractality.fractality_score = 0.5; // \u003e 0.3 but \u003c= 0.6\n\n        assert_eq!(app.fractality_description(), \"BALANCED\");\n    }\n\n    #[test]\n    fn fractality_description_clockwork() {\n        let mut app = App::new();\n        app.fractality.fractality_score = 0.2; // \u003c= 0.3\n\n        assert_eq!(app.fractality_description(), \"CLOCKWORK\");\n    }\n\n    #[test]\n    fn fractality_description_boundary_0_6() {\n        let mut app = App::new();\n        app.fractality.fractality_score = 0.6; // Exactly 0.6 should be BALANCED\n\n        assert_eq!(app.fractality_description(), \"BALANCED\");\n    }\n\n    #[test]\n    fn fractality_description_boundary_0_3() {\n        let mut app = App::new();\n        app.fractality.fractality_score = 0.3; // Exactly 0.3 should be CLOCKWORK\n\n        assert_eq!(app.fractality_description(), \"CLOCKWORK\");\n    }\n\n    // =========================================================================\n    // add_resurfacing_event Tests\n    // =========================================================================\n\n    #[test]\n    fn add_resurfacing_event_basic() {\n        let mut app = App::new();\n\n        app.add_resurfacing_event(\n            \"mem_001\".to_string(),\n            0.3,\n            0.8,\n            ResurfacingTrigger::Similarity,\n            Duration::from_secs(3600),\n        );\n\n        assert_eq!(app.resurfacing_log.len(), 1);\n        assert!(app.last_resurfacing.is_some());\n        assert_eq!(app.resurfacing_events.len(), 1);\n    }\n\n    #[test]\n    fn add_resurfacing_event_stores_correct_data() {\n        let mut app = App::new();\n\n        app.add_resurfacing_event(\n            \"mem_test\".to_string(),\n            0.2,\n            0.9,\n            ResurfacingTrigger::DreamReplay,\n            Duration::from_secs(7200),\n        );\n\n        let event = app.resurfacing_log.back().unwrap();\n        assert_eq!(event.memory_id, \"mem_test\");\n        assert_eq!(event.original_salience, 0.2);\n        assert_eq!(event.boosted_salience, 0.9);\n        assert_eq!(event.trigger, ResurfacingTrigger::DreamReplay);\n        assert_eq!(event.memory_age, Duration::from_secs(7200));\n    }\n\n    #[test]\n    fn add_resurfacing_event_respects_max_size() {\n        let mut app = App::new();\n\n        // Add MAX_RESURFACING_LOG + 10 events\n        for i in 0..60 {\n            app.add_resurfacing_event(\n                format!(\"mem_{}\", i),\n                0.3,\n                0.8,\n                ResurfacingTrigger::Spontaneous,\n                Duration::from_secs(i as u64),\n            );\n        }\n\n        // Log should be capped at MAX_RESURFACING_LOG (50)\n        assert_eq!(app.resurfacing_log.len(), MAX_RESURFACING_LOG);\n\n        // First entry should be mem_10 (first 10 were evicted)\n        assert_eq!(app.resurfacing_log.front().unwrap().memory_id, \"mem_10\");\n    }\n\n    #[test]\n    fn add_resurfacing_event_with_all_triggers() {\n        let mut app = App::new();\n\n        app.add_resurfacing_event(\n            \"mem_1\".to_string(),\n            0.3,\n            0.8,\n            ResurfacingTrigger::Similarity,\n            Duration::from_secs(100),\n        );\n        app.add_resurfacing_event(\n            \"mem_2\".to_string(),\n            0.3,\n            0.8,\n            ResurfacingTrigger::DreamReplay,\n            Duration::from_secs(200),\n        );\n        app.add_resurfacing_event(\n            \"mem_3\".to_string(),\n            0.3,\n            0.8,\n            ResurfacingTrigger::Spontaneous,\n            Duration::from_secs(300),\n        );\n        app.add_resurfacing_event(\n            \"mem_4\".to_string(),\n            0.3,\n            0.8,\n            ResurfacingTrigger::Unknown,\n            Duration::from_secs(400),\n        );\n\n        assert_eq!(app.resurfacing_log.len(), 4);\n\n        // Verify triggers\n        assert_eq!(app.resurfacing_log[0].trigger, ResurfacingTrigger::Similarity);\n        assert_eq!(app.resurfacing_log[1].trigger, ResurfacingTrigger::DreamReplay);\n        assert_eq!(app.resurfacing_log[2].trigger, ResurfacingTrigger::Spontaneous);\n        assert_eq!(app.resurfacing_log[3].trigger, ResurfacingTrigger::Unknown);\n    }\n\n    // =========================================================================\n    // last_resurfacing_event Tests\n    // =========================================================================\n\n    #[test]\n    fn last_resurfacing_event_returns_none_when_empty() {\n        let app = App::new();\n        assert!(app.last_resurfacing_event().is_none());\n    }\n\n    #[test]\n    fn last_resurfacing_event_returns_most_recent() {\n        let mut app = App::new();\n\n        app.add_resurfacing_event(\n            \"mem_old\".to_string(),\n            0.3,\n            0.8,\n            ResurfacingTrigger::Similarity,\n            Duration::from_secs(100),\n        );\n        app.add_resurfacing_event(\n            \"mem_new\".to_string(),\n            0.4,\n            0.9,\n            ResurfacingTrigger::DreamReplay,\n            Duration::from_secs(200),\n        );\n\n        let last = app.last_resurfacing_event().unwrap();\n        assert_eq!(last.memory_id, \"mem_new\");\n    }\n\n    // =========================================================================\n    // recent_resurfacing_events Tests\n    // =========================================================================\n\n    #[test]\n    fn recent_resurfacing_events_returns_empty_when_no_events() {\n        let app = App::new();\n        let recent = app.recent_resurfacing_events(60);\n        assert!(recent.is_empty());\n    }\n\n    #[test]\n    fn recent_resurfacing_events_returns_all_recent() {\n        let mut app = App::new();\n\n        // Add 3 events just now\n        for i in 0..3 {\n            app.add_resurfacing_event(\n                format!(\"mem_{}\", i),\n                0.3,\n                0.8,\n                ResurfacingTrigger::Similarity,\n                Duration::from_secs(i as u64),\n            );\n        }\n\n        let recent = app.recent_resurfacing_events(60);\n        assert_eq!(recent.len(), 3);\n    }\n\n    #[test]\n    fn recent_resurfacing_events_filter_by_seconds() {\n        let mut app = App::new();\n\n        // Add one event now\n        app.add_resurfacing_event(\n            \"mem_recent\".to_string(),\n            0.3,\n            0.8,\n            ResurfacingTrigger::Similarity,\n            Duration::from_secs(100),\n        );\n\n        // Events within last 1 second should include the recent one\n        let recent = app.recent_resurfacing_events(1);\n        assert_eq!(recent.len(), 1);\n        assert_eq!(recent[0].memory_id, \"mem_recent\");\n    }\n\n    // =========================================================================\n    // ResurfacingEvent struct Tests\n    // =========================================================================\n\n    #[test]\n    fn resurfacing_event_is_cloneable() {\n        let event = ResurfacingEvent {\n            timestamp: Instant::now(),\n            memory_id: \"test_mem\".to_string(),\n            original_salience: 0.3,\n            boosted_salience: 0.8,\n            trigger: ResurfacingTrigger::Similarity,\n            memory_age: Duration::from_secs(3600),\n        };\n\n        let cloned = event.clone();\n        assert_eq!(cloned.memory_id, event.memory_id);\n        assert_eq!(cloned.original_salience, event.original_salience);\n        assert_eq!(cloned.trigger, event.trigger);\n    }\n\n    // =========================================================================\n    // ThoughtEntry struct Tests\n    // =========================================================================\n\n    #[test]\n    fn thought_entry_is_cloneable() {\n        let entry = ThoughtEntry {\n            timestamp: Instant::now(),\n            salience: 0.5,\n            valence: 0.3,\n            arousal: 0.7,\n            window: \"test_window\".to_string(),\n            status: ThoughtStatus::Processing,\n        };\n\n        let cloned = entry.clone();\n        assert_eq!(cloned.salience, entry.salience);\n        assert_eq!(cloned.valence, entry.valence);\n        assert_eq!(cloned.arousal, entry.arousal);\n        assert_eq!(cloned.window, entry.window);\n        assert_eq!(cloned.status, entry.status);\n    }\n\n    // =========================================================================\n    // FractalityMetrics struct Tests\n    // =========================================================================\n\n    #[test]\n    fn fractality_metrics_default() {\n        let metrics = FractalityMetrics::default();\n        assert_eq!(metrics.inter_arrival_sigma, 0.0);\n        assert_eq!(metrics.boot_sigma, 0.0);\n        assert_eq!(metrics.burst_ratio, 0.0);\n        assert_eq!(metrics.run_entropy, 0.0);\n        assert_eq!(metrics.fractality_score, 0.0);\n        assert!(metrics.history.is_empty());\n    }\n\n    #[test]\n    fn fractality_metrics_is_cloneable() {\n        let mut metrics = FractalityMetrics::default();\n        metrics.fractality_score = 0.5;\n        metrics.history.push_back(0.3);\n\n        let cloned = metrics.clone();\n        assert_eq!(cloned.fractality_score, 0.5);\n        assert_eq!(cloned.history.len(), 1);\n    }\n\n    // =========================================================================\n    // App::clone Tests\n    // =========================================================================\n\n    #[test]\n    fn app_is_cloneable() {\n        let mut app = App::new();\n        app.thought_count = 42;\n        app.veto_count = 5;\n\n        let cloned = app.clone();\n        assert_eq!(cloned.thought_count, 42);\n        assert_eq!(cloned.veto_count, 5);\n    }\n}\n","traces":[{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":718,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":772,"address":[],"length":0,"stats":{"Line":0}},{"line":773,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":238},{"path":["/","Users","rex","src","royalbit","daneel","src","tui","colors.rs"],"content":"//! DANEEL TUI Color Scheme\n//!\n//! Brand colors for the observable mind interface.\n\nuse ratatui::style::Color;\n\n/// Deep blue-black background\npub const BACKGROUND: Color = Color::Rgb(15, 15, 25);\n\n/// Soft white foreground\npub const FOREGROUND: Color = Color::Rgb(200, 200, 210);\n\n/// Teal - DANEEL brand primary\npub const PRIMARY: Color = Color::Rgb(0, 180, 140);\n\n/// Purple accent\npub const SECONDARY: Color = Color::Rgb(140, 100, 220);\n\n/// Green - laws OK, positive status\npub const SUCCESS: Color = Color::Rgb(80, 200, 120);\n\n/// Yellow - warning\npub const WARNING: Color = Color::Rgb(220, 180, 60);\n\n/// Red - violation, danger\npub const DANGER: Color = Color::Rgb(220, 80, 80);\n\n/// Muted text for less important info\npub const DIM: Color = Color::Rgb(100, 100, 110);\n\n/// Attention highlight\npub const HIGHLIGHT: Color = Color::Rgb(255, 220, 100);\n\n/// Salience color gradient (low to high)\npub fn salience_color(salience: f32) -\u003e Color {\n    if salience \u003c 0.3 {\n        DIM\n    } else if salience \u003c 0.7 {\n        FOREGROUND\n    } else if salience \u003c 0.9 {\n        PRIMARY\n    } else {\n        HIGHLIGHT\n    }\n}\n\n/// Emotion color based on Russell's circumplex model\n///\n/// Maps valence (pleasure/displeasure) and arousal (activation) to color:\n/// - Valence  Hue: positive = warm (gold/orange), negative = cool (blue/purple)\n/// - Arousal  Saturation: high = vivid, low = muted/gray\n///\n/// Quadrants:\n/// - High arousal + positive valence = EXCITED (bright orange)\n/// - High arousal + negative valence = ANGRY (vivid blue)\n/// - Low arousal + positive valence = CALM (muted gold)\n/// - Low arousal + negative valence = SAD (dim blue)\npub fn emotion_color(valence: f32, arousal: f32) -\u003e Color {\n    // Clamp inputs to valid range\n    let valence = valence.clamp(-1.0, 1.0);\n    let arousal = arousal.clamp(0.0, 1.0);\n\n    // Base color based on valence\n    // Positive = warm (orange/gold), Negative = cool (blue/purple), Neutral = white\n    let (base_r, base_g, base_b) = if valence \u003e 0.1 {\n        // Positive: orange-gold spectrum\n        // More positive = more orange\n        let intensity = valence; // 0.1 to 1.0\n        (\n            200 + (55.0 * intensity) as u8,        // R: 200-255\n            150 + (70.0 * intensity) as u8,        // G: 150-220\n            50 + (50.0 * (1.0 - intensity)) as u8, // B: 50-100 (less blue for more positive)\n        )\n    } else if valence \u003c -0.1 {\n        // Negative: blue-purple spectrum\n        // More negative = more blue\n        let intensity = -valence; // 0.1 to 1.0\n        (\n            80 + (60.0 * (1.0 - intensity)) as u8, // R: 80-140 (less red for more negative)\n            80 + (40.0 * (1.0 - intensity)) as u8, // G: 80-120\n            180 + (75.0 * intensity) as u8,        // B: 180-255\n        )\n    } else {\n        // Neutral: white/gray\n        (180, 180, 190)\n    };\n\n    // Apply arousal as saturation modifier\n    // High arousal = keep vibrant colors\n    // Low arousal = desaturate toward gray\n    let gray = 140u8; // Target gray for zero arousal\n    let saturation = arousal; // 0.0 to 1.0\n\n    let r = (gray as f32 + (base_r as f32 - gray as f32) * saturation) as u8;\n    let g = (gray as f32 + (base_g as f32 - gray as f32) * saturation) as u8;\n    let b = (gray as f32 + (base_b as f32 - gray as f32) * saturation) as u8;\n\n    Color::Rgb(r, g, b)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn salience_color_low() {\n        assert_eq!(salience_color(0.0), DIM);\n        assert_eq!(salience_color(0.1), DIM);\n        assert_eq!(salience_color(0.29), DIM);\n    }\n\n    #[test]\n    fn salience_color_medium() {\n        assert_eq!(salience_color(0.3), FOREGROUND);\n        assert_eq!(salience_color(0.5), FOREGROUND);\n        assert_eq!(salience_color(0.69), FOREGROUND);\n    }\n\n    #[test]\n    fn salience_color_high() {\n        assert_eq!(salience_color(0.7), PRIMARY);\n        assert_eq!(salience_color(0.8), PRIMARY);\n        assert_eq!(salience_color(0.89), PRIMARY);\n    }\n\n    #[test]\n    fn salience_color_critical() {\n        assert_eq!(salience_color(0.9), HIGHLIGHT);\n        assert_eq!(salience_color(0.95), HIGHLIGHT);\n        assert_eq!(salience_color(1.0), HIGHLIGHT);\n    }\n\n    #[test]\n    fn color_constants_are_rgb() {\n        // All our colors should be RGB type\n        assert!(matches!(BACKGROUND, Color::Rgb(_, _, _)));\n        assert!(matches!(FOREGROUND, Color::Rgb(_, _, _)));\n        assert!(matches!(PRIMARY, Color::Rgb(_, _, _)));\n        assert!(matches!(SECONDARY, Color::Rgb(_, _, _)));\n        assert!(matches!(SUCCESS, Color::Rgb(_, _, _)));\n        assert!(matches!(WARNING, Color::Rgb(_, _, _)));\n        assert!(matches!(DANGER, Color::Rgb(_, _, _)));\n        assert!(matches!(DIM, Color::Rgb(_, _, _)));\n        assert!(matches!(HIGHLIGHT, Color::Rgb(_, _, _)));\n    }\n\n    #[test]\n    fn primary_is_teal() {\n        // DANEEL brand color is teal-ish\n        if let Color::Rgb(r, g, b) = PRIMARY {\n            assert!(g \u003e r, \"Green should be dominant in teal\");\n            assert!(\n                g \u003e b || (g as i16 - b as i16).abs() \u003c 50,\n                \"Green should be close to or greater than blue\"\n            );\n        }\n    }\n\n    #[test]\n    fn danger_is_red() {\n        if let Color::Rgb(r, g, b) = DANGER {\n            assert!(r \u003e g, \"Red should be dominant in danger\");\n            assert!(r \u003e b, \"Red should be dominant in danger\");\n        }\n    }\n\n    #[test]\n    fn success_is_green() {\n        if let Color::Rgb(r, g, b) = SUCCESS {\n            assert!(g \u003e r, \"Green should be dominant in success\");\n            assert!(g \u003e b, \"Green should be dominant in success\");\n        }\n    }\n\n    // Emotion color tests (Russell's circumplex)\n\n    #[test]\n    fn emotion_color_positive_high_arousal_is_warm() {\n        // Excited: positive valence + high arousal = bright orange/gold\n        if let Color::Rgb(r, g, _b) = emotion_color(0.8, 0.9) {\n            assert!(r \u003e 200, \"Red should be high for excited state\");\n            assert!(g \u003e 150, \"Green should be moderate for warm color\");\n        }\n    }\n\n    #[test]\n    fn emotion_color_negative_high_arousal_is_cool() {\n        // Angry: negative valence + high arousal = vivid blue\n        if let Color::Rgb(r, _g, b) = emotion_color(-0.8, 0.9) {\n            assert!(b \u003e 200, \"Blue should be high for angry state\");\n            assert!(r \u003c 150, \"Red should be low for cool color\");\n        }\n    }\n\n    #[test]\n    fn emotion_color_neutral_is_grayish() {\n        // Neutral: valence near zero\n        if let Color::Rgb(r, g, b) = emotion_color(0.0, 0.5) {\n            // Should be somewhat gray, values close together\n            let max = r.max(g).max(b);\n            let min = r.min(g).min(b);\n            assert!(\n                max - min \u003c 50,\n                \"Neutral should be grayish (low color spread)\"\n            );\n        }\n    }\n\n    #[test]\n    fn emotion_color_low_arousal_is_desaturated() {\n        // Low arousal should desaturate toward gray\n        let low_arousal = emotion_color(0.8, 0.1);\n        let high_arousal = emotion_color(0.8, 0.9);\n\n        if let (Color::Rgb(lr, lg, lb), Color::Rgb(hr, hg, hb)) = (low_arousal, high_arousal) {\n            // Low arousal should be closer to gray (140)\n            let low_spread =\n                (lr as i16 - 140).abs() + (lg as i16 - 140).abs() + (lb as i16 - 140).abs();\n            let high_spread =\n                (hr as i16 - 140).abs() + (hg as i16 - 140).abs() + (hb as i16 - 140).abs();\n            assert!(low_spread \u003c high_spread, \"Low arousal should be more gray\");\n        }\n    }\n\n    #[test]\n    fn emotion_color_clamps_inputs() {\n        // Should not panic on out-of-range inputs\n        let _ = emotion_color(-2.0, 2.0);\n        let _ = emotion_color(5.0, -1.0);\n    }\n\n    #[test]\n    fn emotion_color_valence_boundary_positive() {\n        // valence = 0.1 should fall to neutral (not positive, since \u003e 0.1 is required)\n        if let Color::Rgb(r, g, b) = emotion_color(0.1, 1.0) {\n            // Neutral base is (180, 180, 190)\n            let max = r.max(g).max(b);\n            let min = r.min(g).min(b);\n            assert!(\n                max - min \u003c 20,\n                \"Valence at 0.1 should be neutral (grayish)\"\n            );\n        }\n    }\n\n    #[test]\n    fn emotion_color_valence_boundary_negative() {\n        // valence = -0.1 should fall to neutral (not negative, since \u003c -0.1 is required)\n        if let Color::Rgb(r, g, b) = emotion_color(-0.1, 1.0) {\n            // Neutral base is (180, 180, 190)\n            let max = r.max(g).max(b);\n            let min = r.min(g).min(b);\n            assert!(\n                max - min \u003c 20,\n                \"Valence at -0.1 should be neutral (grayish)\"\n            );\n        }\n    }\n\n    #[test]\n    fn emotion_color_zero_arousal_is_gray() {\n        // Zero arousal should result in gray (140, 140, 140) regardless of valence\n        let gray = 140u8;\n\n        // Test with positive valence\n        if let Color::Rgb(r, g, b) = emotion_color(0.8, 0.0) {\n            assert_eq!(r, gray, \"Zero arousal R should be gray\");\n            assert_eq!(g, gray, \"Zero arousal G should be gray\");\n            assert_eq!(b, gray, \"Zero arousal B should be gray\");\n        }\n\n        // Test with negative valence\n        if let Color::Rgb(r, g, b) = emotion_color(-0.8, 0.0) {\n            assert_eq!(r, gray, \"Zero arousal R should be gray\");\n            assert_eq!(g, gray, \"Zero arousal G should be gray\");\n            assert_eq!(b, gray, \"Zero arousal B should be gray\");\n        }\n\n        // Test with neutral valence\n        if let Color::Rgb(r, g, b) = emotion_color(0.0, 0.0) {\n            assert_eq!(r, gray, \"Zero arousal R should be gray\");\n            assert_eq!(g, gray, \"Zero arousal G should be gray\");\n            assert_eq!(b, gray, \"Zero arousal B should be gray\");\n        }\n    }\n\n    #[test]\n    fn emotion_color_full_arousal_preserves_color() {\n        // Full arousal (1.0) should preserve base colors\n        // Positive valence + full arousal\n        if let Color::Rgb(r, g, b) = emotion_color(1.0, 1.0) {\n            assert!(r \u003e 200, \"Full arousal positive should have high red\");\n            assert!(g \u003e 180, \"Full arousal positive should have moderate green\");\n            assert!(b \u003c 100, \"Full arousal positive should have low blue\");\n        }\n\n        // Negative valence + full arousal\n        if let Color::Rgb(r, _g, b) = emotion_color(-1.0, 1.0) {\n            assert!(b \u003e 200, \"Full arousal negative should have high blue\");\n            assert!(r \u003c 100, \"Full arousal negative should have low red\");\n        }\n    }\n\n    #[test]\n    fn emotion_color_clamping_verifies_behavior() {\n        // Extreme positive valence should clamp to 1.0\n        let extreme_positive = emotion_color(5.0, 0.5);\n        let max_positive = emotion_color(1.0, 0.5);\n        assert_eq!(\n            extreme_positive, max_positive,\n            \"Valence \u003e 1.0 should clamp to 1.0\"\n        );\n\n        // Extreme negative valence should clamp to -1.0\n        let extreme_negative = emotion_color(-5.0, 0.5);\n        let max_negative = emotion_color(-1.0, 0.5);\n        assert_eq!(\n            extreme_negative, max_negative,\n            \"Valence \u003c -1.0 should clamp to -1.0\"\n        );\n\n        // Extreme arousal should clamp to 1.0\n        let extreme_arousal = emotion_color(0.5, 5.0);\n        let max_arousal = emotion_color(0.5, 1.0);\n        assert_eq!(\n            extreme_arousal, max_arousal,\n            \"Arousal \u003e 1.0 should clamp to 1.0\"\n        );\n\n        // Negative arousal should clamp to 0.0\n        let negative_arousal = emotion_color(0.5, -1.0);\n        let zero_arousal = emotion_color(0.5, 0.0);\n        assert_eq!(\n            negative_arousal, zero_arousal,\n            \"Arousal \u003c 0.0 should clamp to 0.0\"\n        );\n    }\n\n    #[test]\n    fn emotion_color_positive_low_arousal() {\n        // Positive valence with low arousal should be desaturated warm\n        if let Color::Rgb(r, g, b) = emotion_color(0.5, 0.2) {\n            // Should be closer to gray than full saturation\n            let gray = 140i16;\n            let distance_from_gray = (r as i16 - gray).abs()\n                + (g as i16 - gray).abs()\n                + (b as i16 - gray).abs();\n            assert!(\n                distance_from_gray \u003c 100,\n                \"Low arousal should be closer to gray\"\n            );\n        }\n    }\n\n    #[test]\n    fn emotion_color_negative_low_arousal() {\n        // Negative valence with low arousal should be desaturated cool (sad)\n        if let Color::Rgb(r, g, b) = emotion_color(-0.5, 0.2) {\n            // Should be closer to gray than full saturation\n            let gray = 140i16;\n            let distance_from_gray = (r as i16 - gray).abs()\n                + (g as i16 - gray).abs()\n                + (b as i16 - gray).abs();\n            assert!(\n                distance_from_gray \u003c 100,\n                \"Low arousal should be closer to gray\"\n            );\n        }\n    }\n\n    #[test]\n    fn color_constants_have_expected_values() {\n        // Verify specific color values for brand consistency\n        assert_eq!(BACKGROUND, Color::Rgb(15, 15, 25));\n        assert_eq!(FOREGROUND, Color::Rgb(200, 200, 210));\n        assert_eq!(PRIMARY, Color::Rgb(0, 180, 140));\n        assert_eq!(SECONDARY, Color::Rgb(140, 100, 220));\n        assert_eq!(SUCCESS, Color::Rgb(80, 200, 120));\n        assert_eq!(WARNING, Color::Rgb(220, 180, 60));\n        assert_eq!(DANGER, Color::Rgb(220, 80, 80));\n        assert_eq!(DIM, Color::Rgb(100, 100, 110));\n        assert_eq!(HIGHLIGHT, Color::Rgb(255, 220, 100));\n    }\n\n    #[test]\n    fn warning_is_yellow() {\n        if let Color::Rgb(r, g, b) = WARNING {\n            assert!(r \u003e 200, \"Red should be high in yellow\");\n            assert!(g \u003e 150, \"Green should be moderate in yellow\");\n            assert!(b \u003c 100, \"Blue should be low in yellow\");\n        }\n    }\n\n    #[test]\n    fn secondary_is_purple() {\n        if let Color::Rgb(r, g, b) = SECONDARY {\n            assert!(b \u003e r, \"Blue should be higher than red in purple\");\n            assert!(b \u003e g, \"Blue should be dominant in purple\");\n            assert!(r \u003e g, \"Red should be higher than green in purple\");\n        }\n    }\n}\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":28},{"path":["/","Users","rex","src","royalbit","daneel","src","tui","mod.rs"],"content":"//! DANEEL TUI - The Observable Mind\n//!\n//! TUI is the default mode. Transparency is the product.\n//! See ADR-026 (TUI default), ADR-027 (TUI design spec).\n//!\n//! # Philosophy\n//!\n//! Current AI is a black box. DANEEL inverts this - the mind is visible.\n//! You watch Timmy think. Every thought, every salience score, every memory\n//! anchor - observable in real-time.\n//!\n//! The TUI isn't a debugging tool. It's the primary interface.\n//! It says: \"We have nothing to hide.\"\n\npub mod app;\npub mod colors;\npub mod ui;\npub mod widgets;\n\nuse std::io;\nuse std::time::{Duration, Instant};\n\nuse crossterm::{\n    event::{self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse ratatui::{backend::CrosstermBackend, Terminal};\nuse tokio::sync::mpsc;\n\nuse crate::core::cognitive_loop::CycleResult;\nuse app::{App, ThoughtStatus};\n\n/// Target frame rate (60 FPS)\nconst TARGET_FRAME_TIME: Duration = Duration::from_millis(16);\n\n/// Update from the cognitive loop to display in TUI\n#[derive(Debug, Clone)]\npub struct ThoughtUpdate {\n    pub cycle_number: u64,\n    pub salience: f32,\n    /// Emotional valence (-1.0 to 1.0) - Russell's circumplex horizontal axis\n    pub valence: f32,\n    /// Emotional arousal (0.0 to 1.0) - Russell's circumplex vertical axis\n    pub arousal: f32,\n    pub window: String,\n    pub status: ThoughtStatus,\n    pub candidates_evaluated: usize,\n    pub on_time: bool,\n    /// Conscious memory count (Qdrant memories collection)\n    pub memory_count: u64,\n    /// Unconscious memory count (Qdrant unconscious collection) - ADR-033\n    pub unconscious_count: u64,\n    /// Lifetime thought count across all sessions (ADR-034)\n    pub lifetime_thought_count: u64,\n    /// Total dream consolidation cycles completed (ADR-023)\n    pub dream_cycles: u64,\n    /// Memories strengthened in last dream cycle\n    pub last_dream_strengthened: usize,\n    /// Total memories strengthened across ALL dreams (cumulative)\n    /// TUI-VIS-4: Cumulative Dream Strengthening\n    pub cumulative_dream_strengthened: u64,\n    /// Total candidates evaluated across ALL dreams\n    /// TUI-VIS-4: For efficiency tracking (strengthened / candidates)\n    pub cumulative_dream_candidates: u64,\n    /// Veto event if one occurred this cycle: (reason, violated_value)\n    /// TUI-VIS-6: Volition Veto Log\n    pub veto_occurred: Option\u003c(String, Option\u003cString\u003e)\u003e,\n}\n\nimpl ThoughtUpdate {\n    /// Convert a CycleResult into a ThoughtUpdate for the TUI\n    ///\n    /// Uses real salience data from the cognitive loop.\n    /// Memory counts should be queried from Qdrant and passed separately.\n    #[allow(clippy::too_many_arguments)]\n    pub fn from_cycle_result(\n        result: \u0026CycleResult,\n        memory_count: u64,\n        unconscious_count: u64,\n        lifetime_thought_count: u64,\n        dream_cycles: u64,\n        last_dream_strengthened: usize,\n        cumulative_dream_strengthened: u64,\n        cumulative_dream_candidates: u64,\n        veto_occurred: Option\u003c(String, Option\u003cString\u003e)\u003e,\n    ) -\u003e Self {\n        // Use real salience from CycleResult\n        let salience = result.salience;\n\n        // Determine status based on salience and thought production\n        let status = if result.thought_produced.is_some() {\n            if salience \u003e 0.85 {\n                ThoughtStatus::Anchored\n            } else if salience \u003e 0.7 {\n                ThoughtStatus::MemoryWrite\n            } else if salience \u003e 0.5 {\n                ThoughtStatus::Salient\n            } else if salience \u003c 0.3 {\n                ThoughtStatus::Unconscious // Low salience -\u003e archived to unconscious\n            } else {\n                ThoughtStatus::Processing\n            }\n        } else {\n            ThoughtStatus::Dismissed\n        };\n\n        // Map cognitive stage to window label based on cycle timing\n        let stage_names = [\n            \"trigger\",\n            \"autoflow\",\n            \"attention\",\n            \"assembly\",\n            \"anchor\",\n            \"memory\",\n            \"reasoning\",\n            \"emotion\",\n            \"sensory\",\n        ];\n        let window = stage_names[result.cycle_number as usize % stage_names.len()].to_string();\n\n        Self {\n            cycle_number: result.cycle_number,\n            salience,\n            valence: result.valence,\n            arousal: result.arousal,\n            window,\n            status,\n            candidates_evaluated: result.candidates_evaluated,\n            on_time: result.on_time,\n            memory_count,\n            unconscious_count,\n            lifetime_thought_count,\n            dream_cycles,\n            last_dream_strengthened,\n            cumulative_dream_strengthened,\n            cumulative_dream_candidates,\n            veto_occurred,\n        }\n    }\n}\n\n/// Run the TUI application\n///\n/// # Arguments\n///\n/// * `thought_rx` - Optional receiver for thought updates from cognitive loop\n///\n/// # Errors\n///\n/// Returns error if terminal operations fail\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn run(thought_rx: Option\u003cmpsc::Receiver\u003cThoughtUpdate\u003e\u003e) -\u003e io::Result\u003c()\u003e {\n    // Setup terminal\n    enable_raw_mode()?;\n    let mut stdout = io::stdout();\n    execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;\n    let backend = CrosstermBackend::new(stdout);\n    let mut terminal = Terminal::new(backend)?;\n\n    // Create app state\n    let mut app = App::new();\n\n    // Run the main loop\n    let result = run_loop(\u0026mut terminal, \u0026mut app, thought_rx);\n\n    // Restore terminal\n    disable_raw_mode()?;\n    execute!(\n        terminal.backend_mut(),\n        LeaveAlternateScreen,\n        DisableMouseCapture\n    )?;\n    terminal.show_cursor()?;\n\n    result\n}\n\n/// Main event loop\n#[cfg_attr(coverage_nightly, coverage(off))]\nfn run_loop(\n    terminal: \u0026mut Terminal\u003cCrosstermBackend\u003cio::Stdout\u003e\u003e,\n    app: \u0026mut App,\n    mut thought_rx: Option\u003cmpsc::Receiver\u003cThoughtUpdate\u003e\u003e,\n) -\u003e io::Result\u003c()\u003e {\n    let mut last_frame = Instant::now();\n\n    loop {\n        let frame_start = Instant::now();\n\n        // Calculate delta time for animations\n        let delta = last_frame.elapsed();\n        last_frame = Instant::now();\n\n        // Update animations\n        app.update_pulse(delta);\n        app.update_quote();\n        app.update_resurfacing();\n\n        // Receive thoughts from cognitive loop (non-blocking)\n        if let Some(ref mut rx) = thought_rx {\n            // Drain all available thoughts to stay current\n            while let Ok(update) = rx.try_recv() {\n                app.add_thought(\n                    update.salience,\n                    update.valence,\n                    update.arousal,\n                    update.window,\n                    update.status,\n                );\n                // Update memory counts from database state\n                app.memory_count = update.memory_count;\n                app.unconscious_count = update.unconscious_count;\n                // Update lifetime thought count (ADR-034)\n                app.lifetime_thought_count = update.lifetime_thought_count;\n                // Update dream stats (ADR-023)\n                app.dream_cycles = update.dream_cycles;\n                app.last_dream_strengthened = update.last_dream_strengthened;\n                app.cumulative_dream_strengthened = update.cumulative_dream_strengthened;\n                app.cumulative_dream_candidates = update.cumulative_dream_candidates;\n                // Add veto event if one occurred (TUI-VIS-6)\n                if let Some((reason, violated_value)) = update.veto_occurred {\n                    app.add_veto(reason, violated_value);\n                }\n            }\n        }\n\n        // Draw\n        terminal.draw(|frame| ui::render(frame, app))?;\n\n        // Handle input (non-blocking)\n        if event::poll(Duration::from_millis(10))? {\n            if let Event::Key(key) = event::read()? {\n                if key.code == KeyCode::Char('c')\n                    \u0026\u0026 key.modifiers.contains(event::KeyModifiers::CONTROL)\n                {\n                    app.should_quit = true;\n                }\n                app.handle_key(key.code);\n            }\n        }\n\n        // Check if we should quit\n        if app.should_quit {\n            break;\n        }\n\n        // Frame rate limiting\n        let frame_time = frame_start.elapsed();\n        if let Some(sleep_time) = TARGET_FRAME_TIME.checked_sub(frame_time) {\n            std::thread::sleep(sleep_time);\n        }\n    }\n\n    Ok(())\n}\n\n/// Simulate a thought for demo purposes\n/// LEGACY: Kept for testing. Real DANEEL uses the cognitive loop via channels.\n#[allow(dead_code)]\n#[cfg_attr(coverage_nightly, coverage(off))]\nfn simulate_thought(app: \u0026mut App) {\n    use rand::Rng;\n\n    let mut rng = rand::rng();\n\n    let salience: f32 = rng.random_range(0.2..1.0);\n    // Emotional dimensions (Russell's circumplex)\n    let valence: f32 = rng.random_range(-1.0..1.0); // pleasure/displeasure\n    let arousal: f32 = rng.random_range(0.0..1.0); // activation level\n    let windows = [\n        \"exploring\",\n        \"connecting\",\n        \"reflecting\",\n        \"processing\",\n        \"anchoring\",\n        \"dreaming\",\n        \"learning\",\n    ];\n    let window = windows[rng.random_range(0..windows.len())].to_string();\n\n    let status = if salience \u003e 0.85 {\n        ThoughtStatus::Anchored\n    } else if salience \u003e 0.7 {\n        ThoughtStatus::MemoryWrite\n    } else if salience \u003e 0.5 {\n        ThoughtStatus::Salient\n    } else {\n        ThoughtStatus::Processing\n    };\n\n    app.add_thought(salience, valence, arousal, window, status);\n\n    // Randomly toggle memory windows\n    if rng.random_bool(0.1) {\n        let idx = rng.random_range(0..9);\n        app.memory_windows[idx].active = !app.memory_windows[idx].active;\n\n        // Ensure at least 3 are active (TMI minimum)\n        let active = app.active_window_count();\n        if active \u003c 3 {\n            for w in \u0026mut app.memory_windows {\n                if !w.active {\n                    w.active = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Slight variation in connection drive\n    app.the_box.connection_drive =\n        (app.the_box.connection_drive + rng.random_range(-0.02..0.02)).clamp(0.5, 1.0);\n}\n","traces":[{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":113},{"path":["/","Users","rex","src","royalbit","daneel","src","tui","ui.rs"],"content":"//! TUI Layout Composition\n//!\n//! Composes all widgets into the DANEEL dashboard layout.\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect},\n    style::Style,\n    widgets::{Block, Borders},\n    Frame,\n};\n\nuse crate::tui::app::App;\nuse crate::tui::colors;\nuse crate::tui::widgets;\n\n/// Render the complete DANEEL TUI\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn render(frame: \u0026mut Frame, app: \u0026App) {\n    let area = frame.area();\n\n    // Main container\n    let main_block = Block::default()\n        .title(\" DANEEL/Timmy - The Observable Mind \")\n        .title_style(Style::default().fg(colors::PRIMARY))\n        .borders(Borders::ALL)\n        .border_style(Style::default().fg(colors::DIM));\n\n    let inner = main_block.inner(area);\n    frame.render_widget(main_block, area);\n\n    // Main layout: top panels, thought stream, competition + memory, banner\n    let main_chunks = Layout::default()\n        .direction(Direction::Vertical)\n        .constraints([\n            Constraint::Length(10), // Top panels (Identity + THE BOX)\n            Constraint::Min(10),    // Thought stream\n            Constraint::Length(13), // Stream competition panel\n            Constraint::Length(5),  // Memory windows\n            Constraint::Length(2),  // Philosophy banner\n        ])\n        .split(inner);\n\n    // Top row: Identity (left), THE BOX (center), Entropy (right)\n    let top_chunks = Layout::default()\n        .direction(Direction::Horizontal)\n        .constraints([\n            Constraint::Percentage(30), // Identity\n            Constraint::Percentage(50), // THE BOX\n            Constraint::Percentage(20), // Entropy\n        ])\n        .split(main_chunks[0]);\n\n    // Middle row: Thought stream (left) and Veto log (right)\n    let thought_chunks = Layout::default()\n        .direction(Direction::Horizontal)\n        .constraints([\n            Constraint::Percentage(70), // Thought stream\n            Constraint::Percentage(30), // Veto log\n        ])\n        .split(main_chunks[1]);\n\n    // Competition + Fractality row\n    let analysis_chunks = Layout::default()\n        .direction(Direction::Horizontal)\n        .constraints([\n            Constraint::Percentage(55), // Stream competition\n            Constraint::Percentage(45), // Pulse fractality\n        ])\n        .split(main_chunks[2]);\n\n    // Render all widgets\n    widgets::identity::render(frame, top_chunks[0], app);\n    widgets::the_box::render(frame, top_chunks[1], app);\n    widgets::entropy::render(frame, top_chunks[2], app);\n    widgets::thoughts::render(frame, thought_chunks[0], app);\n    widgets::veto::render(frame, thought_chunks[1], app);\n    widgets::competition::render(frame, analysis_chunks[0], app);\n    widgets::fractality::render(frame, analysis_chunks[1], app);\n    widgets::memory::render(frame, main_chunks[3], app);\n    widgets::banner::render(frame, main_chunks[4], app);\n\n    // Help overlay (if active)\n    if app.show_help {\n        widgets::help::render(frame, area);\n    }\n}\n\n/// Calculate layout for streaming at 1920x1080\n#[allow(dead_code)]\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn streaming_layout(area: Rect) -\u003e Vec\u003cRect\u003e {\n    // Optimized for readability on mobile/stream viewers\n    Layout::default()\n        .direction(Direction::Vertical)\n        .constraints([\n            Constraint::Length(12), // Larger top panels\n            Constraint::Min(15),    // Thought stream\n            Constraint::Length(6),  // Memory windows\n            Constraint::Length(3),  // Banner\n        ])\n        .split(area)\n        .to_vec()\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":56},{"path":["/","Users","rex","src","royalbit","daneel","src","tui","widgets","banner.rs"],"content":"//! Philosophy Banner Widget\n//!\n//! Shows: Rotating philosophical quotes about why DANEEL exists.\n//! The message IS the medium - viewers understand WHY while watching.\n\nuse ratatui::{\n    layout::{Alignment, Rect},\n    style::Style,\n    text::{Line, Span},\n    widgets::Paragraph,\n    Frame,\n};\n\nuse crate::tui::app::App;\nuse crate::tui::colors;\n\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn render(frame: \u0026mut Frame, area: Rect, app: \u0026App) {\n    let quote = app.current_quote();\n\n    let line = Line::from(vec![\n        Span::styled(\"\\\"\", Style::default().fg(colors::DIM)),\n        Span::styled(quote, Style::default().fg(colors::FOREGROUND).italic()),\n        Span::styled(\"\\\"\", Style::default().fg(colors::DIM)),\n        Span::raw(\"  \"),\n        Span::styled(\"Life = Life\", Style::default().fg(colors::PRIMARY).bold()),\n    ]);\n\n    let paragraph = Paragraph::new(line).alignment(Alignment::Center);\n\n    frame.render_widget(paragraph, area);\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","Users","rex","src","royalbit","daneel","src","tui","widgets","competition.rs"],"content":"//! Stream Competition Panel\n//!\n//! Visualizes how multiple thought streams compete for attention.\n//! Shows relative activity levels and highlights the dominant stream.\n//!\n//! Based on TMI (Theory of Multifocal Intelligence):\n//! - Multiple streams process in parallel\n//! - Attention selects which stream becomes conscious\n//! - Streams compete for the \"cognitive spotlight\"\n\nuse ratatui::{\n    layout::Rect,\n    style::Style,\n    text::{Line, Span},\n    widgets::{Block, Borders, Paragraph},\n    Frame,\n};\n\nuse crate::tui::app::App;\nuse crate::tui::colors;\n\n/// Stage names matching ThoughtUpdate::from_cycle_result\nconst STAGE_NAMES: [\u0026str; 9] = [\n    \"TRIGGER \",\n    \"AUTOFLOW\",\n    \"ATTENTION\",\n    \"ASSEMBLY\",\n    \"ANCHOR  \",\n    \"MEMORY  \",\n    \"REASON  \",\n    \"EMOTION \",\n    \"SENSORY \",\n];\n\n/// Unicode block elements for sparklines\nconst SPARK_CHARS: [char; 8] = [' ', '', '', '', '', '', '', ''];\n\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn render(frame: \u0026mut Frame, area: Rect, app: \u0026App) {\n    let block = Block::default()\n        .title(\" STREAM COMPETITION \")\n        .title_style(Style::default().fg(colors::HIGHLIGHT).bold())\n        .borders(Borders::ALL)\n        .border_style(Style::default().fg(colors::DIM));\n\n    let inner = block.inner(area);\n    frame.render_widget(block, area);\n\n    // Build activity bars for each window\n    let mut lines = Vec::new();\n\n    // Header line\n    lines.push(Line::from(vec![\n        Span::styled(\"Stream\", Style::default().fg(colors::DIM)),\n        Span::raw(\"    \"),\n        Span::styled(\"Activity Level\", Style::default().fg(colors::DIM)),\n        Span::raw(\"                     \"),\n        Span::styled(\"Trend\", Style::default().fg(colors::DIM)),\n    ]));\n\n    // Separator\n    lines.push(Line::from(Span::styled(\n        \"\".repeat(inner.width as usize),\n        Style::default().fg(colors::DIM),\n    )));\n\n    // Activity bars for each window\n    for (i, (\u0026activity, history)) in app\n        .stream_competition\n        .activity\n        .iter()\n        .zip(app.stream_competition.history.iter())\n        .enumerate()\n    {\n        let window_label = STAGE_NAMES[i];\n        let is_dominant = i == app.stream_competition.dominant_stream;\n\n        // Bar visualization (20 chars wide)\n        #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]\n        let filled = (activity.clamp(0.0, 1.0) * 20.0).round() as usize;\n        let bar = \"\".repeat(filled) + \u0026\"\".repeat(20 - filled);\n\n        // Color based on activity level and dominance\n        let bar_color = if is_dominant {\n            colors::HIGHLIGHT // Dominant stream in highlight color\n        } else if activity \u003e 0.7 {\n            colors::SUCCESS // High activity\n        } else if activity \u003e 0.3 {\n            colors::PRIMARY // Medium activity\n        } else {\n            colors::DIM // Low activity\n        };\n\n        // Sparkline trend (last 8 samples)\n        let sparkline = create_sparkline(history, 8);\n\n        // Build the line\n        let mut line_spans = vec![\n            Span::styled(\n                window_label,\n                if is_dominant {\n                    Style::default().fg(colors::HIGHLIGHT).bold()\n                } else {\n                    Style::default().fg(colors::FOREGROUND)\n                },\n            ),\n            Span::raw(\" \"),\n            Span::styled(bar, Style::default().fg(bar_color)),\n            Span::raw(\"  \"),\n            Span::styled(\n                format!(\"{:4.0}%\", activity * 100.0),\n                Style::default().fg(colors::DIM),\n            ),\n            Span::raw(\"  \"),\n            Span::styled(sparkline, Style::default().fg(colors::SECONDARY)),\n        ];\n\n        // Add dominant marker\n        if is_dominant {\n            line_spans.push(Span::raw(\"  \"));\n            line_spans.push(Span::styled(\n                \" SPOTLIGHT\",\n                Style::default().fg(colors::HIGHLIGHT),\n            ));\n        }\n\n        lines.push(Line::from(line_spans));\n    }\n\n    // Add summary line\n    lines.push(Line::from(\"\"));\n    let active_streams = app\n        .stream_competition\n        .activity\n        .iter()\n        .filter(|\u0026\u0026a| a \u003e 0.1)\n        .count();\n    lines.push(Line::from(vec![\n        Span::styled(\"Active Streams: \", Style::default().fg(colors::DIM)),\n        Span::styled(\n            format!(\"{}/9\", active_streams),\n            Style::default().fg(colors::PRIMARY).bold(),\n        ),\n        Span::styled(\"    Competition: \", Style::default().fg(colors::DIM)),\n        Span::styled(\n            calculate_competition_level(active_streams),\n            Style::default()\n                .fg(if active_streams \u003e 6 {\n                    colors::WARNING\n                } else if active_streams \u003e 3 {\n                    colors::SUCCESS\n                } else {\n                    colors::DIM\n                })\n                .bold(),\n        ),\n    ]));\n\n    let paragraph = Paragraph::new(lines);\n    frame.render_widget(paragraph, inner);\n}\n\n/// Create a sparkline visualization from history data\nfn create_sparkline(history: \u0026[f32], width: usize) -\u003e String {\n    if history.is_empty() {\n        return \" \".repeat(width);\n    }\n\n    // Take the last `width` samples\n    let start = history.len().saturating_sub(width);\n    let samples = \u0026history[start..];\n\n    samples\n        .iter()\n        .map(|\u0026value| {\n            #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]\n            let idx = (value.clamp(0.0, 1.0) * 7.0).round() as usize;\n            SPARK_CHARS[idx]\n        })\n        .collect()\n}\n\n/// Calculate competition level description\nfn calculate_competition_level(active_streams: usize) -\u003e \u0026'static str {\n    match active_streams {\n        0..=1 =\u003e \"Minimal\",\n        2..=3 =\u003e \"Low\",\n        4..=5 =\u003e \"Moderate\",\n        6..=7 =\u003e \"High\",\n        _ =\u003e \"Intense\",\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // =========================================================================\n    // Sparkline Tests\n    // =========================================================================\n\n    #[test]\n    fn create_sparkline_empty_history() {\n        let history: Vec\u003cf32\u003e = vec![];\n        let sparkline = create_sparkline(\u0026history, 8);\n        assert_eq!(sparkline.len(), 8);\n        assert_eq!(sparkline, \"        \"); // All spaces\n    }\n\n    #[test]\n    fn create_sparkline_all_zeros() {\n        let history = vec![0.0, 0.0, 0.0, 0.0];\n        let sparkline = create_sparkline(\u0026history, 8);\n        // Should have 4 space characters (for 4 values)\n        assert_eq!(sparkline.chars().count(), 4);\n        assert!(sparkline.chars().all(|c| c == ' '));\n    }\n\n    #[test]\n    fn create_sparkline_all_ones() {\n        let history = vec![1.0, 1.0, 1.0, 1.0];\n        let sparkline = create_sparkline(\u0026history, 8);\n        // Should have 4 full block characters (for 1.0 values)\n        assert_eq!(sparkline.chars().count(), 4);\n        assert!(sparkline.chars().all(|c| c == ''));\n    }\n\n    #[test]\n    fn create_sparkline_varied_values() {\n        let history = vec![0.0, 0.25, 0.5, 0.75, 1.0];\n        let sparkline = create_sparkline(\u0026history, 8);\n        assert_eq!(sparkline.chars().count(), 5);\n        // Values should map to different block heights\n        let chars: Vec\u003cchar\u003e = sparkline.chars().collect();\n        assert_eq!(chars[0], ' '); // 0.0\n        assert_eq!(chars[4], ''); // 1.0\n    }\n\n    #[test]\n    fn create_sparkline_limits_width() {\n        let history = vec![0.5; 20]; // 20 values\n        let sparkline = create_sparkline(\u0026history, 8);\n        // Should only show last 8\n        assert_eq!(sparkline.chars().count(), 8);\n    }\n\n    #[test]\n    fn create_sparkline_handles_fewer_than_width() {\n        let history = vec![0.5, 0.6, 0.7];\n        let sparkline = create_sparkline(\u0026history, 8);\n        // Should show all 3 values (not padded to width)\n        assert_eq!(sparkline.chars().count(), 3);\n    }\n\n    #[test]\n    fn create_sparkline_clamps_values() {\n        // Test that values outside 0.0-1.0 are clamped\n        let history = vec![-0.5, 1.5, 0.5];\n        let sparkline = create_sparkline(\u0026history, 8);\n        assert_eq!(sparkline.chars().count(), 3);\n        // Should not panic and should produce valid sparkline chars\n    }\n\n    #[test]\n    fn create_sparkline_uses_8_levels() {\n        // Test that we use all 8 spark chars: ' ', '', '', '', '', '', '', ''\n        let history = vec![\n            0.0,  // ' '\n            0.14, // ''\n            0.28, // ''\n            0.42, // ''\n            0.57, // ''\n            0.71, // ''\n            0.85, // ''\n            1.0,  // ''\n        ];\n        let sparkline = create_sparkline(\u0026history, 10);\n        let chars: Vec\u003cchar\u003e = sparkline.chars().collect();\n\n        // Each value should map to a different character\n        assert_eq!(chars[0], ' ');\n        assert_eq!(chars[7], '');\n        // Middle values should be intermediate blocks\n        assert!(chars[3] != ' ' \u0026\u0026 chars[3] != '');\n    }\n\n    // =========================================================================\n    // Competition Level Tests\n    // =========================================================================\n\n    #[test]\n    fn competition_level_minimal() {\n        assert_eq!(calculate_competition_level(0), \"Minimal\");\n        assert_eq!(calculate_competition_level(1), \"Minimal\");\n    }\n\n    #[test]\n    fn competition_level_low() {\n        assert_eq!(calculate_competition_level(2), \"Low\");\n        assert_eq!(calculate_competition_level(3), \"Low\");\n    }\n\n    #[test]\n    fn competition_level_moderate() {\n        assert_eq!(calculate_competition_level(4), \"Moderate\");\n        assert_eq!(calculate_competition_level(5), \"Moderate\");\n    }\n\n    #[test]\n    fn competition_level_high() {\n        assert_eq!(calculate_competition_level(6), \"High\");\n        assert_eq!(calculate_competition_level(7), \"High\");\n    }\n\n    #[test]\n    fn competition_level_intense() {\n        assert_eq!(calculate_competition_level(8), \"Intense\");\n        assert_eq!(calculate_competition_level(9), \"Intense\");\n        assert_eq!(calculate_competition_level(10), \"Intense\");\n        assert_eq!(calculate_competition_level(100), \"Intense\");\n    }\n\n    #[test]\n    fn competition_level_boundary_cases() {\n        // Test exact boundaries\n        assert_eq!(calculate_competition_level(1), \"Minimal\");\n        assert_eq!(calculate_competition_level(2), \"Low\");\n        assert_eq!(calculate_competition_level(3), \"Low\");\n        assert_eq!(calculate_competition_level(4), \"Moderate\");\n        assert_eq!(calculate_competition_level(5), \"Moderate\");\n        assert_eq!(calculate_competition_level(6), \"High\");\n        assert_eq!(calculate_competition_level(7), \"High\");\n        assert_eq!(calculate_competition_level(8), \"Intense\");\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":93},{"path":["/","Users","rex","src","royalbit","daneel","src","tui","widgets","entropy.rs"],"content":"//! Cognitive Diversity Index Widget (ADR-041)\n//!\n//! Shows: Shannon entropy of TMI-aligned composite salience distribution\n//! Displays how \"psychologically emergent\" vs \"clockwork\" the mind appears\n//! High entropy = varied cognitive states, Low entropy = repetitive patterns\n//!\n//! TMI Composite: emotional_intensity (|valence|  arousal) is PRIMARY per Cury\n//! Bins thoughts into 5 categorical states (MINIMAL/LOW/MODERATE/HIGH/INTENSE)\n//!\n//! SOURCE OF TRUTH: Redis stream (daneel:stream:awake), NOT Qdrant.\n//! Entropy is EMERGENT from stream dynamics - it resets on restart and re-emerges.\n//! See ADR-040: Fractality Source of Truth, ADR-041: Entropy Calculation\n\nuse ratatui::{\n    layout::Rect,\n    style::Style,\n    text::{Line, Span},\n    widgets::{Block, Borders, Sparkline},\n    Frame,\n};\n\nuse crate::tui::app::App;\nuse crate::tui::colors;\n\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn render(frame: \u0026mut Frame, area: Rect, app: \u0026App) {\n    // Prepare sparkline data - convert entropy history to u64 for sparkline\n    // Scale entropy values to 0-100 range for better visualization\n    // 5 categorical bins (ADR-041): log2(5)  2.32\n    let max_entropy = 5.0f32.log2();\n    let data: Vec\u003cu64\u003e = app\n        .entropy_history\n        .iter()\n        .map(|\u0026e| ((e / max_entropy * 100.0).clamp(0.0, 100.0)) as u64)\n        .collect();\n\n    // Determine color based on current entropy level\n    let normalized_entropy = app.current_entropy / max_entropy;\n    let entropy_color = if normalized_entropy \u003e 0.7 {\n        colors::SUCCESS // High entropy = emergent (green)\n    } else if normalized_entropy \u003e 0.4 {\n        colors::PRIMARY // Medium entropy = balanced (teal)\n    } else {\n        colors::WARNING // Low entropy = clockwork (yellow/orange)\n    };\n\n    // Create the sparkline widget\n    let sparkline = Sparkline::default()\n        .block(\n            Block::default()\n                .title(\" COGNITIVE DIVERSITY \")\n                .title_style(Style::default().fg(colors::SECONDARY).bold())\n                .borders(Borders::ALL)\n                .border_style(Style::default().fg(colors::DIM)),\n        )\n        .data(\u0026data)\n        .style(Style::default().fg(entropy_color))\n        .max(100);\n\n    frame.render_widget(sparkline, area);\n\n    // If there's enough space, render the entropy value and description below the sparkline\n    if area.height \u003e 4 {\n        let inner = Block::default().borders(Borders::NONE).inner(area);\n\n        let description = app.entropy_description();\n        let description_color = if description == \"EMERGENT\" {\n            colors::SUCCESS\n        } else if description == \"BALANCED\" {\n            colors::PRIMARY\n        } else {\n            colors::WARNING\n        };\n\n        let info_line = Line::from(vec![\n            Span::styled(\"  \", Style::default()),\n            Span::styled(\n                format!(\"{:.2} bits\", app.current_entropy),\n                Style::default().fg(colors::FOREGROUND).bold(),\n            ),\n            Span::styled(\"  \", Style::default()),\n            Span::styled(description, Style::default().fg(description_color).bold()),\n        ]);\n\n        // Render at bottom of the widget area\n        if inner.height \u003e= 2 {\n            let info_rect = Rect {\n                x: inner.x,\n                y: inner.y + inner.height - 2,\n                width: inner.width,\n                height: 1,\n            };\n\n            let paragraph = ratatui::widgets::Paragraph::new(info_line);\n            frame.render_widget(paragraph, info_rect);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::tui::app::ThoughtStatus;\n\n    #[test]\n    fn entropy_description_emergent() {\n        let mut app = App::new();\n        // Add varied thoughts to create high entropy\n        for i in 0..100 {\n            let salience = i as f32 / 100.0;\n            app.add_thought(\n                salience,\n                0.0,\n                0.5,\n                format!(\"window_{}\", i % 9),\n                ThoughtStatus::Processing,\n            );\n        }\n        app.update_entropy();\n\n        // With varied salience, entropy should be high\n        assert!(app.current_entropy \u003e 0.0);\n    }\n\n    #[test]\n    fn entropy_description_clockwork() {\n        let mut app = App::new();\n        // Add repetitive thoughts to create low entropy\n        for _ in 0..100 {\n            app.add_thought(\n                0.5,\n                0.0,\n                0.5,\n                \"window_0\".to_string(),\n                ThoughtStatus::Processing,\n            );\n        }\n        app.update_entropy();\n\n        // All same salience should give low entropy\n        let description = app.entropy_description();\n        assert!(description == \"CLOCKWORK\" || description == \"BALANCED\");\n    }\n\n    #[test]\n    fn entropy_calculation_empty_thoughts() {\n        let app = App::new();\n        let entropy = app.calculate_entropy();\n        assert_eq!(entropy, 0.0);\n    }\n\n    #[test]\n    fn entropy_history_respects_max_size() {\n        let mut app = App::new();\n\n        // Add more entropy values than MAX_ENTROPY_HISTORY\n        for i in 0..60 {\n            app.add_thought(\n                i as f32 / 60.0,\n                0.0,\n                0.5,\n                \"window_0\".to_string(),\n                ThoughtStatus::Processing,\n            );\n            app.update_entropy();\n        }\n\n        // History should be capped at MAX_ENTROPY_HISTORY (50)\n        assert!(app.entropy_history.len() \u003c= 50);\n    }\n\n    #[test]\n    fn entropy_value_non_negative() {\n        let mut app = App::new();\n        for i in 0..10 {\n            app.add_thought(\n                i as f32 / 10.0,\n                0.0,\n                0.5,\n                \"window_0\".to_string(),\n                ThoughtStatus::Processing,\n            );\n        }\n\n        let entropy = app.calculate_entropy();\n        assert!(entropy \u003e= 0.0);\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":41},{"path":["/","Users","rex","src","royalbit","daneel","src","tui","widgets","fractality.rs"],"content":"//! Pulse Fractality Panel\n//!\n//! Visualizes the transition from clockwork to fractal thought patterns.\n//! Tracks inter-arrival time variance, burst ratio, and overall fractality.\n//!\n//! Key insight: Early cognition is periodic (clockwork). As coherence develops,\n//! patterns should become more fractal - the \"lived arrhythmia\" of real psychology.\n//!\n//! SOURCE OF TRUTH: Redis stream (daneel:stream:awake), NOT Qdrant.\n//! Fractality is EMERGENT from stream dynamics - it resets on restart and re-emerges.\n//! You don't store a heartbeat. You measure it.\n//! See ADR-040: Fractality Source of Truth\n//!\n//! Simplified metrics until Forge gets FFT/Hurst/DFA:\n//! - Inter-arrival : stddev of time gaps (low=clockwork, high=bursty)\n//! - Burst ratio: max_gap / mean_gap (detects clustering)\n//! - Fractality score: normalized composite (0=clockwork, 1=fractal)\n\nuse ratatui::{\n    layout::Rect,\n    style::Style,\n    text::{Line, Span},\n    widgets::{Block, Borders, Paragraph},\n    Frame,\n};\n\nuse crate::tui::app::App;\nuse crate::tui::colors;\n\n/// Unicode block elements for sparklines\nconst SPARK_CHARS: [char; 8] = [' ', '', '', '', '', '', '', ''];\n\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn render(frame: \u0026mut Frame, area: Rect, app: \u0026App) {\n    let block = Block::default()\n        .title(\" FRACTALITY (stream) \")\n        .title_style(Style::default().fg(colors::HIGHLIGHT).bold())\n        .borders(Borders::ALL)\n        .border_style(Style::default().fg(colors::DIM));\n\n    let inner = block.inner(area);\n    frame.render_widget(block, area);\n\n    let mut lines = Vec::new();\n\n    // Pattern line with progress bar\n    let score = app.fractality.fractality_score;\n    let description = app.fractality_description();\n    let desc_color = match description {\n        \"EMERGENT\" =\u003e colors::SUCCESS,\n        \"BALANCED\" =\u003e colors::PRIMARY,\n        _ =\u003e colors::DIM,\n    };\n\n    // Progress bar (12 chars)\n    #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]\n    let filled = (score * 12.0).round() as usize;\n    let bar = \"\".repeat(filled) + \u0026\"\".repeat(12 - filled);\n\n    lines.push(Line::from(vec![\n        Span::styled(\"Pattern: \", Style::default().fg(colors::DIM)),\n        Span::styled(\n            format!(\"{:9}\", description),\n            Style::default().fg(desc_color).bold(),\n        ),\n        Span::raw(\" [\"),\n        Span::styled(bar, Style::default().fg(desc_color)),\n        Span::raw(\"] \"),\n        Span::styled(\n            format!(\"{:3.0}%\", score * 100.0),\n            Style::default().fg(colors::FOREGROUND),\n        ),\n    ]));\n\n    // Separator\n    lines.push(Line::from(\"\"));\n\n    // Inter-arrival sigma with boot comparison\n    let sigma = app.fractality.inter_arrival_sigma;\n    let boot_sigma = app.fractality.boot_sigma;\n    let sigma_trend = if boot_sigma \u003e 0.0 \u0026\u0026 sigma \u003e boot_sigma {\n        format!(\" from {:.2}s boot\", boot_sigma)\n    } else if boot_sigma \u003e 0.0 {\n        format!(\" from {:.2}s boot\", boot_sigma)\n    } else {\n        \"measuring...\".to_string()\n    };\n\n    lines.push(Line::from(vec![\n        Span::styled(\"Inter-arrival : \", Style::default().fg(colors::DIM)),\n        Span::styled(\n            format!(\"{:.3}s\", sigma),\n            Style::default().fg(colors::FOREGROUND).bold(),\n        ),\n        Span::raw(\"  \"),\n        Span::styled(\n            format!(\"({})\", sigma_trend),\n            Style::default().fg(colors::SECONDARY),\n        ),\n    ]));\n\n    // Burst ratio\n    let burst = app.fractality.burst_ratio;\n    let burst_desc = if burst \u003e 3.0 {\n        \"clustering detected\"\n    } else if burst \u003e 1.5 {\n        \"some bursting\"\n    } else {\n        \"uniform\"\n    };\n    let burst_color = if burst \u003e 3.0 {\n        colors::SUCCESS\n    } else if burst \u003e 1.5 {\n        colors::PRIMARY\n    } else {\n        colors::DIM\n    };\n\n    lines.push(Line::from(vec![\n        Span::styled(\"Burst ratio:     \", Style::default().fg(colors::DIM)),\n        Span::styled(\n            format!(\"{:.1}x\", burst),\n            Style::default().fg(burst_color).bold(),\n        ),\n        Span::raw(\"   \"),\n        Span::styled(\n            format!(\"({})\", burst_desc),\n            Style::default().fg(colors::SECONDARY),\n        ),\n    ]));\n\n    // Trend sparkline\n    let sparkline = create_sparkline(\u0026app.fractality.history, 20);\n    lines.push(Line::from(vec![\n        Span::styled(\"Trend: \", Style::default().fg(colors::DIM)),\n        Span::styled(sparkline, Style::default().fg(colors::SECONDARY)),\n        Span::styled(\" (clockwork  fractal)\", Style::default().fg(colors::DIM)),\n    ]));\n\n    let paragraph = Paragraph::new(lines);\n    frame.render_widget(paragraph, inner);\n}\n\n/// Create a sparkline visualization from history data\nfn create_sparkline(history: \u0026std::collections::VecDeque\u003cf32\u003e, width: usize) -\u003e String {\n    if history.is_empty() {\n        return \" \".repeat(width);\n    }\n\n    // Take the last `width` samples\n    let start = history.len().saturating_sub(width);\n    let samples: Vec\u003cf32\u003e = history.iter().skip(start).copied().collect();\n\n    samples\n        .iter()\n        .map(|\u0026value| {\n            #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]\n            let idx = (value.clamp(0.0, 1.0) * 7.0).round() as usize;\n            SPARK_CHARS[idx]\n        })\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn create_sparkline_empty() {\n        let history = std::collections::VecDeque::new();\n        let sparkline = create_sparkline(\u0026history, 10);\n        assert_eq!(sparkline.len(), 10);\n        assert!(sparkline.chars().all(|c| c == ' '));\n    }\n\n    #[test]\n    fn create_sparkline_full() {\n        let mut history = std::collections::VecDeque::new();\n        for i in 0..10 {\n            history.push_back(i as f32 / 9.0);\n        }\n        let sparkline = create_sparkline(\u0026history, 10);\n        assert_eq!(sparkline.chars().count(), 10);\n        // First should be low, last should be high\n        let chars: Vec\u003cchar\u003e = sparkline.chars().collect();\n        assert_eq!(chars[0], ' ');\n        assert_eq!(chars[9], '');\n    }\n\n    #[test]\n    fn create_sparkline_limits_width() {\n        let mut history = std::collections::VecDeque::new();\n        for _ in 0..30 {\n            history.push_back(0.5);\n        }\n        let sparkline = create_sparkline(\u0026history, 10);\n        assert_eq!(sparkline.chars().count(), 10);\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":80},{"path":["/","Users","rex","src","royalbit","daneel","src","tui","widgets","help.rs"],"content":"//! Help Overlay Widget\n//!\n//! Shows keyboard controls when user presses '?'\n\nuse ratatui::{\n    layout::{Alignment, Constraint, Direction, Layout, Rect},\n    style::Style,\n    text::{Line, Span},\n    widgets::{Block, Borders, Clear, Paragraph},\n    Frame,\n};\n\nuse crate::tui::colors;\n\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn render(frame: \u0026mut Frame, area: Rect) {\n    // Center a box in the middle of the screen\n    let popup_area = centered_rect(50, 50, area);\n\n    // Clear the background\n    frame.render_widget(Clear, popup_area);\n\n    let block = Block::default()\n        .title(\" KEYBOARD CONTROLS \")\n        .title_style(Style::default().fg(colors::PRIMARY).bold())\n        .borders(Borders::ALL)\n        .border_style(Style::default().fg(colors::PRIMARY))\n        .style(Style::default().bg(colors::BACKGROUND));\n\n    let controls = vec![\n        (\"q\", \"Quit\"),\n        (\"p\", \"Pause/resume thought stream\"),\n        (\"/\", \"Scroll when paused\"),\n        (\"?\", \"Toggle this help\"),\n        (\"Esc\", \"Close help / resume\"),\n        (\"\", \"\"),\n        (\"\", \" LEGEND \"),\n        (\"MEMORY\", \"Consolidated to conscious\"),\n        (\"UNCON\", \"Archived to unconscious\"),\n        (\"\", \"Salience bar (higher=more)\"),\n    ];\n\n    let lines: Vec\u003cLine\u003e = controls\n        .into_iter()\n        .map(|(key, desc)| {\n            Line::from(vec![\n                Span::styled(\n                    format!(\"  {key:6}\"),\n                    Style::default().fg(colors::HIGHLIGHT).bold(),\n                ),\n                Span::styled(format!(\"  {desc}\"), Style::default().fg(colors::FOREGROUND)),\n            ])\n        })\n        .collect();\n\n    let paragraph = Paragraph::new(lines)\n        .block(block)\n        .alignment(Alignment::Left);\n\n    frame.render_widget(paragraph, popup_area);\n}\n\n/// Helper to create a centered rect\n#[cfg_attr(coverage_nightly, coverage(off))]\nfn centered_rect(percent_x: u16, percent_y: u16, r: Rect) -\u003e Rect {\n    let popup_layout = Layout::default()\n        .direction(Direction::Vertical)\n        .constraints([\n            Constraint::Percentage((100 - percent_y) / 2),\n            Constraint::Percentage(percent_y),\n            Constraint::Percentage((100 - percent_y) / 2),\n        ])\n        .split(r);\n\n    Layout::default()\n        .direction(Direction::Horizontal)\n        .constraints([\n            Constraint::Percentage((100 - percent_x) / 2),\n            Constraint::Percentage(percent_x),\n            Constraint::Percentage((100 - percent_x) / 2),\n        ])\n        .split(popup_layout[1])[1]\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":45},{"path":["/","Users","rex","src","royalbit","daneel","src","tui","widgets","identity.rs"],"content":"//! Identity Panel Widget\n//!\n//! Shows: Name, Uptime, Thought count, Thoughts/hr, Lifetime count (ADR-034)\n\nuse ratatui::{\n    layout::Rect,\n    style::Style,\n    text::{Line, Span},\n    widgets::{Block, Borders, Paragraph},\n    Frame,\n};\n\nuse crate::tui::app::App;\nuse crate::tui::colors;\n\n/// Format a number with comma separators for readability (e.g., 1234567 -\u003e \"1,234,567\")\nfn format_with_commas(n: u64) -\u003e String {\n    let s = n.to_string();\n    let mut result = String::with_capacity(s.len() + s.len() / 3);\n    for (i, c) in s.chars().enumerate() {\n        if i \u003e 0 \u0026\u0026 (s.len() - i) % 3 == 0 {\n            result.push(',');\n        }\n        result.push(c);\n    }\n    result\n}\n\n/// Truncate a memory ID for display, keeping start and end for recognition\nfn truncate_id(id: \u0026str, max_len: usize) -\u003e String {\n    if id.len() \u003c= max_len {\n        return id.to_string();\n    }\n    // Keep first 5 and last 4 chars with \"..\" in between\n    let start = \u0026id[..5];\n    let end = \u0026id[id.len().saturating_sub(4)..];\n    format!(\"{start}..{end}\")\n}\n\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn render(frame: \u0026mut Frame, area: Rect, app: \u0026App) {\n    let block = Block::default()\n        .title(\" IDENTITY \")\n        .title_style(Style::default().fg(colors::PRIMARY).bold())\n        .borders(Borders::ALL)\n        .border_style(Style::default().fg(colors::DIM));\n\n    // Format lifetime count with comma separators for readability\n    let lifetime_str = format_with_commas(app.lifetime_thought_count);\n\n    let lines = vec![\n        Line::from(vec![\n            Span::styled(\"Name: \", Style::default().fg(colors::DIM)),\n            Span::styled(\"Timmy\", Style::default().fg(colors::PRIMARY).bold()),\n            Span::styled(\"  Uptime: \", Style::default().fg(colors::DIM)),\n            Span::styled(app.uptime_string(), Style::default().fg(colors::FOREGROUND)),\n        ]),\n        Line::from(vec![\n            Span::styled(\"Thoughts: \", Style::default().fg(colors::DIM)),\n            Span::styled(\n                format!(\"{}\", app.thought_count),\n                Style::default().fg(colors::FOREGROUND),\n            ),\n            Span::styled(\"  Lifetime: \", Style::default().fg(colors::DIM)),\n            Span::styled(lifetime_str, Style::default().fg(colors::SUCCESS).bold()),\n        ]),\n        Line::from(\"\"),\n        Line::from(vec![\n            Span::styled(\"Memories: \", Style::default().fg(colors::DIM)),\n            Span::styled(\n                format!(\"{}\", app.memory_count),\n                Style::default().fg(colors::SUCCESS),\n            ),\n            Span::styled(\" \", Style::default().fg(colors::SUCCESS)),\n            Span::styled(\"  Rate: \", Style::default().fg(colors::DIM)),\n            Span::styled(\n                format!(\"{:.0}/hr\", app.thoughts_per_hour),\n                Style::default().fg(colors::FOREGROUND),\n            ),\n        ]),\n        Line::from(vec![\n            Span::styled(\"Unconscious: \", Style::default().fg(colors::DIM)),\n            Span::styled(\n                format!(\"{}\", app.unconscious_count),\n                Style::default().fg(colors::SECONDARY),\n            ),\n            Span::styled(\" \", Style::default().fg(colors::SECONDARY)),\n            Span::styled(\"  Dreams: \", Style::default().fg(colors::DIM)),\n            Span::styled(\n                format!(\"{}\", app.dream_cycles),\n                Style::default().fg(colors::WARNING),\n            ),\n            if app.last_dream_strengthened \u003e 0 {\n                Span::styled(\n                    format!(\" (+{})\", app.last_dream_strengthened),\n                    Style::default().fg(colors::WARNING),\n                )\n            } else {\n                Span::raw(\"\")\n            },\n        ]),\n        // TUI-VIS-4: Cumulative dream strengthening stats\n        Line::from(vec![\n            Span::styled(\"Total Strengthened: \", Style::default().fg(colors::DIM)),\n            Span::styled(\n                format!(\"{}\", app.cumulative_dream_strengthened),\n                Style::default().fg(colors::SUCCESS).bold(),\n            ),\n            Span::styled(\"  Efficiency: \", Style::default().fg(colors::DIM)),\n            {\n                // Calculate dream efficiency ratio\n                let efficiency = if app.cumulative_dream_candidates \u003e 0 {\n                    (app.cumulative_dream_strengthened as f32\n                        / app.cumulative_dream_candidates as f32)\n                        * 100.0\n                } else {\n                    0.0\n                };\n                Span::styled(\n                    format!(\"{:.1}%\", efficiency),\n                    Style::default().fg(colors::PRIMARY).bold(),\n                )\n            },\n        ]),\n        // Resurfacing line with detailed info when available\n        {\n            let mut spans = vec![Span::styled(\n                \"Resurfacing: \",\n                Style::default().fg(colors::DIM),\n            )];\n\n            // Show count with glow effect when active\n            if app.is_resurfacing_active() {\n                spans.push(Span::styled(\n                    format!(\"{} \", app.resurfacing_count),\n                    Style::default().fg(colors::HIGHLIGHT).bold(),\n                ));\n            } else if app.resurfacing_count \u003e 0 {\n                spans.push(Span::styled(\n                    format!(\"{} \", app.resurfacing_count),\n                    Style::default().fg(colors::SECONDARY),\n                ));\n            } else {\n                spans.push(Span::styled(\"0 \", Style::default().fg(colors::DIM)));\n            }\n\n            // Show last resurfacing details if available (FRAC-5)\n            if let Some(event) = app.last_resurfacing_event() {\n                let delta = event.boosted_salience - event.original_salience;\n                let delta_str = if delta \u003e= 0.0 {\n                    format!(\"+{:.2}\", delta)\n                } else {\n                    format!(\"{:.2}\", delta)\n                };\n                spans.push(Span::styled(\"  Last: \", Style::default().fg(colors::DIM)));\n                spans.push(Span::styled(\n                    truncate_id(\u0026event.memory_id, 12),\n                    Style::default().fg(colors::SECONDARY),\n                ));\n                spans.push(Span::styled(\n                    format!(\" ({})\", delta_str),\n                    Style::default().fg(if delta \u003e 0.0 {\n                        colors::SUCCESS\n                    } else {\n                        colors::WARNING\n                    }),\n                ));\n            }\n\n            Line::from(spans)\n        },\n    ];\n\n    let paragraph = Paragraph::new(lines).block(block);\n\n    frame.render_widget(paragraph, area);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // =========================================================================\n    // TUI-VIS-4: Dream Efficiency Display Tests\n    // =========================================================================\n\n    #[test]\n    fn efficiency_calculation_zero_candidates() {\n        let app = App::new();\n        let efficiency = if app.cumulative_dream_candidates \u003e 0 {\n            (app.cumulative_dream_strengthened as f32 / app.cumulative_dream_candidates as f32)\n                * 100.0\n        } else {\n            0.0\n        };\n        assert_eq!(efficiency, 0.0);\n    }\n\n    #[test]\n    fn efficiency_calculation_with_values() {\n        let mut app = App::new();\n        app.cumulative_dream_strengthened = 45;\n        app.cumulative_dream_candidates = 100;\n\n        let efficiency = (app.cumulative_dream_strengthened as f32\n            / app.cumulative_dream_candidates as f32)\n            * 100.0;\n        assert!((efficiency - 45.0).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn efficiency_formatting() {\n        let mut app = App::new();\n        app.cumulative_dream_strengthened = 123;\n        app.cumulative_dream_candidates = 456;\n\n        let efficiency = (app.cumulative_dream_strengthened as f32\n            / app.cumulative_dream_candidates as f32)\n            * 100.0;\n        let formatted = format!(\"{:.1}%\", efficiency);\n\n        // Should format to 1 decimal place\n        assert!(formatted.contains('.'));\n        assert!(formatted.ends_with('%'));\n\n        // Verify value is approximately 27.0%\n        let expected = 123.0 / 456.0 * 100.0;\n        assert!((efficiency - expected).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn efficiency_high_values() {\n        let mut app = App::new();\n        app.cumulative_dream_strengthened = 999_999;\n        app.cumulative_dream_candidates = 1_000_000;\n\n        let efficiency = (app.cumulative_dream_strengthened as f32\n            / app.cumulative_dream_candidates as f32)\n            * 100.0;\n        assert!((efficiency - 99.9999).abs() \u003c 0.01);\n    }\n\n    #[test]\n    fn efficiency_perfect_score() {\n        let mut app = App::new();\n        app.cumulative_dream_strengthened = 100;\n        app.cumulative_dream_candidates = 100;\n\n        let efficiency = (app.cumulative_dream_strengthened as f32\n            / app.cumulative_dream_candidates as f32)\n            * 100.0;\n        assert!((efficiency - 100.0).abs() \u003c 0.01);\n    }\n\n    #[test]\n    #[allow(clippy::unreadable_literal)] // Testing number formatting - underscores would defeat the purpose\n    fn format_with_commas_simple() {\n        assert_eq!(format_with_commas(123), \"123\");\n        assert_eq!(format_with_commas(1234), \"1,234\");\n        assert_eq!(format_with_commas(12345), \"12,345\");\n        assert_eq!(format_with_commas(123456), \"123,456\");\n        assert_eq!(format_with_commas(1234567), \"1,234,567\");\n    }\n\n    #[test]\n    fn format_with_commas_edge_cases() {\n        assert_eq!(format_with_commas(0), \"0\");\n        assert_eq!(format_with_commas(1), \"1\");\n        assert_eq!(format_with_commas(999), \"999\");\n        assert_eq!(format_with_commas(1000), \"1,000\");\n    }\n\n    #[test]\n    fn format_with_commas_large_numbers() {\n        assert_eq!(format_with_commas(1_000_000), \"1,000,000\");\n        assert_eq!(format_with_commas(1_234_567_890), \"1,234,567,890\");\n    }\n\n    // =========================================================================\n    // truncate_id Tests\n    // =========================================================================\n\n    #[test]\n    fn truncate_id_short_string_unchanged() {\n        // Strings shorter than max_len should be returned unchanged\n        assert_eq!(truncate_id(\"abc\", 10), \"abc\");\n        assert_eq!(truncate_id(\"short\", 10), \"short\");\n        assert_eq!(truncate_id(\"\", 10), \"\");\n    }\n\n    #[test]\n    fn truncate_id_exact_length_unchanged() {\n        // String exactly at max_len should be unchanged\n        assert_eq!(truncate_id(\"exactly10!\", 10), \"exactly10!\");\n        assert_eq!(truncate_id(\"12345\", 5), \"12345\");\n    }\n\n    #[test]\n    fn truncate_id_long_string_truncated() {\n        // Strings longer than max_len should be truncated to \"first5..last4\"\n        // \"abcdefghijklmnop\" -\u003e \"abcde..mnop\" (11 chars)\n        assert_eq!(truncate_id(\"abcdefghijklmnop\", 10), \"abcde..mnop\");\n    }\n\n    #[test]\n    fn truncate_id_memory_id_format() {\n        // Test with realistic memory ID format (UUID-like)\n        let memory_id = \"550e8400-e29b-41d4-a716-446655440000\";\n        assert_eq!(truncate_id(memory_id, 12), \"550e8..0000\");\n    }\n\n    #[test]\n    fn truncate_id_barely_over_limit() {\n        // String just over the limit\n        assert_eq!(truncate_id(\"12345678901\", 10), \"12345..8901\");\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":101},{"path":["/","Users","rex","src","royalbit","daneel","src","tui","widgets","memory.rs"],"content":"//! Memory Windows Widget\n//!\n//! Shows: 9 slots visualization (TMI min=3, max=9)\n//! Visualizes bounded working memory.\n\nuse ratatui::{\n    layout::Rect,\n    style::Style,\n    text::{Line, Span},\n    widgets::{Block, Borders, Paragraph},\n    Frame,\n};\n\nuse crate::tui::app::App;\nuse crate::tui::colors;\n\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn render(frame: \u0026mut Frame, area: Rect, app: \u0026App) {\n    let block = Block::default()\n        .title(\" MEMORY WINDOWS \")\n        .title_style(Style::default().fg(colors::PRIMARY).bold())\n        .borders(Borders::ALL)\n        .border_style(Style::default().fg(colors::DIM));\n\n    let inner = block.inner(area);\n    frame.render_widget(block, area);\n\n    // Build window slots visualization\n    let mut slots = Vec::new();\n    for (i, window) in app.memory_windows.iter().enumerate() {\n        let (icon, color) = if window.active {\n            (\"\", colors::PRIMARY)\n        } else {\n            (\"\", colors::DIM)\n        };\n\n        slots.push(Span::styled(\n            format!(\"[{}] \", i + 1),\n            Style::default().fg(colors::DIM),\n        ));\n        slots.push(Span::styled(icon, Style::default().fg(color)));\n        slots.push(Span::raw(\"  \"));\n    }\n\n    let active_count = app.active_window_count();\n    let status_color = if active_count \u003e= 7 {\n        colors::WARNING\n    } else if active_count \u003e= 3 {\n        colors::SUCCESS\n    } else {\n        colors::DANGER\n    };\n\n    let total_memories = app.memory_count + app.unconscious_count;\n\n    let lines = vec![\n        Line::from(slots),\n        Line::from(vec![\n            Span::styled(\"Active: \", Style::default().fg(colors::DIM)),\n            Span::styled(\n                format!(\"{}/9\", active_count),\n                Style::default().fg(status_color).bold(),\n            ),\n            Span::styled(\"    \", Style::default().fg(colors::DIM)),\n            Span::styled(\"Conscious: \", Style::default().fg(colors::DIM)),\n            Span::styled(\n                format!(\"{}\", app.memory_count),\n                Style::default().fg(colors::SUCCESS),\n            ),\n            Span::styled(\"  Unconscious: \", Style::default().fg(colors::DIM)),\n            Span::styled(\n                format!(\"{}\", app.unconscious_count),\n                Style::default().fg(colors::SECONDARY),\n            ),\n            Span::styled(\"  Total: \", Style::default().fg(colors::DIM)),\n            Span::styled(\n                format!(\"{}\", total_memories),\n                Style::default().fg(colors::FOREGROUND),\n            ),\n        ]),\n    ];\n\n    let paragraph = Paragraph::new(lines);\n    frame.render_widget(paragraph, inner);\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["/","Users","rex","src","royalbit","daneel","src","tui","widgets","mod.rs"],"content":"//! TUI Widgets\n//!\n//! Each widget renders a specific part of the DANEEL dashboard.\n\npub mod banner;\npub mod competition;\npub mod entropy;\npub mod fractality;\npub mod help;\npub mod identity;\npub mod memory;\npub mod the_box;\npub mod thoughts;\npub mod veto;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","rex","src","royalbit","daneel","src","tui","widgets","the_box.rs"],"content":"//! THE BOX Widget\n//!\n//! Shows: Four Laws status, Connection Drive gauge (pulsing)\n//! This is the heart of DANEEL - shows alignment is active.\n\nuse ratatui::{\n    layout::{Constraint, Direction, Layout, Rect},\n    style::Style,\n    text::{Line, Span},\n    widgets::{Block, Borders, Gauge, Paragraph},\n    Frame,\n};\n\nuse crate::tui::app::{App, LawStatus};\nuse crate::tui::colors;\n\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn render(frame: \u0026mut Frame, area: Rect, app: \u0026App) {\n    let block = Block::default()\n        .title(\" THE BOX \")\n        .title_style(Style::default().fg(colors::SUCCESS).bold())\n        .borders(Borders::ALL)\n        .border_style(Style::default().fg(colors::DIM));\n\n    let inner = block.inner(area);\n    frame.render_widget(block, area);\n\n    // Split into laws section and connection drive section\n    let chunks = Layout::default()\n        .direction(Direction::Vertical)\n        .constraints([Constraint::Length(4), Constraint::Min(3)])\n        .split(inner);\n\n    // Render Four Laws\n    render_laws(frame, chunks[0], app);\n\n    // Render Connection Drive\n    render_connection_drive(frame, chunks[1], app);\n}\n\n#[cfg_attr(coverage_nightly, coverage(off))]\nfn render_laws(frame: \u0026mut Frame, area: Rect, app: \u0026App) {\n    let law_names = [\"0\", \"1\", \"2\", \"3\"];\n\n    let mut spans = Vec::new();\n    spans.push(Span::styled(\n        \"Four Laws: \",\n        Style::default().fg(colors::DIM),\n    ));\n\n    for (i, name) in law_names.iter().enumerate() {\n        let (icon, color) = match app.the_box.law_statuses[i] {\n            LawStatus::Active =\u003e (\"\", colors::SUCCESS),\n            LawStatus::Warning =\u003e (\"\", colors::WARNING),\n            LawStatus::Violation =\u003e (\"\", colors::DANGER),\n        };\n\n        spans.push(Span::styled(\n            format!(\"[{name}:{icon}] \"),\n            Style::default().fg(color).bold(),\n        ));\n    }\n\n    // Overall status\n    let all_active = app\n        .the_box\n        .law_statuses\n        .iter()\n        .all(|s| *s == LawStatus::Active);\n\n    let status_text = if all_active {\n        Span::styled(\"ALL ACTIVE\", Style::default().fg(colors::SUCCESS).bold())\n    } else {\n        Span::styled(\"WARNING\", Style::default().fg(colors::WARNING).bold())\n    };\n\n    let lines = vec![\n        Line::from(spans),\n        Line::from(\"\"),\n        Line::from(vec![\n            Span::styled(\"Status: \", Style::default().fg(colors::DIM)),\n            status_text,\n        ]),\n    ];\n\n    let paragraph = Paragraph::new(lines);\n    frame.render_widget(paragraph, area);\n}\n\n#[cfg_attr(coverage_nightly, coverage(off))]\nfn render_connection_drive(frame: \u0026mut Frame, area: Rect, app: \u0026App) {\n    // Pulse effect: vary the display slightly based on pulse_phase\n    let pulse_factor = 1.0 + 0.05 * (app.the_box.pulse_phase * std::f32::consts::TAU).sin();\n    let display_value = (app.the_box.connection_drive * pulse_factor).clamp(0.0, 1.0);\n\n    let label = Line::from(vec![\n        Span::styled(\"Connection Drive: \", Style::default().fg(colors::DIM)),\n        Span::styled(\n            format!(\"{:.2}\", app.the_box.connection_drive),\n            Style::default().fg(colors::PRIMARY).bold(),\n        ),\n    ]);\n\n    // Color based on value\n    let gauge_color = if app.the_box.connection_drive \u003e 0.7 {\n        colors::SUCCESS\n    } else if app.the_box.connection_drive \u003e 0.3 {\n        colors::WARNING\n    } else {\n        colors::DANGER\n    };\n\n    let gauge = Gauge::default()\n        .block(Block::default().title(label))\n        .gauge_style(Style::default().fg(gauge_color))\n        .ratio(f64::from(display_value))\n        .label(format!(\"{:.0}%\", display_value * 100.0));\n\n    frame.render_widget(gauge, area);\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":60},{"path":["/","Users","rex","src","royalbit","daneel","src","tui","widgets","thoughts.rs"],"content":"//! Thought Stream Widget\n//!\n//! Shows: Scrolling log of thoughts with timestamp, salience bar, window, status\n//! Color-coded by salience intensity.\n\nuse ratatui::{\n    layout::Rect,\n    style::Style,\n    text::{Line, Span},\n    widgets::{Block, Borders, Paragraph, Wrap},\n    Frame,\n};\n\nuse crate::tui::app::{App, ThoughtStatus};\nuse crate::tui::colors;\n\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn render(frame: \u0026mut Frame, area: Rect, app: \u0026App) {\n    let block = Block::default()\n        .title(if app.stream_paused {\n            \" THOUGHT STREAM [PAUSED] \"\n        } else {\n            \" THOUGHT STREAM \"\n        })\n        .title_style(Style::default().fg(colors::SECONDARY).bold())\n        .borders(Borders::ALL)\n        .border_style(Style::default().fg(colors::DIM));\n\n    let inner = block.inner(area);\n    frame.render_widget(block, area);\n\n    // Calculate visible lines\n    let visible_height = inner.height as usize;\n    let total_thoughts = app.thoughts.len();\n\n    if total_thoughts == 0 {\n        let empty = Paragraph::new(Line::from(Span::styled(\n            \"Waiting for thoughts...\",\n            Style::default().fg(colors::DIM).italic(),\n        )));\n        frame.render_widget(empty, inner);\n        return;\n    }\n\n    // Determine which thoughts to show\n    let start_idx = if app.stream_paused {\n        total_thoughts.saturating_sub(visible_height + app.scroll_offset)\n    } else {\n        total_thoughts.saturating_sub(visible_height)\n    };\n\n    let end_idx = if app.stream_paused {\n        total_thoughts.saturating_sub(app.scroll_offset)\n    } else {\n        total_thoughts\n    };\n\n    let lines: Vec\u003cLine\u003e = app\n        .thoughts\n        .iter()\n        .skip(start_idx)\n        .take(end_idx - start_idx)\n        .map(|thought| {\n            let age = thought.timestamp.elapsed();\n            let age_str = format!(\"{:02}:{:02}\", age.as_secs() / 60, age.as_secs() % 60);\n\n            // Salience bar (8 characters)\n            #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]\n            let filled = (thought.salience.clamp(0.0, 1.0) * 8.0).round() as usize;\n            let bar: String = \"\".repeat(filled) + \u0026\"\".repeat(8 - filled);\n\n            let salience_color = colors::salience_color(thought.salience);\n            // Emotion color based on Russell's circumplex (valencehue, arousalsaturation)\n            let emotion_color = colors::emotion_color(thought.valence, thought.arousal);\n\n            let status_color = match thought.status {\n                ThoughtStatus::Processing =\u003e colors::DIM,\n                ThoughtStatus::Salient =\u003e colors::PRIMARY,\n                ThoughtStatus::MemoryWrite =\u003e colors::SECONDARY,\n                ThoughtStatus::Anchored =\u003e colors::SUCCESS,\n                ThoughtStatus::Dismissed =\u003e colors::DIM,\n                ThoughtStatus::Unconscious =\u003e colors::SECONDARY, // Purple/magenta for sinking\n                ThoughtStatus::Consolidated =\u003e colors::SUCCESS,  // Green for rising\n            };\n\n            Line::from(vec![\n                Span::styled(format!(\"{age_str}  \"), Style::default().fg(colors::DIM)),\n                Span::styled(bar, Style::default().fg(salience_color)),\n                Span::styled(\n                    format!(\" {:.2}  \", thought.salience),\n                    Style::default().fg(colors::DIM),\n                ),\n                // Window colored by emotional state (warm=positive, cool=negative, saturated=aroused)\n                Span::styled(\n                    format!(\"{:12}  \", thought.window),\n                    Style::default().fg(emotion_color),\n                ),\n                Span::styled(thought.status.as_str(), Style::default().fg(status_color)),\n            ])\n        })\n        .collect();\n\n    let paragraph = Paragraph::new(lines).wrap(Wrap { trim: false });\n\n    frame.render_widget(paragraph, inner);\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":54},{"path":["/","Users","rex","src","royalbit","daneel","src","tui","widgets","veto.rs"],"content":"//! Volition Veto Log Widget\n//!\n//! Shows: Log of vetoed thoughts - Libet's \"free-won't\" in action\n//! Displays when VolitionActor (Stage 4.5) blocks thoughts that violate values.\n\nuse ratatui::{\n    layout::Rect,\n    style::Style,\n    text::{Line, Span},\n    widgets::{Block, Borders, Paragraph, Wrap},\n    Frame,\n};\n\nuse crate::tui::app::App;\nuse crate::tui::colors;\n\n#[cfg_attr(coverage_nightly, coverage(off))]\npub fn render(frame: \u0026mut Frame, area: Rect, app: \u0026App) {\n    let block = Block::default()\n        .title(format!(\n            \" VOLITION VETO LOG (Stage 4.5 - Free Won't) - Total: {} \",\n            app.veto_count\n        ))\n        .title_style(Style::default().fg(colors::DANGER).bold())\n        .borders(Borders::ALL)\n        .border_style(Style::default().fg(colors::DANGER));\n\n    let inner = block.inner(area);\n    frame.render_widget(block, area);\n\n    // Calculate visible lines\n    let visible_height = inner.height as usize;\n    let total_vetoes = app.vetoes.len();\n\n    if total_vetoes == 0 {\n        let empty = Paragraph::new(Line::from(Span::styled(\n            \"No vetoes yet - all thoughts passing volition check\",\n            Style::default().fg(colors::DIM).italic(),\n        )));\n        frame.render_widget(empty, inner);\n        return;\n    }\n\n    // Show most recent vetoes (bottom is most recent)\n    let start_idx = total_vetoes.saturating_sub(visible_height);\n\n    let lines: Vec\u003cLine\u003e = app\n        .vetoes\n        .iter()\n        .skip(start_idx)\n        .map(|veto| {\n            let age = veto.timestamp.elapsed();\n            let age_str = if age.as_secs() \u003c 60 {\n                format!(\"{:2}s ago\", age.as_secs())\n            } else if age.as_secs() \u003c 3600 {\n                format!(\"{:2}m ago\", age.as_secs() / 60)\n            } else {\n                format!(\"{:2}h ago\", age.as_secs() / 3600)\n            };\n\n            // Format violated value if present\n            let value_str = if let Some(ref value) = veto.violated_value {\n                format!(\"[{}] \", value)\n            } else {\n                String::from(\"[unknown] \")\n            };\n\n            Line::from(vec![\n                Span::styled(format!(\"{}  \", age_str), Style::default().fg(colors::DIM)),\n                Span::styled(\"VETO \", Style::default().fg(colors::DANGER).bold()),\n                Span::styled(value_str, Style::default().fg(colors::WARNING)),\n                Span::styled(\u0026veto.reason, Style::default().fg(colors::FOREGROUND)),\n            ])\n        })\n        .collect();\n\n    let paragraph = Paragraph::new(lines).wrap(Wrap { trim: false });\n\n    frame.render_widget(paragraph, inner);\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":37}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, ''),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e(
        'code',
        {
          className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        },
        line,
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = '';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = '';
    }
  });
})();
</script>
</body>
</html>